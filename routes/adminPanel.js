const express = require("express");
const mongoose = require("mongoose");
const moment = require("moment");
const fs = require('fs/promises');
const XLSX = require('xlsx');
const jwt = require("jsonwebtoken");
const { isAdmin, ValidateToken, isTeacher } = require("../middleware/authenticateToken");
const { BannerTable } = require("../models/BannerSchema");
const AdminPanel = express.Router();
const { adminTeacherTable } = require("../models/adminTeacherModel");
const { YouTube_Url } = require("../models/YouTubeSchema");
const { Telegram_Channel } = require("../models/Telegram_Channel");
const { Contact_Info } = require("../models/Contact_info");
const { ResourcesTable } = require("../models/Resources");
const { NotesTable } = require("../models/Notes");
const { NewsClipsTable } = require("../models/News_clips");
const { AIRTable } = require("../models/allIndiaRadio");
const { BatchesTable } = require("../models/BatchesSchema");
const { AssignmentTable } = require("../models/Assignments");
const { TestimonialTable } = require("../models/Testimonials");
const { categoryTable } = require("../models/category");
const { subCategoryTable } = require("../models/subCategory");
const { previousYearQuestionPapersTable } = require("../models/previousYearQuestionPapers");
const { UserTable } = require("../models/userModel");
const { LectureTable } = require("../models/addLecture");
const { uploadFile } = require("../aws/UploadFile");
// const {  deleteFileFromBucket } = require("../aws/deleteS3Object");
const multer = require("multer");
const { CartTable } = require("../models/cart");
const { MybatchTable } = require("../models/MyBatches");
const { SubjectTable } = require("../models/Subject");
const { SchedularTable } = require("../models/Schedular");
const { LectureResourceTable } = require("../models/lectureResources");
const { paymentTransactionTestSeries } = require("../models/TestPaymentTransaction")
const { paymentTransactionTable } = require("../models/paymentTransaction");
const { ctaTable } = require("../models/CTA");
const xlsjs = require("xlsjs");
const {
    formatDate,
    formatTodaysDate,
    getDateDifference,
} = require("../middleware/dateConverter");
const path = require("path");
const { issueReport } = require("../models/IssueReport");
const { DoubtTable } = require("../models/QuizDoubt");
const { QuizTable } = require("../models/Quiz");
const { QuizQuestionsTable } = require("../models/Quiz_question");
const { QuizResponseTable } = require("../models/QuizResponse");
const { userRequestModel } = require("../models/userRequestsModel");
const { json } = require("express");
const { isSameDevice } = require("../middleware/checkUserDevice");
const { NotificationModel } = require("../models/Notification");
const { RecordedVideoModel } = require("../models/addRecordedVideos");
const { QuizResumeTable } = require("../models/resumeQuiz");
const { sendEmail } = require("../ContactUser/NodeMailer");
const {
    findUserByEmail,
    findUserByUserId,
    findUserByMobileNumber,
    getFcmTokenArrByUserIdArr,
    verifyUserIds,
    saveRefAmount,
    sendWAmessageUserBatchAssign
} = require("../HelperFunctions/userFunctions");
const { invoiceHelper } = require("../HelperFunctions/invoiceHelper")
const {batchExtendInvoiceHelper} = require ("../HelperFunctions/batchExtendInvoiceHelper")
const { checkPayment } = require("../HelperFunctions/checkPayment")
const { savePanelEventLogs } = require("../HelperFunctions/storeLogs")
const {
    findAdminTeacherUsingUserId,
} = require("../HelperFunctions/adminTeacherFunctions");
const { TestSeriesTable } = require("../models/TestSeries");
const { TestSeriesTestTable } = require("../models/testseriestest");
const { MyAttemptedTestTable } = require("../models/myAttemptedTest");
const { MyTestSeriesTable } = require("../models/myTestSeries");
const { attemptTest } = require("../models/attemptTest");
const {
    TestSeriesDetails,
    TestDetailsByTestId,
} = require("../HelperFunctions/TestSeriesFunctions");
const {
    sendNotificationTeacher,
} = require("../ContactUser/NotificationAdminSide");
const { TestQuestionsTable } = require("../models/TestQuestions");
const { ResponseTestTable } = require("../models/ResponeTestQuestions");
const { Timer } = require("../models/Timer");
const { couponTable } = require("../models/Coupon");
const { alertTable } = require("../models/alert");
const { AppliedCoinsTable } = require("../models/appliedCoins")
const { walletTxnTable } = require("../models/walletTxn")
const { withdrawalRequestTable } = require("../models/withdrawlRequest")
const {
    getChatIdFromUrl,
    getYtToken,
} = require("../HelperFunctions/ytLiveChatId");
const { sendBulkPushNotifications, sendPushNotification } = require("../firebaseService/fcmService");
const { myNotificationModel } = require("../models/myNotification");
// const { sendPushNotification } = require("../firebaseService/fcmService.js");
const { leaderBoardTable } = require("../models/leaderboard");
const { timeSpendOnLecture } = require("../models/timeSpendOnLecture");
const { storeProductTable } = require("../models/storeProduct");
const { productCategoryTable } = require("../models/productCategory");
const { scholarshipTestTable } = require("../models/scholarshipTest");
const { scholarshipRegTable } = require("../models/scholarshipReg");
const { announcementTable } = require("../models/announcements");
const { generateSlug } = require("../HelperFunctions/generateSlug");
const { pdfGenerate } = require("../HelperFunctions/invoiceGenrationBatch");
const { pdfStoreGenerate } = require("../HelperFunctions/invoiceGenrationStore");
const { isSubSet } = require("../HelperFunctions/isSubSet")
const { v1: uuidv1, validate } = require("uuid");
const apicache = require("apicache")
const { generateSlugForCommonName } = require("../HelperFunctions/genrateSlugForCommonName");
const { newPdfGenerate } = require('../HelperFunctions/invoiceGenrationForBatchNewPayment');

const { sendWAOTP, campusSignup, batchPurchaseSuccess } = require("../HelperFunctions/whatsAppTemplates")
const { batchValidityFeatures } = require("../HelperFunctions/validity_features")

// import apicache from 'apicache'
let cache = apicache.middleware

const storage = multer.diskStorage({
    destination: function (req, file, cb) {
        cb(null, "uploads/adminPanel");
    },
    filename: function (req, file, cb) {
        cb(
            null,
            file.fieldname + "-" + Date.now() + path.extname(file.originalname)
        );
    },
});

const fileDetails = (file, fileLoc) => {
    const filename = (file.originalname.split(".")[0]).replace(/\s+/g, '_').replace(/[^a-zA-Z0-9_]/g, '');
    return {
        fileLoc: fileLoc,
        fileName: filename,
        fileSize: `${(file.size / 1000000).toFixed(2)} MB`,
    };
};


function formatTimer(timeInMinutes) {
    let hours = Math.floor(timeInMinutes / 60);
    let minutes = Math.floor(timeInMinutes % 60);
    let seconds = Math.floor((timeInMinutes * 60) % 60);

    // add leading zero if needed
    if (hours < 10) {
        hours = "0" + hours;
    }
    if (minutes < 10) {
        minutes = "0" + minutes;
    }
    if (seconds < 10) {
        seconds = "0" + seconds;
    }

    return hours + ":" + minutes + ":" + seconds;
}

const addBatchEmail = async (templateName, data) => {
    const users = await UserTable.find({});
    // console.log(users.length);
    for (let i = 0; i < users.length; i++) {
        sendEmail(templateName, users[i].email, users[i].FullName, data);
    }
};

const uploadTester = multer({ storage: storage });
const uploadMulter = multer();

const upload = multer({ dest: "uploads/adminPanel" });

function generateRandomNumber(numberOfCharacters) {
    var randomValues = "";
    var stringValues = "ABCDEFGHIJKLMNOabcdefghijklmnopqrstuvwxyzPQRSTUVWXYZ";
    var sizeOfCharacter = stringValues.length;
    for (var i = 0; i < numberOfCharacters; i++) {
        randomValues =
            randomValues +
            stringValues.charAt(Math.floor(Math.random() * sizeOfCharacter));
    }
    return randomValues;
}

const { admin } = require("../routes/pushNotification");
const { blogsTable } = require("../models/blog");
const { currentCategory } = require("../models/currentCateggory");
const { storeWishlistTable } = require("../models/storeWishlist");
const { courseTxnTable } = require("../models/coursePaymentTxn");
const { storeTxnTable } = require("../models/storePaymentTxn");
const { presentorderIdtable } = require("../models/presentOrderIdModel");
const { convertSecondsToTime } = require("../HelperFunctions/secondsToTime");
const { courseOrdesTable } = require("../models/courseOrder");
const { lectureRoomTable } = require("../models/lectureRoom");
const { logsTables } = require("../models/logs");
const { roomCreation } = require("../HelperFunctions/roomCreation");
const { roomAssign } = require("../HelperFunctions/roomAssign");
const { populate } = require("dotenv");
const { emiTxnTable } = require("../models/emiTransaction");
const { refreshToken } = require("firebase-admin/app");
const { faqsTable } = require("../models/FAQs");
const { invoiceTable } = require("../models/Invoice");
const { userStoreLogsTable } = require("../models/userStoreLogs");
const { lectureReportTable } = require("../models/lectureReport");
const { genrateDeepLink } = require("../HelperFunctions/genrateDeepLink");
const { cmsPostTable } = require("../models/CmsPost");
const { my } = require("translate-google/languages");
const { saleEmiTable } = require("../models/saleEmi");
const { storeCartTable } = require("../models/storeCart");
const { storeUserAddressTable } = require("../models/storeUserAddress");
const { getLatestBatchId } = require("../HelperFunctions/getLastestBatchId");
const { ValidityTable } = require("../models/Validity");
const { storeOrdesTable } = require("../models/storeOrders");
const { BatchFeature } = require("../models/BatchFeature");
const { badWordCheck } = require('../HelperFunctions/BadWordCheck');
const { SendOtpSms } = require("../ContactUser/SendMessage");
const { ValidityFeatureTable } = require("../models/ValidityFeature");
const { shortTable } = require("../models/Short");
const { channelTable } = require("../models/Channel");
// const uploadVideo = require("../aws/uploadVideo");
const { cldrBookingUsrData } = require("../HelperFunctions/crmTracking")

// const { quizResult } = require("../HelperFunctions/getQuizResult");
// const { sendWhatsappMessage } = require("../HelperFunctions/sendWhatsappMessage");
// const mongoose = require("mongoose")

//<--ADMIN PANEL -->

const sendCustomNotification = async (userIdArr, data) => {
    let tokenArr = [];
    if (userIdArr === "all") {
        const users = await UserTable.find({});
        tokenArr = users.filter((e) => e?.fcmToken).map((e) => e.fcmToken);
    } else if (userIdArr?.length > 0) {
        tokenArr = await getFcmTokenArrByUserIdArr(userIdArr);
    } else {
        const users = await UserTable.find({ email: "govind.s@sdempire.co.in" })
            .sort({ createdAt: -1 })
            .limit(1);
        tokenArr = users.filter((e) => e?.fcmToken != "").map((e) => e.fcmToken);
    }
    // return newSendBulkNotiifcations(tokenArr , data)
    return sendBulkPushNotifications(tokenArr, data);
    // return sendNotificationsToUsers(tokenArr , data);
};

// <---------- Email Testing ----------->
AdminPanel.post("/convertExcelToJson", async (req, res) => {
    // Load Excel file

    const workbook = xlsx.readFile('/Users/govindsuman/Desktop/Govind Suman/SD Empire/backend/janInvoice.xlsx');
    const sheetName = workbook.SheetNames[0]; // Assuming data is in the first sheet
    const worksheet = workbook.Sheets[sheetName];

    // Convert Excel data to JSON
    const jsonData = xlsx.utils.sheet_to_json(worksheet, { header: 1 });
    jsonData.shift();
    // Remove empty rows
    const filteredData = jsonData.filter(row => row.some(cell => cell !== ''));

    // Convert each row to the desired JSON format
    const convertedData = filteredData.map(row => (
        console.log(typeof (row[0])), {

            "invoiceDate": row[0],
            "studentName": row[1],
            "studentEmail": row[2] || "N/A",
            "studentPhone": row[3] ? parseInt(row[3]) : "N/A",
            "items": [{
                "name": row[4],
                "price": parseInt(row[5]),
                "quantity": row[6]
            }],
            "studentAddress": row[7],
            "SDAddress": row[8],
            "studentState": row[9],
            "gstNumber": row[10]
        }));
    // console.log(convertedData)
    const jsonString = JSON.stringify(convertedData, null, 4);

    // Define the file path where you want to save the JSON data
    const filePath = '/Users/govindsuman/Desktop/Govind Suman/SD Empire/backend/convertedData.json';

    // Write JSON data to a file
    fs.writeFile(filePath, jsonString, 'utf-8', (err) => {
        if (err) {
            console.error('Error writing JSON to file:', err);
            return;
        }
        console.log('JSON data has been written to:', filePath);
    });



    return res.status(200).json({
        status: true,
        data: null,
        msg: "Converted",
    });
})

// <=========== INVOICE GENERATION ========>

AdminPanel.post("/invoiceGen", async (req, res) => {


    // const data = {
    //   invoiceNumber: 15678,
    //   invoiceDate: "02/12/2023 11:05:00",
    //   studentName: "Deepa Dwivedi",
    //   studentAddress: `Uttar Pradesh`,
    //   SDAddress: `Plot No-16, Block 7, Sector 5, Rajendra Nagar, Ghaziabad,Uttar Pradesh, 201005`,
    //   items: [{ name: "TestSeries", price: 99, quantity: 1 }],
    //   studentEmail: "deepadwivedi1997@gmail.com",
    //   studentPhone: "7054573517",
    //   studentState: "Uttar Pradesh",
    //   gstNumber: "09ABBCS1440F1ZN"

    // };
    // await pdfGenerate(data)
    const testArr = []
    for (let i = 0; i < testArr.length; i++) {
        let intVal = 412
        await pdfGenerate({
            invoiceNumber: intVal + i,
            invoiceDate: testArr[i].invoiceDate,
            studentName: testArr[i].studentName,
            studentEmail: testArr[i].studentEmail,
            studentPhone: testArr[i].studentPhone,
            items: testArr[i].items,
            studentAddress: testArr[i].studentAddress,
            SDAddress: testArr[i].SDAddress,
            studentState: testArr[i].studentState,
            gstNumber: testArr[i].gstNumber

        })
        // testArr.invoiceNumber = testArr[i] + 1
    }



    return res.status(200).json({
        status: true,
        data: null,
        // data: cursor.map((item) => item.title),
        // data: products?.map((item) => {
        //   return {
        //     title: item.title,
        //     url: `https://store.sdcampus.com/p/${item.category.slug}/${item?.slug}`

        //   }
        // }),
        msg: "mail function checking",
    });
})

// <=========== REFERAL AND EARN ==========>

async function userWalletAmount(userId) {
    const wlmBonus = 51;

    const user = await UserTable.findOne({ _id: userId }, { refUserIds: 1 });
    const refCount = user.refUserIds.length;
    const refAmount = refCount * 21;

    const [withdrawalAmountResult] = await Promise.all([
        walletTxnTable.aggregate([
            { $match: { user: userId, action: 'withdrawal' } },
            { $group: { _id: null, amount: { $sum: { $toInt: "$amount" } } } }
        ])
    ]);
    const withdrawalAmount = withdrawalAmountResult.length > 0 ? withdrawalAmountResult[0].amount : 0;
    const walletBalance = wlmBonus + refAmount - withdrawalAmount;

    return walletBalance;
}
// Student Route
AdminPanel.get("/getRefaralContent", ValidateToken, async (req, res) => {
    try {
        const decoded = jwt.verify(req.token, process.env.SECRET_KEY);
        const studentDetails = await findUserByUserId(decoded.studentId);

        if (studentDetails) {
            const refObj = {
                referial_amount: `1000`,
                url: 'https://links.sdcampus.com/C5sz',
            }
            return res.json({
                status: true,
                data: refObj,
                msg: "Success",
            });
        } else {
            return res.json({
                status: false,
                data: null,
                msg: "User not found",
            });
        }
    } catch (err) {
        res.status(401).json({
            status: false,
            data: null,
            msg: err.message,
        });
    }
});


AdminPanel.get("/getRefaralTxn", ValidateToken, async (req, res) => {
    try {
        const decoded = jwt.verify(req.token, process.env.SECRET_KEY);
        const studentDetails = await findUserByUserId(decoded.studentId);

        if (studentDetails) {
            const wallaetTxn = await walletTxnTable.find({ user: studentDetails._id })
            const walletAmount = await userWalletAmount(studentDetails._id)
            return res.json({
                status: true,
                data: {
                    walletAmount: walletAmount.toString(),
                    transactions: wallaetTxn.map((item) => {
                        return {
                            action: item.action,//'add', 'withdrawal'
                            reason: item.reason,
                            amount: item.amount,
                            dateTime: item.dateTime
                        }
                    })
                },
                msg: "Transaction History",
            });
        } else {
            return res.json({
                status: false,
                data: null,
                msg: "User not found",
            });
        }
    } catch (err) {
        res.status(401).json({
            status: false,
            data: null,
            msg: err.message,
        });
    }
});

AdminPanel.post("/withdrawalRequest", ValidateToken, async (req, res) => {
    const { upiId, amount } = req.body
    try {
        const decoded = jwt.verify(req.token, process.env.SECRET_KEY);
        const studentDetails = await findUserByUserId(decoded.studentId);

        if (studentDetails) {
            const wdrReq = await withdrawalRequestTable.find({ user: studentDetails._id, status: { $nin: 'accepted' } })
            if (wdrReq.length > 0) {
                return res.json({
                    status: true,
                    data: null,
                    msg: "Already requested"
                })
            }
            const walletAmount = await userWalletAmount(studentDetails._id)
            if (walletAmount < amount || amount < 300) {
                return res.json({
                    status: false,
                    data: null,
                    msg: "Withdrawalble amount must be 300 or >300"
                })
            }
            const date = new Date(moment().add(5, "hours").add(30, "minutes"));
            const upiInfoObj = new withdrawalRequestTable({
                user: studentDetails._id,
                upiId,
                amount,
                status: 'pending',
                createdAt: formatDate(date),
                updatedAt: formatDate(date)
            })
            const saveUpiInfo = await upiInfoObj.save()
            console.log()
            return res.json({
                status: true,
                data: saveUpiInfo,
                msg: "Withdrawal request sent",
            });
        } else {
            return res.json({
                status: false,
                data: null,
                msg: "User not found",
            });
        }
    } catch (err) {
        res.status(401).json({
            status: false,
            data: null,
            msg: err.message,
        });
    }
});

// <----------- USERS REPORT SECTION ----------->

function formatDatetime(inputDatetime) {
    const parsedDatetime = new Date(inputDatetime);
    const formattedDatetime = `${String(parsedDatetime.getDate()).padStart(2, '0')}-${String(
        parsedDatetime.getMonth() + 1
    ).padStart(2, '0')}-${parsedDatetime.getFullYear()} ${String(parsedDatetime.getHours()).padStart(2, '0'
    )}:${String(parsedDatetime.getMinutes()).padStart(2, '0')}:${String(parsedDatetime.getSeconds()).padStart(2, '0')}`;
    return formattedDatetime;
}



AdminPanel.post("/query", async (req, res) => {
    try {
        // const obj = {
        //     name: "GovindCRMTest1",
        //     email: "govind.s@sdempire.co.in",
        //     phone: "919983904397",
        //     utm_source: 'demo_booking',
        //     utm_campaign: 'demo_booking_sainik_6th_class',
        //     utm_medium: "demo_booking_form_submit",
        //     platform: 'website',
        //     category: "School Entrance Exams",
        //     subCategory: "Sainik School",
        // }
        // const submtData = await cldrBookingUsrData(obj)
        // const dataObj = {
        //     date: "01 April 2025",
        //     startTime: "5:00 PM",
        //     endTime: "5:45 PM",
        //     meetLink: "https://meet.google.com/vhs-bsky-bzv",
        //     eventName: "SD Campus for Sainik/JNV Demo Class"
        // }
        // await sendEmail("DemoSessionConfirmedImmediately", 'govind.s@sdempire.co.in', "Govind", dataObj)
        // await ()
        // const istTime = moment.utc(inpt).tz("Asia/Kolkata").format("DD MMMM YYYY, h:mm A");
        // const dataObj = {
        //     name: "Govind",
        //     phone: "9983904397",
        //     // invoiceUrl: "https://static.sdcampus.com/invoice/invoice/SDC_Online_23_24_0.7166221754867805_1734847919.pdf",
        //     // batchName: "Sainik School 2025-26 Complete Live Foundation Batch for Class 9th"
        // }
        // await sendWAmessageUserBatchAssign("6588a16c9d5618633c7cdea2", "669a4dfb2c5cc52213da46b5")
        // await campusSignup(dataObj)
        // await batchPurchaseSuccess(dataObj)

        // let dataObj = {
        //     orderId: orders?.orderId,
        //     mobileNumber: orders?.user?.mobileNumber,
        //     totalAmount: orders?.totalAmount,
        //     product: orders?.products?.map((item) => {
        //         return {
        //             title: item?.productId?.title ?? "",
        //             image: item?.productId?.featuredImage ?? "",
        //             qty: item?.quantity ?? "",
        //             // amount : item?.productId?.regularPrice ?? ""
        //         }
        //     }),
        //     orderStatus: "placed",
        // }\\\


        let dataObj = {
            orderId: '99993',
            mobileNumber: "+919983904397",
            totalAmount: '5789',
            product: [
                {
                    title: "SSC CGL Integrated Bachelor's Program Tier-1 Online Pattern: 20 Model Papers - SD Publication",
                    image: "https://d1mbj426mo5twu.cloudfront.net/StoreProduct/productGallery/SSC%20CGL%20Integrated%20Bachelor%27s%20Program%20Tier-1%20Online%20Pattern%3A%2020%20Model%20Papers%20-%20SD%20Publication/SD0330_1_1721649213.jpg",
                    qty: "4",
                },
                {
                    title: "CTET/UPTET Child Development Education Science Complete Study Package with 10 Practice Sets & Solutions Based on NCF & NIOS Including Special Children Paper (1 & 2) - SD Publication",
                    image: "https://d1mbj426mo5twu.cloudfront.net/StoreProduct/productGallery/Ctet%7CUptet%20Paper%201/2%20Bal%20Vikas%20Shiksha%20Shastra%20Complete%20Study%20Package%20%28Hindi%20Medium%29/SD0313%20%28100kb%29_1709184763.png",
                    qty: "5",
                }
            ],
            orderStatus: "placed",
        }


        // await sendEmail("publicationWebsiteOrderPlaced", 'govind.s@sdempire.co.in', "Govind", dataObj)

        return res.json({
            status: true,
            data: null,
            msg: "Success"
        })
        // if (submtData) {
        //     return res.json({
        //         status: true,
        //         data: obj,
        //         msg: "Success"
        //     })
        // } else {
        //     return res.json({
        //         status: false,
        //         data: null,
        //         msg: "Success"
        //     })
        // }

    } catch (error) {
        return res.json({
            status: false,
            data: null,
            msg: error.message
        });
    }
})
// User Purchase report
AdminPanel.post("/purchaseReport", isAdmin, async (req, res) => {
    let { type, valueId, startAt, endAt } = req.body;
    try {
        if (!type || !valueId) {
            return res.status(400).json({
                status: false,
                data: null,
                msg: "Missing required field(s). Please provide type and valueId.",
            });
        }
        const decoded = jwt.verify(req.token, process.env.ADMIN_SECRET_KEY);
        const adminDetails = await findAdminTeacherUsingUserId(decoded.studentId);
        if (!adminDetails) {
            return res.status(401).json({
                status: false,
                data: null,
                msg: "Not an admin",
            });
        }
        startAt = moment(startAt, "YYYY-MM-DD").format("YYYY-MM-DD HH:mm:ss");
        endAt = moment(endAt, "YYYY-MM-DD").set({ hour: 23, minute: 59, second: 59, millisecond: 0 }).format("YYYY-MM-DD HH:mm:ss");
        // console.log(startAt+" "+endAt);
        if (type === "batch") {
            let filterQ = {};
            if (valueId === "all") {
                filterQ = {
                };
            } else {
                filterQ = {
                    batch_id: valueId,
                }
            }
            // console.log("Batch Filter", filterQ)
            let batch = await MybatchTable.find(filterQ).populate("user").populate("batch_id");
            // console.log(batch.length);
            batch = batch.filter((item) => {
                let date = moment(item?.created_at, "DD-MM-YYYY HH:mm:ss").format('YYYY-MM-DD HH:mm:ss')
                if (moment(date, "YYYY-MM-DD HH:mm:ss").isBetween(moment(startAt, 'YYYY-MM-DD HH:mm:ss'), moment(endAt, 'YYYY-MM-DD HH:mm:ss'))) {
                    return item;
                }
            })
            // console.log(batch.length);
            // batch = [...new Set(batch)];
            let resData = []
            for (let i = 0; i < batch.length; i++) {
                let obj = {};
                let couponDetails = {
                    code: "NA",
                    value: "NA",
                    type: "NA",
                }
                let txnsDetails = await paymentTransactionTable.findOne({ user: batch[i].user?._id, batch_name: batch[i].batch_id?.batch_name }).populate('couponId', '_id couponCode couponValue couponType');
                if (txnsDetails?._id) {
                    couponDetails = {
                        code: txnsDetails?.couponId?.couponCode ?? "NA",
                        value: txnsDetails?.couponId?.couponValue ?? "NA",
                        type: txnsDetails?.couponId?.couponType ?? "NA",
                    }
                    obj = {
                        txnId: "",
                        transactionUserOrederId: txnsDetails?.userOrederId ?? "",
                        transactionId: txnsDetails?.payment_id ?? "",
                        transactionAmount: txnsDetails?.amount ?? "",
                        remark: txnsDetails?.remark ?? "",
                        transactionDate: txnsDetails?.transactionDate ?? "",
                        invoice: txnsDetails?.invoice,
                        couponDetails
                    }
                } else {
                    let courseOrder = await courseOrdesTable.findOne({ user: batch[i]?.user?._id, courseId: batch[i]?.batch_id, isPaid: true }).populate('couponId', '_id couponCode couponValue couponType');
                    if (courseOrder?._id) {
                        couponDetails = {
                            code: courseOrder?.couponId?.couponCode ?? "NA",
                            value: courseOrder?.couponId?.couponValue ?? "NA",
                            type: courseOrder?.couponId?.couponType ?? "NA",
                        }
                        obj = {
                            txnId: "",
                            transactionUserOrederId: courseOrder?.orderId ?? "",
                            transactionId: courseOrder?.txnId ?? "",
                            transactionAmount: courseOrder?.totalAmount ?? "",
                            transactionDate: courseOrder?.purchaseDate ?? "",
                            remark: courseOrder?.remark ?? "",
                            invoice: courseOrder?.invoice,
                            couponDetails
                        }
                    }
                }
                // console.log(obj)
                resData.push(
                    {
                        id: batch[i]._id,
                        userId: batch[i].user?._id,
                        enrollId: batch[i].user?.enrollId,
                        icon: batch[i].user?.profilePhoto,
                        name: batch[i].user?.FullName,
                        email: batch[i].user?.email,
                        phone: batch[i].user?.mobileNumber,
                        category: batch[i].user?.Stream,
                        value: `${batch[i].batch_id?.batch_name} - ${batch[i].batch_id?.batchId}`,
                        amount: batch[i].amount,
                        prices: { regularPrice: batch[i]?.batch_id?.charges, salePrice: batch[i]?.batch_id?.discount },
                        // salePrice :  
                        // ...obj,
                        // txnId: "",
                        // transactionUserOrederId: txnsDetails?.userOrederId ?? "",
                        // transactionId: txnsDetails?.payment_id ?? "",
                        // transactionAmount: txnsDetails?.amount ?? "",
                        // transactionDate: txnsDetails?.transactionDate ?? "",
                        invoice: txnsDetails?.invoice,
                        is_paid: batch[i].is_paid,
                        is_active: batch[i].is_active,
                        purchaseAt: batch[i].created_at,
                        ...obj,
                    }
                )
            }
            return res.json({
                status: true,
                data: resData,
                msg: "Purchase Report",
            });
        } else if (type === "testseries") {
            let filterQ = {};
            // console.log(valueId)
            if (valueId === "all") {
                filterQ = {
                };
            } else {
                filterQ = {
                    testseries_id: valueId,
                };
            }
            // console.log(filterQ)
            let testSeries = await MyTestSeriesTable.find(filterQ).populate("user").populate("testseries_id")
            testSeries = testSeries.filter((item) => {
                let date = moment(item?.created_at, "DD-MM-YYYY HH:mm:ss").format('YYYY-MM-DD HH:mm:ss')
                if (moment(date, "YYYY-MM-DD HH:mm:ss").isBetween(moment(startAt, 'YYYY-MM-DD HH:mm:ss'), moment(endAt, 'YYYY-MM-DD HH:mm:ss'))) {
                    return item;
                }
            })
            testSeries = [...new Set(testSeries)]
            let resData = []
            for (let i = 0; i < testSeries.length; i++) {
                let txnsDetails = await paymentTransactionTestSeries.findOne({ user: testSeries[i]?.user?._id, TestSeries_name: testSeries[i]?.testseries_id?.testseries_name })
                resData.push(
                    {
                        id: testSeries[i]._id,
                        enrollId: testSeries[i]?.user?.enrollId,
                        userId: testSeries[i]?.user?._id,
                        icon: testSeries[i]?.user?.profilePhoto,
                        name: testSeries[i]?.user?.FullName,
                        email: testSeries[i]?.user?.email,
                        phone: testSeries[i]?.user?.mobileNumber,
                        category: testSeries[i]?.user?.Stream,
                        value: testSeries[i]?.testseries_id?.testseries_name,
                        amount: testSeries[i]?.amount,
                        txnId: "",
                        transactionUserOrederId: txnsDetails?.userOrederId ?? "",
                        transactionId: txnsDetails?.payment_id ?? "",
                        transactionAmount: txnsDetails?.amount ?? "",
                        transactionDate: txnsDetails?.transactionDate ?? "",
                        is_paid: testSeries[i]?.is_paid,
                        is_active: testSeries[i]?.is_active,
                        purchaseAt: testSeries[i]?.created_at,
                        prices: { regularPrice: testSeries[i]?.testseries_id?.charges, salePrice: testSeries[i]?.testseries_id?.discount },

                    }
                )
            }
            return res.json({
                status: true,
                data: resData,
                msg: "Purchase Report",
            });
        } else {
            let filterQ = {};
            let couponDetails = {
                code: 'NA',
                value: "NA",
                type: 'NA',
            }
            // console.log(filterQ)
            let testSeries = await MyTestSeriesTable.find(filterQ).populate("user").populate("testseries_id")
            testSeries = testSeries.filter((item) => {
                let date = moment(item?.created_at, "DD-MM-YYYY HH:mm:ss").format('YYYY-MM-DD HH:mm:ss')
                if (moment(date, "YYYY-MM-DD HH:mm:ss").isBetween(moment(startAt, 'YYYY-MM-DD HH:mm:ss'), moment(endAt, 'YYYY-MM-DD HH:mm:ss'))) {
                    return item;
                }
            })
            let resData = []
            for (let i = 0; i < testSeries.length; i++) {
                let txnsDetails = await paymentTransactionTestSeries.findOne({ user: testSeries[i]?.user?._id, TestSeries_name: testSeries[i]?.testseries_id?.testseries_name })
                resData.push(
                    {
                        id: testSeries[i]._id,
                        enrollId: testSeries[i]?.user?.enrollId,
                        userId: testSeries[i]?.user?._id,
                        icon: testSeries[i]?.user?.profilePhoto,
                        name: testSeries[i]?.user?.FullName,
                        email: testSeries[i]?.user?.email,
                        phone: testSeries[i]?.user?.mobileNumber,
                        category: testSeries[i]?.user?.Stream,
                        value: testSeries[i]?.testseries_id?.testseries_name,
                        amount: testSeries[i]?.amount,
                        txnId: "",
                        transactionUserOrederId: txnsDetails?.userOrederId ?? "",
                        transactionId: txnsDetails?.payment_id ?? "",
                        transactionAmount: txnsDetails?.amount ?? "",
                        transactionDate: txnsDetails?.transactionDate ?? "",
                        is_paid: testSeries[i]?.is_paid,
                        is_active: testSeries[i]?.is_active,
                        purchaseAt: testSeries[i]?.created_at,
                        prices: { regularPrice: testSeries[i]?.testseries_id?.charges, salePrice: testSeries[i]?.testseries_id?.discount },
                        couponDetails,
                    }
                )
            }
            let batch = await MybatchTable.find(filterQ).populate("user").populate("batch_id");
            // console.log(batch.length);
            batch = batch.filter((item) => {
                let date = moment(item?.created_at, "DD-MM-YYYY HH:mm:ss").format('YYYY-MM-DD HH:mm:ss')
                if (moment(date, "YYYY-MM-DD HH:mm:ss").isBetween(moment(startAt, 'YYYY-MM-DD HH:mm:ss'), moment(endAt, 'YYYY-MM-DD HH:mm:ss'))) {
                    return item;
                }
            })
            for (let i = 0; i < batch.length; i++) {
                // const txnsDetails = await 
                let obj = {};
                let txnsDetails = await paymentTransactionTable.findOne({ user: batch[i].user?._id, batch_name: batch[i].batch_id?.batch_name }).populate('couponId', '_id couponCode couponValue couponType');
                if (txnsDetails?._id) {
                    couponDetails = {
                        code: txnsDetails?.couponId?.couponCode ?? "NA",
                        value: txnsDetails?.couponId?.couponValue ?? "NA",
                        type: txnsDetails?.couponId?.couponType ?? "NA",
                    }
                    obj = {
                        txnId: "",
                        transactionUserOrederId: txnsDetails?.userOrederId ?? "",
                        transactionId: txnsDetails?.payment_id ?? "",
                        transactionAmount: txnsDetails?.amount ?? "",
                        remark: txnsDetails?.remark ?? "",
                        transactionDate: txnsDetails?.transactionDate ?? "",
                        invoice: txnsDetails?.invoice,
                        couponDetails,
                    }
                } else {
                    let courseOrder = await courseOrdesTable.findOne({ user: batch[i]?.user?._id, courseId: batch[i]?.batch_id, isPaid: true }).populate('couponId', '_id couponValue couponCode couponType');
                    if (courseOrder?._id) {
                        couponDetails = {
                            code: courseOrder?.couponId?.couponCode ?? "NA",
                            value: courseOrder?.couponId?.couponValue ?? "NA",
                            type: courseOrder?.couponId?.couponType ?? "NA",
                        }
                        obj = {
                            txnId: "",
                            transactionUserOrederId: courseOrder?.orderId ?? "",
                            transactionId: courseOrder?.txnId ?? "",
                            transactionAmount: courseOrder?.totalAmount ?? "",
                            transactionDate: courseOrder?.purchaseDate ?? "",
                            invoice: courseOrder?.invoice,
                            couponDetails,
                        }
                    }
                }
                // let txnsDetails = await paymentTransactionTable.findOne({ user: batch[i].user?._id, batch_name: batch[i].batch_id?.batch_name });
                resData.push(
                    {
                        id: batch[i]._id,
                        enrollId: batch[i].user?.enrollId,
                        userId: batch[i]?.user?._id,
                        icon: batch[i].user?.profilePhoto,
                        name: batch[i].user?.FullName,
                        email: batch[i].user?.email,
                        phone: batch[i].user?.mobileNumber,
                        category: batch[i].user?.Stream,
                        value: `${batch[i].batch_id?.batch_name} - ${batch[i].batch_id?.batchId}`,
                        amount: batch[i].amount,
                        prices: { regularPrice: batch[i]?.batch_id?.charges, salePrice: batch[i]?.batch_id?.discount },
                        ...obj,
                        // txnId: "",
                        // transactionUserOrederId: txnsDetails?.userOrederId ?? "",
                        // transactionId: txnsDetails?.payment_id ?? "",
                        // transactionAmount: txnsDetails?.amount ?? "",
                        // transactionDate: txnsDetails?.transactionDate ?? "",
                        is_paid: batch[i].is_paid,
                        remark: batch[i]?.remark ?? "",
                        is_active: batch[i].is_active,
                        purchaseAt: batch[i].created_at
                    }
                )
            }
            return res.json({
                status: true,
                data: resData,
                msg: "Purchase Report",
            });
        }



    } catch (err) {
        res.status(401).json({
            status: false,
            data: null,
            msg: err.message || "Unauthorized",
        });
    }
});

// Users details
AdminPanel.post("/usersReport", isAdmin, async (req, res) => {
    let { type, category, startAt, endAt } = req.body;
    try {
        if (!type || !category || !startAt || !endAt) {
            return res.status(400).json({
                status: false,
                data: null,
                msg: "Missing required field(s). Please provide type and category.",
            });
        }
        const decoded = jwt.verify(req.token, process.env.ADMIN_SECRET_KEY);
        const adminDetails = await findAdminTeacherUsingUserId(decoded.studentId);
        if (!adminDetails) {
            return res.status(401).json({
                status: false,
                data: null,
                msg: "Not an admin",
            });
        }
        // console.log(startAt+""+endAt);
        startAt = moment(startAt, "YYYY-MM-DD").format("YYYY-MM-DD HH:mm:ss");
        endAt = moment(endAt, "YYYY-MM-DD").set({ hour: 23, minute: 59, second: 59, millisecond: 0 }).format("YYYY-MM-DD HH:mm:ss");
        // console.log(startAt+""+endAt);
        if (type === "paid") {
            let paidUsers = []
            let filterQ = {
            }
            // console.log("Batch Filter", filterQ)
            // const batch = await MybatchTable.find(filterQ)
            let batch = await MybatchTable.find(filterQ);
            // batch = batch.filter((item) => {
            //     let date = moment(item?.created_at, "DD-MM-YYYY HH:mm:ss").format('YYYY-MM-DD HH:mm:ss')
            //     if (moment(date, "YYYY-MM-DD HH:mm:ss").isBetween(moment(startAt, 'YYYY-MM-DD HH:mm:ss'), moment(endAt, 'YYYY-MM-DD HH:mm:ss'))) {
            //         return item;
            //     }
            // })
            // paidUsers.push(batch.map((item) => item.user))
            let batchUser = batch.map((item) => item.user);
            paidUsers = paidUsers.concat(batchUser);
            let testSeries = await MyTestSeriesTable.find({ ...filterQ, createdAt: { $gte: new Date(startAt), $lte: new Date(endAt) } });
            // testSeries = testSeries.filter((item) => {
            //     let date = moment(item?.created_at, "DD-MM-YYYY HH:mm:ss").format('YYYY-MM-DD HH:mm:ss')
            //     if (moment(date, "YYYY-MM-DD HH:mm:ss").isBetween(moment(startAt, 'YYYY-MM-DD HH:mm:ss'), moment(endAt, 'YYYY-MM-DD HH:mm:ss'))) {
            //         return item;
            //     }
            // })
            let testSeriesUser = testSeries.map((item) => item.user);
            paidUsers = paidUsers.concat(testSeriesUser);
            paidUsers = paidUsers.map(objId => objId.toString())
            paidUsers = [...new Set(paidUsers)]
            let userData;
            if (category != "all") {
                userData = await UserTable.find({ _id: { $in: paidUsers }, Stream: { $in: category }, createdAt: { $gte: new Date(startAt), $lte: new Date(endAt) } })
            } else {
                userData = await UserTable.find({ _id: { $in: paidUsers }, createdAt: { $gte: new Date(startAt), $lte: new Date(endAt) } })
            }
            return res.json({
                status: true,
                data: userData.map((item) => {
                    return {
                        enrollId: item.enrollId,
                        id: item._id,
                        name: item.FullName,
                        phone: item.mobileNumber,
                        email: item.email,
                        regCategory: item.Stream,
                        userId: item.userId,
                        regDateTime: item.created_at,
                        utmCampaign: item?.utm_campaign ?? "",
                        utmSource: item?.utm_source ?? "",
                        utmMedium: item?.utm_medium ?? "",
                        signinType: item?.signinType ?? "",
                    }
                }),
                msg: `${type} Users report`,
            });
        } else if (type === "free") {
            let paidUsers = []
            let filterQ = {
            }
            // console.log()
            // const batch = await MybatchTable.find(filterQ)
            let batch = await MybatchTable.find(filterQ);
            // console.log(batch.length);
            // batch = batch.filter((item) => {
            //   let date = moment(item?.created_at, "DD-MM-YYYY HH:mm:ss").format('YYYY-MM-DD HH:mm:ss')
            //   if (moment(date , "YYYY-MM-DD HH:mm:ss").isBetween(moment(startAt, 'YYYY-MM-DD HH:mm:ss') , moment(endAt ,'YYYY-MM-DD HH:mm:ss'))) {
            //     return item;
            //   }
            // })
            // console.log(batch.length);
            // paidUsers.push(batch.map((item) => item.user))
            let batchUser = batch.map((item) => item.user)
            paidUsers = paidUsers.concat(batchUser);
            // const testSeries = await MyTestSeriesTable.find(filterQ)
            let testSeries = await MyTestSeriesTable.find(filterQ);
            // testSeries = testSeries.filter((item) => {
            //   let date = moment(item?.created_at, "DD-MM-YYYY HH:mm:ss").format('YYYY-MM-DD HH:mm:ss')
            //   if (moment(date , "YYYY-MM-DD HH:mm:ss").isBetween(moment(startAt, 'YYYY-MM-DD HH:mm:ss') , moment(endAt ,'YYYY-MM-DD HH:mm:ss'))) {
            //     return item;
            //   }
            // })
            // paidUsers.push(testSeries.map((item) => item.user))
            let testSeriesUser = testSeries.map((item) => item.user);
            paidUsers = paidUsers.concat(testSeriesUser);
            // console.log(paidUsers.length)
            paidUsers = paidUsers.map(objId => objId.toString())
            paidUsers = [...new Set(paidUsers)];
            // console.log(paidUsers.length);
            // console.log(paidUsers);
            let userData;
            if (category != "all") {
                userData = await UserTable.find({ _id: { $nin: paidUsers }, Stream: { $in: category }, createdAt: { $gte: new Date(startAt), $lte: new Date(endAt) } }).select("_id enrollId FullName email mobileNumber Stream created_at userId utm_campaign utm_source utm_medium signinType")
            } else {
                userData = await UserTable.find({ _id: { $nin: paidUsers }, createdAt: { $gte: new Date(startAt), $lte: new Date(endAt) } }).select("_id enrollId FullName email mobileNumber Stream created_at userId utm_campaign utm_source utm_medium signinType")
                // userData = await UserTable.find({ _id: { $nin: paidUsers } })
            }
            // userData = userData.filter((item) => {
            //     let date = moment(item?.created_at, "DD-MM-YYYY HH:mm:ss").format('YYYY-MM-DD HH:mm:ss')
            //     if (moment(date, "YYYY-MM-DD HH:mm:ss").isBetween(moment(startAt, 'YYYY-MM-DD HH:mm:ss'), moment(endAt, 'YYYY-MM-DD HH:mm:ss'))) {
            //         return item;
            //     }
            // })
            return res.json({
                status: true,
                data: userData.map((item) => {
                    return {
                        enrollId: item.enrollId,
                        id: item._id,
                        name: item.FullName,
                        phone: item.mobileNumber,
                        email: item.email,
                        regCategory: item.Stream,
                        userId: item.userId,
                        regDateTime: item.created_at,
                        utmCampaign: item?.utm_campaign ?? "",
                        utmSource: item?.utm_source ?? "",
                        utmMedium: item?.utm_medium ?? "",
                        signinType: item?.signinType ?? "",
                    }
                }),
                // data : userData, 
                msg: `${type} Users report`,
            });
        } else if (type === "all") {
            let filterQ = {}
            if (category === "all") {
                filterQ = {
                }
            } else {
                filterQ = {
                    Stream: { $in: category },
                }
            }
            // console.log(filterQ);
            // const userData = await UserTable.find(filterQ)
            let userData = await UserTable.find({ ...filterQ, createdAt: { $gte: new Date(startAt), $lte: new Date(endAt) } });
            // console.log(userData.length);
            // userData = userData.filter((item) => {
            //     let date = moment(item?.created_at, "DD-MM-YYYY HH:mm:ss").format('YYYY-MM-DD HH:mm:ss')
            //     if (moment(date, "YYYY-MM-DD HH:mm:ss").isBetween(moment(startAt, 'YYYY-MM-DD HH:mm:ss'), moment(endAt, 'YYYY-MM-DD HH:mm:ss'))) {
            //         return item;
            //     }
            // })
            // console.log()
            return res.json({
                status: true,
                data: userData.map((item) => {
                    return {
                        enrollId: item?.enrollId,
                        id: item?._id,
                        name: item?.FullName,
                        phone: item?.mobileNumber,
                        email: item?.email,
                        userId: item.userId,
                        regCategory: item?.Stream,
                        regDateTime: item?.created_at,
                        utmCampaign: item?.utm_campaign ?? "",
                        utmSource: item?.utm_source ?? "",
                        utmMedium: item?.utm_medium ?? "",
                        signinType: item?.signinType ?? "",
                    }
                    // }
                    // return {
                    //   enrollId: item.enrollId,
                    //   id: item._id,
                    //   name: item.FullName,
                    //   phone: item.mobileNumber,
                    //   email: item.email,
                    //   regCategory: item.Stream,
                    //   regDateTime: item.created_at
                    // }
                }),
                msg: `${type} Users report`,
            });
        }
    } catch (err) {
        res.status(401).json({
            status: false,
            data: null,
            msg: err.message || "Unauthorized",
        });
    }
});

// <----------- BATCH ENROLLMENT SECTION ------->
AdminPanel.post("/batchEnroll", isAdmin, async (req, res) => {
    const { userIdArr, batchId, transactionId, amount, validityId, remark } = req.body;
    try {
        if (!userIdArr || userIdArr.length === 0 || !batchId || !validityId) {
            return res.status(400).json({
                status: false,
                data: null,
                msg: "Missing required field(s). Please provide userIdArr , batchId and ValidityId.",
            });
        }
        if (parseInt(amount) == 0 && transactionId != 'Admin-SD') {
            return res.json({
                status: false,
                data: null,
                msg: 'Provide correct transaction Id'
            })
        }
        const decoded = jwt.verify(req.token, process.env.ADMIN_SECRET_KEY);
        const adminDetails = await findAdminTeacherUsingUserId(decoded.studentId);
        if (!adminDetails) {
            return res.status(401).json({
                status: false,
                data: null,
                msg: "Not an admin",
            });
        }

        const users = await verifyUserIds(userIdArr);
        if (!users) {
            return res.status(404).json({
                status: false,
                data: null,
                msg: "UserIds Not Exist",
            });
        }

        await CartTable.deleteMany({
            batch_id: batchId,
            user: { $in: userIdArr },
        });
        const batch = await BatchesTable.findByIdAndUpdate(
            batchId,
            { $addToSet: { student: { $each: userIdArr } } },
            { new: true, lean: true }
        );

        if (!batch) {
            return res.status(404).json({
                status: false,
                data: null,
                msg: "Batch Not Found",
            });
        }

        //  check validity for this batch 
        const isValidity = await ValidityTable.findOne({ _id: validityId, batch: batchId });
        if (!isValidity) {
            return res.json({
                status: false,
                data: null,
                msg: `Validity is not for this batch`
            })
        }
        const date = new Date(moment().add(5, "hours").add(30, "minutes"));
        const isAlreadyEnroll = await MybatchTable.findOne({ batch_id: batchId, user: userIdArr[0] });
        if (isAlreadyEnroll) {
            return res.json({
                status: false,
                data: null,
                msg: `Student Already Enrolled`
            })
        }
        const formattedDate = formatDate(date);
        let expireDate = new Date();
        let extendMonth = parseInt(isValidity?.month);
        expireDate.setMonth(expireDate.getMonth() + extendMonth);

        const myBatches = userIdArr.map((userId) => ({
            user: userId,
            batch_id: batchId,
            expireDate,
            amount: amount,
            is_active: true,
            is_paid: true,
            created_at: formattedDate,
            validity: validityId,
            remark
        }));

        await MybatchTable.insertMany(myBatches, { ordered: false });
        const fcmdata = {
            title: batch?.batch_name || '',
            message: `New Batch ${batch?.batch_name} added into your account`,
            fileUrl: `${batch?.banner[0]?.fileLoc}` || "",
            route: "mybatchbyid",
            rootId: `${batch?._id}`,
            childId: ""
        }
        // console.log(userIdArr);
        await sendCustomNotification(userIdArr, fcmdata)
        let paymentArr = [];
        for (let id of userIdArr) {
            let userDetails = await UserTable.findOne({ _id: id });
            if (userDetails) {
                const orderidHelper = await presentorderIdtable.findOne({});
                const orderIdNumber = orderidHelper.presentorderId + 1;
                await presentorderIdtable.findByIdAndUpdate(
                    { _id: orderidHelper._id },
                    { presentorderId: orderIdNumber }
                );
                let userOrederId = "SDCAMPUS" + orderIdNumber;
                // let userOrederId ="SDCAMPUS-" + uuidv1(); 
                // let checkPaymentStatus =  await checkPayment(transactionId , amount , userDetails?.mobileNumber , userDetails?.email );
                let obj =
                {
                    user: userDetails?._id,
                    name: userDetails?.FullName,
                    email: userDetails?.email,
                    mobileNumber: userDetails?.mobileNumber,
                    description: batch?.batch_name,
                    amount,
                    // orderId : userOrederId,
                    orderId: "",
                    userOrederId,
                    batch_name: batch?.batch_name,
                    transactionDate: formatDatetime(new Date()),
                    payment_id: transactionId,
                    success: true,
                    remark,
                    validity: validityId,
                }
                paymentArr.push(obj);

                let data = {
                    user: {
                        _id: userDetails?._id,
                        FullName: userDetails?.FullName,
                        email: userDetails?.email,
                        mobileNumber: userDetails?.mobileNumber,
                        Address: userDetails?.Address
                    },
                    batch_name: batch?.batch_name,
                    amount: amount,
                    transactionId,
                }
                invoiceHelper(data);
            }
        }
        await paymentTransactionTable.insertMany(paymentArr);
        // console.log(paymentArr);
        roomAssign(batch?._id, userIdArr, batch?.roomSize || 20);
        await sendWAmessageUserBatchAssign(userIdArr[0], batchId)
        savePanelEventLogs(
            adminDetails._id,
            "BatchEnroll",
            "Enroll",
            { batch_id: batch?._id, user: userIdArr[0], amount }
        )
        res.json({
            status: true,
            data: batch,
            msg: "Batch Enrollment Success",
        });

        // save payment transaction
    } catch (err) {
        res.status(401).json({
            status: false,
            data: null,
            msg: err.message || "Unauthorized",
        });
    }
});

// <----------- BATCH Exten SECTION ------->
AdminPanel.post("/extendBatchValidity", isAdmin, async (req, res) => {
    const { userIdArr, batchId, transactionId, amount, validityId, remark } = req.body;
    try {
        if (!userIdArr || !batchId || !validityId || !transactionId || !amount) {
            return res.status(400).json({
                status: false,
                data: null,
                msg: "Missing required field(s). Please provide userIdArr , batchId and ValidityId.",
            });
        }
        if (parseInt(amount) == 0 && transactionId != 'Admin-SD') {
            return res.json({
                status: false,
                data: null,
                msg: 'Provide correct transaction Id'
            })
        }
        const decoded = jwt.verify(req.token, process.env.ADMIN_SECRET_KEY);
        const adminDetails = await findAdminTeacherUsingUserId(decoded.studentId);
        if (!adminDetails) {
            return res.status(401).json({
                status: false,
                data: null,
                msg: "Not an admin",
            });
        }
        const users = await verifyUserIds(userIdArr);
        if (!users) {
            return res.status(404).json({
                status: false,
                data: null,
                msg: "UserIds Not Exist",
            });
        }
        const batch = await BatchesTable.findByIdAndUpdate(
            batchId,
            { $addToSet: { student: { $each: userIdArr } } },
            { new: true, lean: true }
        );

        if (!batch) {
            return res.status(404).json({
                status: false,
                data: null,
                msg: "Batch Not Found",
            });
        }
        //  check validity for this batch 
        const isValidity = await ValidityTable.findOne({ _id: validityId, batch: batchId });
        if (!isValidity) {
            return res.json({
                status: false,
                data: null,
                msg: `Validity is not for this batch`
            })
        }
        const date = new Date(moment().add(5, "hours").add(30, "minutes"));
        const isAlreadyEnroll = await MybatchTable.findOne({ batch_id: batchId, user: userIdArr[0] }).populate("validity");
        if (!isAlreadyEnroll) {
            return res.json({
                status: false,
                data: null,
                msg: `First enroll student`
            })
        }
        const isSameValidityAssigned = await MybatchTable.findOne({ batch_id: batchId, user: userIdArr[0],validity: validityId });
        if(isSameValidityAssigned){
            return res.json({
                status: false,
                data: null,
                msg: `You are trying to assign same validity again`
            })
        }
        
        const formattedDate = formatDate(date);
        let extendMonth = parseInt(isValidity?.month);
        let purchaseDate = new Date(isAlreadyEnroll?.assignedDate);
        
        let newExpireDate = new Date(purchaseDate);
        newExpireDate.setMonth(newExpireDate.getMonth() + extendMonth);
        await MybatchTable.updateOne(
            {
                user: userIdArr[0],
                batch_id: batchId,
            },
            { expireDate: newExpireDate,validity: validityId, remark:remark}
        );
        const fcmdata = {
            title: batch?.batch_name || '',
            message: `Your batch ${batch?.batch_name} extended to ${isValidity?.month} month`,
            fileUrl: `${batch?.banner[0]?.fileLoc}` || "",
            route: "mybatchbyid",
            rootId: `${batch?._id}`,
            childId: ""
        }
        // console.log(userIdArr);
       await sendCustomNotification([userIdArr[0]], fcmdata)
        // for (let id of userIdArr) {
        let userDetails = await UserTable.findOne({ _id: userIdArr[0] });
        if (userDetails) {
            const orderidHelper = await presentorderIdtable.findOne({});
            const orderIdNumber = orderidHelper.presentorderId + 1;
            await presentorderIdtable.findByIdAndUpdate(
                { _id: orderidHelper._id },
                { presentorderId: orderIdNumber }
            );
            let userOrederId = "SDCAMPUS" + orderIdNumber;

            let data = {
                user: {
                    _id: userDetails?._id,
                    FullName: userDetails?.FullName,
                    email: userDetails?.email,
                    mobileNumber: userDetails?.mobileNumber,
                    Address: userDetails?.Address
                },
                batch_name: batch?.batch_name,
                amount: amount,
                transactionId,
            }
            
            let obj =
            {
                user: userDetails?._id,
                name: userDetails?.FullName,
                email: userDetails?.email,
                mobileNumber: userDetails?.mobileNumber,
                description: batch?.batch_name,
                amount,
                // orderId : userOrederId,
                orderId: "",
                userOrederId,
                batch_name: batch?.batch_name,
                transactionDate: formatDatetime(new Date()),
                payment_id: transactionId,
                success: true,
                remark,
                validity: validityId,
            }
            
            await batchExtendInvoiceHelper(data,obj);
            
          
        }
        // }
        
        // console.log(paymentArr);
        // roomAssign(batch?._id, userIdArr, batch?.roomSize || 20);
       await sendWAmessageUserBatchAssign(userIdArr[0], batchId)
        savePanelEventLogs(
            adminDetails._id,
            "BatchExtend",
            "Enroll",
            { batch_id: batch?._id, user: userIdArr[0], amount }
        )
        res.json({
            status: true,
            data: batch,
            msg: "Batch extended successfully",
        });

        // save payment transaction
    } catch (err) {
        res.status(401).json({
            status: false,
            data: null,
            msg: err.message || "Unauthorized",
        });
    }
});

AdminPanel.post("/testSeriesEnroll", isAdmin, async (req, res) => {
    const { userIdArr, testSriesId } = req.body;
    try {
        if (!userIdArr || userIdArr.length === 0 || !testSriesId) {
            return res.status(400).json({
                status: false,
                data: null,
                msg: "Missing required field(s). Please provide userIdArr and testSriesId.",
            });
        }

        const decoded = jwt.verify(req.token, process.env.ADMIN_SECRET_KEY);
        const adminDetails = await findAdminTeacherUsingUserId(decoded.studentId);
        if (!adminDetails) {
            return res.status(401).json({
                status: false,
                data: null,
                msg: "Not an admin",
            });
        }

        const users = await verifyUserIds(userIdArr);
        if (!users) {
            return res.status(404).json({
                status: false,
                data: null,
                msg: "UserIds Not Exist",
            });
        }

        const testseries = await TestSeriesTable.findByIdAndUpdate(
            testSriesId,
            { $addToSet: { student: { $each: userIdArr } } },
            { new: true, lean: true }
        );

        if (!testseries) {
            return res.status(404).json({
                status: false,
                data: null,
                msg: "Testseries Not Found",
            });
        }

        const date = new Date(moment().add(5, "hours").add(30, "minutes"));
        const formattedDate = formatDate(date);
        const myTestSeries = userIdArr.map((userId) => ({
            user: userId,
            testseries_id: testSriesId,
            amount: testseries.charges,
            is_active: true,
            is_paid: true,
            created_at: formattedDate,
            updated_at: formattedDate,
        }));

        await MyTestSeriesTable.insertMany(myTestSeries, { ordered: false });

        res.json({
            status: true,
            data: testseries,
            msg: " TestSeries Enrollment Success",
        });
    } catch (err) {
        res.status(401).json({
            status: false,
            data: null,
            msg: err.message || "Unauthorized",
        });
    }
});

//  <------------------ REMOVE STUDENT FROM BATCH -------------------------->
AdminPanel.delete(
    "/removeStudentBatch/:userId/:batchId",
    isAdmin,
    async (req, res) => {
        const { userId, batchId } = req.params;
        try {
            if (!userId || !batchId) {
                return res.status(400).json({
                    status: false,
                    data: null,
                    msg: "Missing required field(s). Please provide userId and batchId.",
                });
            }

            const decoded = jwt.verify(req.token, process.env.ADMIN_SECRET_KEY);
            const adminDetails = await findAdminTeacherUsingUserId(decoded.studentId);
            if (!adminDetails) {
                return res.status(401).json({
                    status: false,
                    data: null,
                    msg: "Not an admin",
                });
            }

            const user = await UserTable.findById(userId);
            if (!user) {
                return res.status(404).json({
                    status: false,
                    data: null,
                    msg: "User Not Exist",
                });
            }
            const batch = await BatchesTable.findByIdAndUpdate(
                batchId,
                { $pull: { student: userId } },
                { new: true, lean: true }
            );

            if (!batch) {
                return res.status(404).json({
                    status: false,
                    data: null,
                    msg: "Batch Not Found",
                });
            }
            await MybatchTable.deleteOne({ batch_id: batchId, user: userId });
            // await savePanelEventLogs({
            //   user: adminDetails._id,
            //   event: "removeStudentFromBatch",
            //   action: "delete",
            //   data: { batch_id: batchId, user: userId }
            // })
            await savePanelEventLogs(
                adminDetails._id,
                "removeStudentFromBatch",
                "delete",
                { batch_id: batchId, user: userId }
            )
            res.json({
                status: true,
                data: null,
                msg: `Student removed from batch ${batchId}`,
            });
        } catch (err) {
            res.status(401).json({
                status: false,
                data: null,
                msg: err.message || "Unauthorized",
            });
        }
    }
);

// <------------------- REMOVE STUDENT FROM TEST SERIES ---------------->

AdminPanel.delete(
    "/removeStudentTestSeries/:userId/:testSriesId",
    isAdmin,
    async (req, res) => {
        const { userId, testSriesId } = req.params;
        try {
            if (!userId || !testSriesId) {
                return res.status(400).json({
                    status: false,
                    data: null,
                    msg: "Missing required field(s). Please provide userId and testSriesId.",
                });
            }

            const decoded = jwt.verify(req.token, process.env.ADMIN_SECRET_KEY);
            const adminDetails = await findAdminTeacherUsingUserId(decoded.studentId);
            if (!adminDetails) {
                return res.status(401).json({
                    status: false,
                    data: null,
                    msg: "Not an admin",
                });
            }

            const users = await UserTable.findById(userId);
            if (!users) {
                return res.status(404).json({
                    status: false,
                    data: null,
                    msg: "User Not Found",
                });
            }

            const testseries = await TestSeriesTable.findByIdAndUpdate(
                testSriesId,
                { $pull: { student: userId } },
                { new: true, lean: true }
            );

            if (!testseries) {
                return res.status(404).json({
                    status: false,
                    data: null,
                    msg: "Testseries Not Found",
                });
            }

            await MyTestSeriesTable.deleteOne({
                testseries_id: testSriesId,
                user: userId,
            });
            await savePanelEventLogs(
                adminDetails._id,
                "removeStudentFromTestSeries",
                "delete",
                { testSeries_id: testseries?._id, user: users?._id }
            )
            res.json({
                status: true,
                data: null,
                msg: `${userId} removed from ${testSriesId}`,
            });
        } catch (err) {
            res.status(401).json({
                status: false,
                data: null,
                msg: err.message || "Unauthorized",
            });
        }
    }
);

// <----------------------- FCM PUSH Notification Service ---------->

AdminPanel.post(
    "/sendCustomNotification",
    isAdmin,
    upload.single("file"),
    async (req, res) => {
        try {
            const { userIdArr, title, message } = req.body;
            const Data = jwt.verify(req.token, process.env.ADMIN_SECRET_KEY);
            const adminDetails = await findAdminTeacherUsingUserId(Data.studentId);
            if (!adminDetails) {
                return res.json({ status: false, data: null, msg: "Not an admin" });
            }

            let fileLoc = [];
            if (req.file) {
                const helperString = Math.floor(Date.now() / 1000);
                const filename = (req.file.originalname.split(".")[0]).replace(/\s+/g, '_').replace(/[^a-zA-Z0-9_]/g, '');
                const extension = "." + req.file.originalname.split(".").pop();
                FileUploadLocation = `pushNoti/${title?.replace(/\s+/g, '_').replace(/[^a-zA-Z0-9_]/g, '')}/${filename}_${helperString}${extension}`;
                let helperfileLoc = await uploadFile(req.file.path, FileUploadLocation);
                fileLoc.push(helperfileLoc);
            }
            const data = {
                title,
                message,
                fileUrl: fileLoc[0] || "",
                route: "",
                rootId: "",
                childId: ""
            }
            const notification = await sendCustomNotification(
                userIdArr,
                data,
            );

            res.json({
                status: true,
                msg: "Push Notification Sent",
            });
        } catch (error) {
            res.status(401).json({ status: false, data: null, msg: error.message });
        }
    }
);

// <---------------- APP ALERT MESSAGE SECTION ------------>

//add alert message
AdminPanel.post("/addAlert", isAdmin, async (req, res) => {
    const { userIdArr, title, type, desc, isActive } = req.body;
    if (!userIdArr.length > 0 || !title || !desc || !isActive) {
        res.status(400).json({
            status: false,
            data: null,
            msg: "Missing required field(s). Please provide userIdArr, title, type, desc, and isActive.",
        });
        return;
    }
    jwt.verify(req.token, process.env.ADMIN_SECRET_KEY, async (err, Data) => {
        if (err) {
            res.status(401).json({
                status: false,
                data: null,
                msg: err,
            });
        } else {
            const adminDetails = await findAdminTeacherUsingUserId(Data.studentId);
            if (adminDetails) {
                const users = await verifyUserIds(userIdArr);
                if (users) {
                    const alert = new alertTable({
                        userIdArr,
                        title,
                        desc,
                        type,
                        isActive,
                        createdAt: moment().add(5, "hours").add(30, "minutes"),
                    });
                    const result = await alert.save();
                    if (result) {
                        res.json({
                            status: true,
                            data: result,
                            msg: "Alert Added Successfully",
                        });
                    } else {
                        res.json({
                            status: false,
                            data: null,
                            msg: "Something went wrong! Try again!",
                        });
                    }
                } else {
                    res.json({
                        status: false,
                        data: null,
                        msg: "UserIds Not Exists",
                    });
                }
            } else {
                res.json({
                    status: false,
                    data: null,
                    msg: "Not an admin",
                });
            }
        }
    });
});

AdminPanel.get("/getAlerts", isAdmin, async (req, res) => {
    jwt.verify(req.token, process.env.ADMIN_SECRET_KEY, async (err, Data) => {
        if (err) {
            res.status(401).json({
                status: false,
                data: null,
                msg: err,
            });
        } else {
            const adminDetails = await findAdminTeacherUsingUserId(Data.studentId);
            if (adminDetails) {
                const alert = await alertTable.find({}).populate("userIdArr");
                const alertRes = alert.map((alert) => {
                    const { _id, userIdArr, title, type, desc, isActive, createdAt } =
                        alert;
                    const user = userIdArr.map(({ FullName, _id, fcmToken }) => ({
                        id: _id,
                        fcmToken,
                        FullName,
                    }));

                    return {
                        id: _id,
                        user,
                        title,
                        type,
                        desc,
                        isActive,
                        createdAt,
                    };
                });
                if (alert) {
                    res.json({
                        status: true,
                        data: alertRes,
                        msg: "Alerts",
                    });
                } else {
                    res.json({
                        status: false,
                        data: null,
                        msg: "Something went wrong! Try again!",
                    });
                }
            } else {
                res.json({
                    status: false,
                    data: null,
                    msg: "Not an admin",
                });
            }
        }
    });
});

AdminPanel.delete("/deleteAlert/:id", isAdmin, async (req, res) => {
    const { id } = req.params;
    if (!id) {
        return res.status(400).json({
            status: false,
            data: null,
            msg: "Invalid Request",
        });
    }
    try {
        const decoded = jwt.verify(req.token, process.env.ADMIN_SECRET_KEY);
        const adminDetails = await findAdminTeacherUsingUserId(decoded.studentId);
        if (!adminDetails) {
            return res.status(401).json({
                status: false,
                data: null,
                msg: "Unauthorized",
            });
        }
        const data = await alertTable.findByIdAndDelete(id);
        if (!data) {
            return res.status(404).json({
                status: false,
                data: null,
                msg: "Alert not found",
            });
        }
        await savePanelEventLogs(
            adminDetails._id,
            "deleteAlert",
            "delete",
            { alert_id: data }
        )

        res.json({
            status: true,
            data: data,
            msg: "Alert deleted",
        });
    } catch (err) {
        res.status(401).json({
            status: false,
            data: null,
            msg: err.message || "Unauthorized",
        });
    }
});

// Student Route
AdminPanel.get("/getMyAlerts", ValidateToken, async (req, res) => {
    try {
        const decoded = jwt.verify(req.token, process.env.SECRET_KEY);
        const studentDetails = await findUserByUserId(decoded.studentId);

        if (studentDetails) {
            const alerts = await alertTable
                .find({
                    userIdArr: {
                        $elemMatch: { $eq: studentDetails._id },
                    },
                    isActive: true,
                })
                .sort({ createdAt: -1 })
                .select("_id title type desc");

            const alertRes = alerts.map((alert) => ({
                id: alert._id,
                title: alert.title,
                type: alert.type,
                desc: alert.desc,
            }));
            res.json({
                status: true,
                data: alertRes,
                msg: "My Alert messages",
            });
        } else {
            res.json({
                status: false,
                data: null,
                msg: "User not found",
            });
        }
    } catch (err) {
        res.status(401).json({
            status: false,
            data: null,
            msg: err.message,
        });
    }
});

// <----------  ADMIN PANEL COUPON SECTION --------->

//Add Coupon
// AdminPanel.post("/addCoupon", isAdmin, async (req, res) => {
//   const {
//     couponCode,
//     couponType,
//     couponValue,
//     link,
//     // linkWith,
//     selectedList,
//     expirationDate,
//     couponAccess,
//     is_active,
//   } = req.body;
//   jwt.verify(req.token, process.env.ADMIN_SECRET_KEY, async (err, Data) => {
//     if (err) {
//       res.status(401).json({
//         status: false,
//         data: null,
//         msg: err,
//       });
//     } else {
//       const adminDetails = await findAdminTeacherUsingUserId(Data.studentId);
//       if (adminDetails) {
//         const coupon = await couponTable.find({ couponCode });
//         if (coupon.length == 0) {
//           for( let id of selectedList){
//             const couponData = new couponTable({
//               user: adminDetails._id,
//               couponCode: couponCode,
//               couponType: couponType,
//               couponValue: couponValue,
//               link,
//               linkWith:id,
//               expirationDate: expirationDate,
//               couponAccess: couponAccess,
//               is_active: is_active,
//               created_at: new Date(moment().add(5, "hours").add(30, "minutes")),
//               updated_at: new Date(moment().add(5, "hours").add(30, "minutes")),
//             });
//           }
//           const couponData = new couponTable({
//             user: adminDetails._id,
//             couponCode: couponCode,
//             couponType: couponType,
//             couponValue: couponValue,
//             link,
//             linkWith,
//             expirationDate: expirationDate,
//             couponAccess: couponAccess,
//             is_active: is_active,
//             created_at: new Date(moment().add(5, "hours").add(30, "minutes")),
//             updated_at: new Date(moment().add(5, "hours").add(30, "minutes")),
//           });
//           const result = await couponData.save();
//           if (result) {
//             res.json({
//               status: true,
//               data: {},
//               msg: "Coupons Details Added Successfully",
//             });
//           } else {
//             res.json({
//               status: false,
//               data: null,
//               msg: "Something went wrong ! Try again !",
//             });
//           }
//         } else {
//           res.json({
//             status: false,
//             data: null,
//             msg: "Coupon Code Already exists",
//           });
//         }
//       } else {
//         res.json({
//           status: false,
//           data: null,
//           msg: "Not an admin",
//         });
//       }
//     }
//   });
// });
AdminPanel.post("/addCoupon", isAdmin, async (req, res) => {
    const {
        couponCode,
        couponType,
        couponValue,
        link,
        // linkWith,
        selectedList,
        expirationDate,
        couponAccess,
        is_active,
        student,
        count
    } = req.body;
    try {
        if ((link != 'none' && selectedList.length < 1) || !couponAccess || isNaN(count)) {
            return res.json({
                status: false,
                data: null,
                msg: `Select correct linkWith couponAccess & valid count`
            })
        }
        const decoded = jwt.verify(req.token, process.env.ADMIN_SECRET_KEY);
        const adminDetails = await findAdminTeacherUsingUserId(decoded.studentId);
        if (!adminDetails) {
            return res.status(401).json({
                status: false,
                data: null,
                msg: "Not an admin",
            });
        }
        if (couponAccess == 'single' && (student == null || count <= 0)) {
            // console.log('true')
            return res.json({
                status: false,
                data: null,
                msg: `Select user & apply count for specific user.`
            })
        }
        if (student != null && link != 'none') {
            return res.json({
                status: false,
                data: null,
                msg: "Make link with none for user specific coupon"
            })
        }
        if (student != null && link != 'none') {
            return res.json({
                status: false,
                data: null,
                msg: "Make link with none for user specific coupon"
            })
        }
        const coupon = await couponTable.findOne({ couponCode: couponCode });
        if (coupon) {
            return res.json({
                status: false,
                data: null,
                msg: "Coupon Code Already exists"
            })
        }

        // if (selectedList.length > 0) {
        //     for (let id of selectedList) {
        //         // console.log( id )
        //         let couponData = new couponTable({
        //             user: adminDetails._id,
        //             couponCode: couponCode,
        //             couponType: couponType,
        //             couponValue: couponValue,
        //             link,
        //             linkWith: id,
        //             expirationDate: expirationDate,
        //             couponAccess: couponAccess,
        //             is_active: is_active,
        //             created_at: new Date(moment().add(5, "hours").add(30, "minutes")),
        //             updated_at: new Date(moment().add(5, "hours").add(30, "minutes")),
        //         });
        //         await couponData.save();
        //     }

        // } else {
        //     let couponData = new couponTable({
        //         user: adminDetails._id,
        //         couponCode: couponCode,
        //         couponType: couponType,
        //         couponValue: couponValue,
        //         link,
        //         linkWith: "NA",
        //         expirationDate: expirationDate,
        //         couponAccess: couponAccess,
        //         is_active: is_active,
        //         created_at: new Date(moment().add(5, "hours").add(30, "minutes")),
        //         updated_at: new Date(moment().add(5, "hours").add(30, "minutes")),
        //     });
        //     await couponData.save();
        // }

        let linkWiths = selectedList?.filter((item) => item != "")?.map((item) => { return item?._id });

        // console.log(linkWiths);
        // console.log( expirationDate);

        let couponData = new couponTable({
            user: adminDetails._id,
            couponCode: couponCode,
            couponType: couponType,
            couponValue: couponValue,
            link,
            linkWiths: linkWiths,
            linkWith: linkWiths[0],
            expirationDate: expirationDate,
            couponAccess: couponAccess,
            student,
            count,
            is_active: is_active,
            created_at: new Date(moment().add(5, "hours").add(30, "minutes")),
            updated_at: new Date(moment().add(5, "hours").add(30, "minutes")),
        });
        await couponData.save();
        return res.json({
            status: true,
            data: {},
            msg: 'Coupons Details Added Successfully'
        })


    } catch (error) {
        return res.json({
            status: false,
            data: null,
            msg: error.message
        })
    }
})
//get CouponCodes
AdminPanel.get("/getCoupons", ValidateToken, async (req, res) => {
    const { link, linkWith } = req.query;
    jwt.verify(req.token, process.env.ADMIN_SECRET_KEY, async (err, Data) => {
        if (err) {
            res.status(401).json({
                status: false,
                data: null,
                msg: err,
            });
        } else {
            const adminDetails = await findAdminTeacherUsingUserId(Data.studentId);
            if (adminDetails) {
                let query = {};
                if (link && linkWith) {
                    query.link = link;
                    query.linkWith = linkWith;
                    // query.user = adminDetails._id
                } else {
                    // query.user = adminDetails._id
                }
                const couponCode = await couponTable
                    .find({
                        ...query
                    })
                    .populate("user");
                let couponArr = [];
                let couponArray = await Promise.all(couponCode?.map(async (item) => {
                    if (item.link == 'batch') {
                        const batch = await BatchesTable.findOne({ _id: item?.linkWith });
                        if (!batch) {
                            return {
                                id: item._id,
                                couponId: item._id,
                                createdBy: { name: item?.user?.FullName, role: item?.user?.Role },
                                couponCode: item.couponCode,
                                couponType: item.couponType,
                                link: item.link ?? "",
                                linkWith: { id: "NA", title: "NA" },
                                couponValue: item.couponValue,
                                expirationDate: item.expirationDate,
                                couponAccess: item.couponAccess,
                                is_active: item.is_active,
                                created_at: item.created_at,
                                updated_at: item.updated_at,
                            }
                        }
                        return {
                            id: item._id,
                            couponId: item._id,
                            createdBy: { name: item?.user?.FullName, role: item?.user?.Role },
                            couponCode: item.couponCode,
                            couponType: item.couponType,
                            link: item.link ?? "",
                            linkWith: { id: batch?._id ?? "NA", title: batch?.batch_name ?? "NA" },
                            couponValue: item.couponValue,
                            expirationDate: item.expirationDate,
                            couponAccess: item.couponAccess,
                            is_active: item.is_active,
                            created_at: item.created_at,
                            updated_at: item.updated_at,
                        }

                    } else if (item.link == 'testSeries') {
                        const testSeries = await TestSeriesTable.findOne({ _id: item?.linkWith });
                        if (!testSeries) {
                            return {
                                id: item._id,
                                couponId: item._id,
                                createdBy: { name: item?.user?.FullName, role: item?.user?.Role },
                                couponCode: item.couponCode,
                                couponType: item.couponType,
                                link: item.link ?? "",
                                linkWith: { id: "NA", title: "NA" },
                                couponValue: item.couponValue,
                                expirationDate: item.expirationDate,
                                couponAccess: item.couponAccess,
                                is_active: item.is_active,
                                created_at: item.created_at,
                                updated_at: item.updated_at,
                            }
                        }
                        return {
                            id: item._id,
                            couponId: item._id,
                            createdBy: { name: item?.user?.FullName, role: item?.user?.Role },
                            couponCode: item.couponCode,
                            couponType: item.couponType,
                            link: item.link ?? "",
                            linkWith: { id: testSeries?._id ?? "NA", title: testSeries?.testseries_name ?? "NA" },
                            couponValue: item.couponValue,
                            expirationDate: item.expirationDate,
                            couponAccess: item.couponAccess,
                            is_active: item.is_active,
                            created_at: item.created_at,
                            updated_at: item.updated_at,
                        }

                    } else if (item.link == 'product') {
                        if (item.linkWith == 'all') {
                            return {
                                id: item._id,
                                couponId: item._id,
                                createdBy: { name: item?.user?.FullName, role: item?.user?.Role },
                                couponCode: item.couponCode,
                                couponType: item.couponType,
                                link: item.link ?? "",
                                linkWith: { id: "All", title: "All" },
                                couponValue: item.couponValue,
                                expirationDate: item.expirationDate,
                                couponAccess: item.couponAccess,
                                is_active: item.is_active,
                                created_at: item.created_at,
                                updated_at: item.updated_at,
                            }
                        }
                        const product = await storeProductTable.findOne({ _id: item.linkWith });
                        if (!product) {
                            return {
                                id: item._id,
                                couponId: item._id,
                                createdBy: { name: item?.user?.FullName, role: item?.user?.Role },
                                couponCode: item.couponCode,
                                couponType: item.couponType,
                                link: item.link ?? "",
                                // link : "Product"
                                linkWith: { id: "NA", title: "NA" },
                                couponValue: item.couponValue,
                                expirationDate: item.expirationDate,
                                couponAccess: item.couponAccess,
                                is_active: item.is_active,
                                created_at: item.created_at,
                                updated_at: item.updated_at,
                            }
                        }
                        return {
                            id: item._id,
                            couponId: item._id,
                            createdBy: { name: item?.user?.FullName, role: item?.user?.Role },
                            couponCode: item.couponCode,
                            couponType: item.couponType,
                            link: item.link ?? "",
                            linkWith: { id: product?._id ?? "NA", title: product?.title ?? "NA" },
                            couponValue: item.couponValue,
                            expirationDate: item.expirationDate,
                            couponAccess: item.couponAccess,
                            is_active: item.is_active,
                            created_at: item.created_at,
                            updated_at: item.updated_at,
                        }

                    } else if (item.link == 'productCategory') {
                        const productCategory = await productCategoryTable.findOne({ _id: item?.linkWith });
                        if (!productCategory) {
                            return {
                                id: item._id,
                                couponId: item._id,
                                createdBy: { name: item?.user?.FullName, role: item?.user?.Role },
                                couponCode: item.couponCode,
                                couponType: item.couponType,
                                link: item.link ?? "",
                                linkWith: { id: "NA", title: "NA" },
                                couponValue: item.couponValue,
                                expirationDate: item.expirationDate,
                                couponAccess: item.couponAccess,
                                is_active: item.is_active,
                                created_at: item.created_at,
                                updated_at: item.updated_at,
                            }
                        }
                        return {
                            id: item._id,
                            couponId: item._id,
                            createdBy: { name: item?.user?.FullName, role: item?.user?.Role },
                            couponCode: item.couponCode,
                            couponType: item.couponType,
                            link: item.link ?? "",
                            linkWith: { id: productCategory?._id ?? "NA", title: productCategory?.title ?? "NA" },
                            couponValue: item.couponValue,
                            expirationDate: item.expirationDate,
                            couponAccess: item.couponAccess,
                            is_active: item.is_active,
                            created_at: item.created_at,
                            updated_at: item.updated_at,
                        }

                    }
                    else {
                        return {
                            id: item._id,
                            couponId: item._id,
                            createdBy: { name: item?.user?.FullName, role: item?.user?.Role },
                            couponCode: item.couponCode,
                            couponType: item.couponType,
                            link: item.link ?? "",
                            linkWith: { id: "NA", title: "NA" },
                            couponValue: item.couponValue,
                            expirationDate: item.expirationDate,
                            couponAccess: item.couponAccess,
                            is_active: item.is_active,
                            created_at: item.created_at,
                            updated_at: item.updated_at,
                        }
                    }
                }))
                // couponCode?.forEach((item) => {
                //   couponArr.push({
                //     couponId: item._id,
                //     createdBy: { name: item.user.FullName, role: item.user.Role },
                //     couponCode: item.couponCode,
                //     couponType: item.couponType,
                //     link: item.link ?? "",
                //     linkWith: item.linkWith ?? "",
                //     couponValue: item.couponValue,
                //     expirationDate: item.expirationDate,
                //     couponAccess: item.couponAccess,
                //     is_active: item.is_active,
                //     created_at: item.created_at,
                //     updated_at: item.updated_at,
                //   });
                // });
                if (couponCode) {
                    res.json({
                        status: true,
                        data: couponArray,
                        msg: "Coupon Codes Details",
                    });
                } else {
                    res.json({
                        status: false,
                        data: null,
                        msg: "Coupon Not Found",
                    });
                }
            } else {
                res.json({
                    status: false,
                    data: null,
                    msg: "Not an admin",
                });
            }
        }
    });
});
//update Coupon Code
// AdminPanel.put("/editCoupon/:couponId", isAdmin, async (req, res) => {
//   const { couponId } = req.params;
//   const { couponCode, couponType, link, linkWith, couponValue, expirationDate, couponAccess } =
//     req.body;
//   jwt.verify(req.token, process.env.ADMIN_SECRET_KEY, async (err, Data) => {
//     if (err) {
//       res.status(401).json({
//         status: false,
//         data: null,
//         msg: err,
//       });
//     } else {
//       const adminDetails = await findAdminTeacherUsingUserId(Data.studentId);
//       if (adminDetails && couponId !== null) {
//         const coupon = await couponTable.findByIdAndUpdate(couponId, {
//           couponCode: couponCode,
//           couponType: couponType,
//           link,
//           linkWith,
//           couponValue: couponValue,
//           expirationDate: expirationDate,
//           couponAccess: couponAccess,
//           updated_at: new Date(moment().add(5, "hours").add(30, "minutes")),
//         });
//         if (coupon) {
//           const updateCoupon = await couponTable.findById(couponId);
//           res.json({
//             status: true,
//             data: updateCoupon,
//             msg: "Coupon Updated Successfully",
//           });
//         } else {
//           res.json({
//             status: false,
//             data: null,
//             msg: "Coupon Not Found",
//           });
//         }
//       } else {
//         res.json({
//           status: false,
//           data: null,
//           msg: "Not an admin",
//         });
//       }
//     }
//   });
// });

AdminPanel.put("/editCoupon/:couponId", isAdmin, async (req, res) => {
    const { couponId } = req.params;
    let { couponCode, couponType, link, linkWith, selectedList, couponValue, expirationDate, couponAccess, is_active, student, count } =
        req.body;
    if (!couponId || !couponType || !couponAccess || !couponCode || !couponValue || !expirationDate || !link) {
        return res.json({
            status: false,
            data: null,
            msg: `Please provide required details!`
        })
    }
    try {
        if ((link != 'none' && selectedList.length < 1) || isNaN(count)) {
            return res.json({
                status: false,
                data: null,
                msg: `Select correct linkWith couponAccess & valid count`
            })
        }
        if (student != null && link != 'none') {
            return res.json({
                status: false,
                data: null,
                msg: "Make link with none for user specific coupon"
            })
        }
        const decoded = jwt.verify(req.token, process.env.ADMIN_SECRET_KEY);
        const adminDetails = await findAdminTeacherUsingUserId(decoded.studentId);
        if (!adminDetails) {
            return res.status(401).json({
                status: false,
                data: null,
                msg: "Not an admin",
            });
        }
        if (couponAccess == 'single' && (student == null || count <= 0)) {
            return res.json({
                status: false,
                data: null,
                msg: `Select user & apply count for specific user.`
            })
        }

        let linkWiths = selectedList?.filter((item) => item != "")?.map((item) => { return item?._id });

        if (link == 'batch') {
            if (linkWiths[0] != 'all') {
                const batch = await BatchesTable.find({ _id: { $in: linkWiths } });
                if (batch.length !== linkWiths.length) {
                    return res.json({
                        status: false,
                        data: null,
                        msg: "please provide existing batch"
                    })
                }
            }


        } else if (link == 'category') {
            const batchCategory = await categoryTable.find({ _id: { $in: linkWiths } });
            if (batchCategory.length !== linkWiths.length) {
                return res.json({
                    status: false,
                    data: null,
                    msg: "please provide existing Batch Category"
                })
            }

        } else if (link == 'testSeries') {
            const testSeries = await TestSeriesTable.find({ _id: { $in: linkWiths } });
            if (testSeries.length !== linkWiths.length) {
                return res.json({
                    status: false,
                    data: null,
                    msg: "please provide existing testSeries"
                })
            }

        } else if (link == 'product') {
            if (linkWiths[0] != 'all') {
                const product = await storeProductTable.find({ _id: { $in: linkWiths } });
                if (product.length !== linkWiths.length) {
                    return res.json({
                        status: false,
                        data: null,
                        msg: "please provide existing product"
                    })
                }
            }


        } else if (link == 'productCategory') {
            const productCategory = await productCategoryTable.find({ _id: { $in: linkWiths } });
            if (productCategory.length !== linkWiths.length) {
                return res.json({
                    status: false,
                    data: null,
                    msg: "please provide existing product category"
                })
            }

        } else {
            linkWith = "";
            linkWiths;[]
        }

        const coupon = await couponTable.findByIdAndUpdate(couponId, {
            couponCode,
            couponType,
            couponAccess,
            couponValue,
            link,
            linkWith: linkWiths[0],
            student,
            count,
            linkWiths,
            expirationDate,
            is_active
        })
        if (coupon) {
            return res.json({
                status: true,
                data: coupon,
                msg: 'Coupon updated Successfully'
            })
        }

        return res.json({
            status: true,
            data: null,
            msg: 'Updated'
        })
    } catch (error) {
        return res.json({
            status: false,
            data: null,
            msg: error.message || `Something went wrong`
        })
    }
})

AdminPanel.get("/getCouponById/:couponId", isAdmin, async (req, res) => {
    const { couponId } = req.params;
    jwt.verify(req.token, process.env.ADMIN_SECRET_KEY, async (err, Data) => {
        if (err) {
            res.status(401).json({
                status: false,
                data: null,
                msg: err,
            });
        } else {
            const adminDetails = await findAdminTeacherUsingUserId(Data.studentId);
            if (adminDetails && couponId !== null) {
                const coupon = await couponTable.findOne({ _id: couponId }).populate("student", "_id FullName email mobileNumber");
                res.json({
                    status: true,
                    data: { ...coupon?._doc, student: coupon?.student?._id ? { value: coupon?.student?._id, label: `${coupon?.student?.FullName} ${coupon?.student?.email} ${coupon?.student?.mobileNumber}` } : null },
                    msg: "Coupon fetched Successfully",
                });
            } else {
                res.json({
                    status: false,
                    data: null,
                    msg: "Coupon Not Found",
                });
            }
        }
    })
})
//enable Or disable Coupon Code
AdminPanel.put(
    "/enableOrDisableCoupon/:couponId",
    isAdmin,
    async (req, res) => {
        const { couponId } = req.params;
        const { is_active } = req.body;
        jwt.verify(req.token, process.env.ADMIN_SECRET_KEY, async (err, Data) => {
            if (err) {
                res.status(401).json({
                    status: false,
                    data: null,
                    msg: err,
                });
            } else {
                const adminDetails = await findAdminTeacherUsingUserId(Data.studentId);
                if (adminDetails && couponId !== null) {
                    const coupon = await couponTable.findByIdAndUpdate(couponId, {
                        is_active: is_active,
                    });
                    if (coupon) {
                        const updateCoupon = await couponTable.findById(couponId);
                        res.json({
                            status: true,
                            data: updateCoupon,
                            msg: "Coupon Status updated Successfully",
                        });
                    } else {
                        res.json({
                            status: false,
                            data: null,
                            msg: "Coupon Not Found",
                        });
                    }
                } else {
                    res.json({
                        status: false,
                        data: null,
                        msg: "Not an admin",
                    });
                }
            }
        });
    }
);
//delete Coupon Code ById
AdminPanel.delete("/deleteCoupon/:couponId", isAdmin, async (req, res) => {
    const { couponId } = req.params;
    jwt.verify(req.token, process.env.ADMIN_SECRET_KEY, async (err, Data) => {
        if (err) {
            res.status(401).json({
                status: false,
                msg: err,
            });
        } else {
            const adminDetails = await findAdminTeacherUsingUserId(Data.studentId);
            if (adminDetails && couponId !== null) {
                // const coupon = await couponTable.findByIdAndDelete(couponId);
                const coupon = await couponTable.findByIdAndUpdate(couponId, { is_active: false })
                if (coupon) {
                    await savePanelEventLogs(
                        adminDetails._id,
                        "deleteCoupon",
                        "delete",
                        coupon
                    )
                    res.json({
                        status: true,
                        data: null,
                        msg: "Coupon Deleted Successfully",
                    });
                } else {
                    res.json({
                        status: false,
                        data: null,
                        msg: "Coupon Not Found",
                    });
                }
            } else {
                res.json({
                    status: false,
                    data: null,
                    msg: "Not an admin",
                });
            }
        }
    });
});

// <----------  STUDENT COUPON SECTION --------->

//studenct Verify CouponCode
AdminPanel.post(
    "/verifyCoupon",
    ValidateToken,
    async (req, res) => {
        const { couponCode, link, linkWith, from } = req.body;
        if (!linkWith || !couponCode || !['batch', 'testSeries', 'product', 'batch_emi'].includes(link)) {
            return res.json({
                status: false,
                data: null,
                msg: "Provide required parameters"
            });
        }

        jwt.verify(req.token, process.env.SECRET_KEY, async (err, Data) => {
            if (err) {
                return res.status(401).json({
                    status: false,
                    data: null,
                    msg: err,
                });
            } else {
                const studentDetails = await findUserByUserId(Data.studentId);
                if (studentDetails && couponCode !== null) {
                    const current = moment().add(5, 'hours').add(30, 'minutes').toDate();
                    const coupon = await couponTable.findOne({
                        couponCode,
                        is_active: true,
                        expirationDate: { $gt: current }
                    });

                    const coupons = await couponTable.find({
                        couponCode,
                        is_active: true,
                        expirationDate: { $gt: current }
                    })
                    const allLinkedIds = coupons.map((item) => { return item?.linkWith });

                    if (coupon) {
                        let couponCode = coupon?.couponCode;
                        let couponType = coupon?.couponType;
                        let couponValue = coupon?.couponValue;
                        if (couponCode == "SD50" && link == "batch") {
                            const isValid = await BatchesTable.find({
                                _id: linkWith,
                                stream: { $in: ['Bihar Teaching Exams', 'UP Teaching Exams', 'KVS/NVS', 'DSSSB Teaching Exams', 'Jharkhand Teaching Exams', 'Other Teaching Exams', 'UGC NET JRF'] }
                            });
                            if (isValid && isValid.length > 0) {
                                return res.json({
                                    status: true,
                                    data: {
                                        id: coupon._id,
                                        couponCode: coupon.couponCode,
                                        couponType: coupon.couponType,
                                        couponValue: coupon.couponValue,
                                        is_active: coupon.is_active,
                                    },
                                    msg: "Coupon Applied"
                                })
                            } else {
                                return res.json({
                                    status: false,
                                    data: null,
                                    msg: "Invalid Coupon"
                                })
                            }
                        }
                        if (link === 'batch') {
                            if (coupon?.linkWith == 'all') {
                                return res.json({
                                    status: true,
                                    data: {
                                        id: coupon._id,
                                        couponCode: coupon.couponCode,
                                        couponType: coupon.couponType,
                                        couponValue: coupon.couponValue,
                                        is_active: coupon.is_active,
                                    },
                                    msg: "Coupon Applied",
                                });
                            }

                            if (coupon?.linkWith == linkWith || allLinkedIds?.includes(linkWith)) {
                                // console.log('valid')
                                const batch = await BatchesTable.findOne({ _id: linkWith });
                                if (!batch) {
                                    return res.json({
                                        status: false,
                                        data: null,
                                        msg: "Invalid Coupon Code"
                                    })
                                }
                                return res.json({
                                    status: true,
                                    data: {
                                        id: coupon._id,
                                        couponCode: coupon.couponCode,
                                        couponType: coupon.couponType,
                                        couponValue: coupon.couponValue,
                                        is_active: coupon.is_active,
                                    },
                                    msg: "Coupon Applied",
                                });
                            }
                            if (coupon?.link === 'category') {
                                // find category 
                                // console.log('category coupon')
                                // if multiple array exist with coupon Code 

                                const category = await categoryTable.findOne({ _id: coupon?.linkWith });
                                if (!category) {
                                    return res.json({
                                        status: false,
                                        data: null,
                                        msg: "Invalid Coupon Code"
                                    })
                                }
                                // console.log(category);
                                //  find Batch 
                                const batchByCategory = await BatchesTable.findOne({ _id: linkWith, stream: category?.title });
                                if (!batchByCategory) {
                                    return res.json({
                                        status: false,
                                        data: null,
                                        msg: "Invalid Coupon Code"
                                    })
                                }
                                // console.log(batchByCategory)
                                let condition = typeof linkWith === 'object' ? batchByCategory?._id?.toString() == linkWith[0] : batchByCategory?._id?.toString() == linkWith
                                if (condition) {
                                    console.log('verify catgeory coupon')
                                    return res.json({
                                        status: true,
                                        data: {
                                            id: coupon._id,
                                            couponCode: coupon.couponCode,
                                            couponType: coupon.couponType,
                                            couponValue: coupon.couponValue,
                                            is_active: coupon.is_active,
                                        },
                                        msg: "Coupon Applied",
                                    });

                                }
                                return res.json({
                                    status: false,
                                    data: null,
                                    msg: "Invalid Coupon Code"
                                })



                            }
                            return res.json({
                                status: false,
                                data: null,
                                msg: "Invalid Coupon Code"
                            })

                        }

                        // if (link === "batch" || link === 'testSeries') {
                        if (link === 'testSeries') {
                            // console.log("Test1", coupon._id, link, linkWith)

                            const isValidCpn = await couponTable.find({
                                // _id: coupon._id,
                                couponCode,
                                link,
                                linkWith: linkWith
                            })
                            // console.log("test2", isValidCpn)
                            if (isValidCpn.length > 0) {
                                return res.json({
                                    status: true,
                                    data: {
                                        id: coupon._id,
                                        couponCode: coupon.couponCode,
                                        couponType: coupon.couponType,
                                        couponValue: coupon.couponValue,
                                        is_active: coupon.is_active,
                                    },
                                    msg: "Coupon Applied",
                                });
                            } else {
                                return res.json({
                                    status: false,
                                    data: null,
                                    msg: "Invalid Coupon Code"
                                })
                            }
                        }
                        if (link === "batch_emi") {
                            // console.log("Test1", coupon._id, link, linkWith)
                            const isValidCpn = await couponTable.find({
                                // _id: coupon._id,
                                couponCode,
                                link: "batch",
                                linkWith: linkWith
                            })
                            const isEmiBatch = await BatchesTable.findOne({ _id: linkWith })
                            // console.log("test2", isValidCpn)
                            if (isValidCpn.length > 0 && isEmiBatch?.isEmi == true) {
                                return res.json({
                                    status: true,
                                    data: {
                                        id: coupon._id,
                                        couponCode: coupon.couponCode,
                                        couponType: coupon.couponType,
                                        couponValue: coupon.couponValue,
                                        is_active: coupon.is_active,
                                    },
                                    msg: "Coupon Applied",
                                });
                            } else {
                                return res.json({
                                    status: false,
                                    data: null,
                                    msg: "Invalid Coupon Code"
                                })
                            }
                        }
                        if (link === 'product') {
                            if (coupon?.linkWith == 'all') {
                                if (couponCode != "" && ["OFFER5", "OFFER10", "OFFER15"]?.includes(couponCode)) {
                                    const carts = await storeCartTable.findOne({ user: studentDetails?._id }).populate({
                                        path: 'products.productId',
                                        select: "_id regularPrice salePrice"
                                    })
                                    // console.log(carts)
                                    let productsAmount = carts?.products?.reduce((accumulator, currentValue) => accumulator + (parseFloat(currentValue.productId?.salePrice) * parseInt(currentValue?.quantity)), 0);
                                    productsAmount = parseFloat(productsAmount)
                                    if (productsAmount < 700 && couponCode == "OFFER15" && couponType == "percentage") {
                                        return res.json({
                                            status: false,
                                            data: null,
                                            msg: `Invalid Coupon Code`
                                        })
                                    }
                                    if (productsAmount < 400 && ["OFFER10", "OFFER15"]?.includes(couponCode) && couponType == "percentage") {
                                        return res.json({
                                            status: false,
                                            data: null,
                                            msg: `Invalid Coupon Code`
                                        })
                                    }
                                    // console.log(couponCode);
                                    if (productsAmount < 200 && ["OFFER5", "OFFER10", "OFFER15"]?.includes(couponCode) && couponType == "percentage") {
                                        return res.json({
                                            status: false,
                                            data: null,
                                            msg: `Invalid Coupon Code`
                                        })
                                    }

                                }

                                else {
                                    return res.json({
                                        status: true,
                                        data: {
                                            id: coupon._id,
                                            couponCode: coupon.couponCode,
                                            couponType: coupon.couponType,
                                            couponValue: coupon.couponValue,
                                            is_active: coupon.is_active,
                                        },
                                        msg: "Coupon Applied",
                                    });
                                }
                                return res.json({
                                    status: true,
                                    data: {
                                        id: coupon._id,
                                        couponCode: coupon.couponCode,
                                        couponType: coupon.couponType,
                                        couponValue: coupon.couponValue,
                                        is_active: coupon.is_active,
                                    },
                                    msg: "Coupon Applied",
                                });
                            }

                            if (coupon?.link == 'productCategory') {
                                const findProduct = await storeProductTable.find({
                                    // category: coupon?.linkWith
                                    categories: { $in: [coupon?.linkWith] }
                                })
                                // console.log( findProduct);
                                // console.log(coupon);
                                const productIds = findProduct?.map((item) => item._id.toString())
                                if (isSubSet(productIds, linkWith)) {
                                    return res.json({
                                        status: true,
                                        data: {
                                            id: coupon._id,
                                            couponCode: coupon.couponCode,
                                            couponType: coupon.couponType,
                                            couponValue: coupon.couponValue,
                                            is_active: coupon.is_active,
                                        },
                                        msg: "Coupon Applied",
                                    });
                                }

                            }
                            if (linkWith.length == 1 && coupon?.linkWith == linkWith[0]) {
                                // if ( linkWith.length == 1 && coupon?.linkWith == linkWith[0] ){
                                return res.json({
                                    status: true,
                                    data: {
                                        id: coupon._id,
                                        couponCode: coupon.couponCode,
                                        couponType: coupon.couponType,
                                        couponValue: coupon.couponValue,
                                        is_active: coupon.is_active,
                                    },
                                    msg: "Coupon Applied",
                                });
                                // }
                            }

                            let coupons = await couponTable.find({
                                couponCode,
                                is_active: true,
                                expirationDate: { $gt: current }
                            }).select('linkWith');
                            let categoryIds = coupons?.map((cou) => cou?.linkWith);
                            let findProduct = await storeProductTable.find({
                                // category: item?.linkWith
                                // category: categoryIds
                                categories: { $in: categoryIds }
                            }).select("_id")
                            let productIds = findProduct?.map((item2) => item2?._id.toString())
                            if (isSubSet(productIds, linkWith)) {
                                return res.json({
                                    status: true,
                                    data: {
                                        id: coupon?._id,
                                        couponCode: coupon?.couponCode,
                                        couponType: coupon?.couponType,
                                        couponValue: coupon?.couponValue,
                                        is_active: coupon?.is_active,
                                    },
                                    msg: "Coupon Applied",
                                });
                            }

                            // else{
                            return res.json({
                                status: false,
                                data: null,
                                msg: "Invalid Coupon Code"
                            })
                            // }
                        }
                    } else {
                        return res.json({
                            status: false,
                            data: null,
                            msg: "Coupon Code Not Found Or Expired"
                        })
                    }


                } else {
                    return res.json({
                        status: false,
                        data: null,
                        msg: "User not found",
                    });
                }
            }
        });
    }
);
//get student Coupon
AdminPanel.get("/getStudentCoupon", ValidateToken, async (req, res) => {
    const { link, linkWith } = req.body;

    if (!linkWith || !['batch', 'testSeries', 'product'].includes(link)) {
        return res.json({
            status: false,
            data: null,
            msg: "Provide required parameters"
        });
    }

    try {
        jwt.verify(req.token, process.env.SECRET_KEY, async (err, Data) => {
            if (err) {
                return res.json({
                    status: false,
                    data: null,
                    msg: err,
                });
            }

            const current = new Date(moment().add(5, "hours").add(30, "minutes"));
            const studentDetails = await findUserByUserId(Data.studentId);

            if (!studentDetails) {
                return res.json({
                    status: false,
                    data: null,
                    msg: "User not found",
                });
            }

            let coupon = [];

            if (link === "batch" || link === "testSeries") {
                coupon = await couponTable.find({
                    is_active: true,
                    expirationDate: { $gt: current },
                    couponAccess: "all",
                    linkWith: linkWith
                });
            }
            if (link === "product" && Array.isArray(linkWith)) {
                for (let k = 0; k < link.length; k++) {
                    const productCoupon = await couponTable.find({
                        is_active: true,
                        expirationDate: { $gt: current },
                        couponAccess: "all",
                        linkWith: linkWith[k]
                    });
                    coupon = coupon.concat(productCoupon);
                }
            }

            let couponArr = coupon.map(couponItem => ({
                id: couponItem._id,
                couponCode: couponItem.couponCode,
                couponType: couponItem.couponType,
                couponValue: couponItem.couponValue,
                expirationDate: moment(couponItem.expirationDate).fromNow(),
                is_active: couponItem.is_active,
            }));

            res.json({
                status: true,
                data: [],
                msg: "Available Coupon Code",
            });
        });
    } catch (error) {
        console.error(error);
        res.status(500).json({
            status: false,
            data: null,
            msg: "Internal Server Error",
        });
    }
});

// TIMER SECTION

AdminPanel.post("/saveTimer", ValidateToken, async (req, res) => {
    const { timerDuration, TimerTitle } = req.body;
    if (!timerDuration || !TimerTitle) {
        return res.json({
            status: false,
            data: null,
            msg: "Please fill all the fields",
        });
    }
    jwt.verify(req.token, process.env.SECRET_KEY, async (err, Data) => {
        if (err) {
            res.status(401).json({
                status: false,
                data: null,
                msg: err,
            });
        } else {
            const date = new Date(moment().add(5, "hours").add(30, "minutes"));
            let formatedDate = formatDate(date);
            const studentDetails = await findUserByUserId(Data.studentId);
            if (studentDetails) {
                const dataTimer = new Timer({
                    user: studentDetails._id,
                    timerDuration: timerDuration,
                    TimerTitle: TimerTitle,
                    created_at: formatedDate,
                });
                const TimerSaved = await dataTimer.save();
                res.json({
                    status: true,
                    data: TimerSaved,
                    msg: "Timer Added Successfully",
                });
            } else {
                res.json({
                    status: false,
                    data: null,
                    msg: "User not found",
                });
            }
        }
    });
});

AdminPanel.get("/getMyTimers", ValidateToken, async (req, res) => {
    jwt.verify(req.token, process.env.SECRET_KEY, async (err, Data) => {
        if (err) {
            res.status(401).json({
                status: false,
                data: null,
                msg: err,
            });
        } else {
            const studentDetails = await findUserByUserId(Data.studentId);
            if (studentDetails) {
                const timerData = await Timer.find({
                    user: studentDetails._id,
                });
                let timerArr = [];
                timerData.forEach((e) => {
                    timerArr.push({
                        id: e._id,
                        userId: e.user,
                        timerDuration: e.timerDuration,
                        TimerTitle: e.TimerTitle,
                        created_at: e.created_at,
                    });
                });
                if (timerData) {
                    res.json({
                        status: true,
                        data: timerArr,
                        msg: "My all timers",
                    });
                } else {
                    res.json({
                        status: false,
                        data: null,
                        msg: "Quizes Not Found",
                    });
                }
            } else {
                res.json({
                    status: false,
                    data: null,
                    msg: "Not authorized",
                });
            }
        }
    });
});

AdminPanel.delete("/deleteTimer/:id", ValidateToken, async (req, res) => {
    const { id } = req.params;
    jwt.verify(req.token, process.env.SECRET_KEY, async (err, Data) => {
        if (err) {
            res.status(401).json({
                status: false,
                data: null,
                msg: err,
            });
        } else {
            const studentDetails = await findUserByUserId(Data.studentId);
            if (studentDetails) {
                const dataTimer = await Timer.findByIdAndDelete(id);
                if (dataTimer) {
                    res.json({
                        status: true,
                        msg: "Timer Deleted Successfully",
                    });
                } else {
                    res.json({
                        status: false,
                        msg: "Timer Not Exists",
                    });
                }
            } else {
                res.json({
                    status: false,
                    msg: "Unable to delete timer",
                });
            }
        }
    });
});

AdminPanel.get("/getTimerByStudentId/:id", isAdmin, async (req, res) => {
    const { id } = req.params;
    jwt.verify(req.token, process.env.ADMIN_SECRET_KEY, async (err, Data) => {
        if (err) {
            res.status(401).json({
                status: false,
                data: null,
                msg: err,
            });
        } else {
            const adminDetails = await findAdminTeacherUsingUserId(Data.studentId);
            if (adminDetails) {
                const timerData = await Timer.find({ user: id });
                let timerArr = [];
                timerData.forEach((e) => {
                    timerArr.push({
                        id: e._id,
                        timerDuration: e.timerDuration,
                        TimerTitle: e.TimerTitle,
                        created_at: e.created_at,
                    });
                });
                if (timerData) {
                    res.json({
                        status: true,
                        data: timerArr,
                        msg: "Timer Details",
                    });
                } else {
                    res.json({
                        status: false,
                        data: null,
                        msg: "Timer Details Not Found",
                    });
                }
            } else {
                res.json({
                    status: false,
                    data: null,
                    msg: "Not admin",
                });
            }
        }
    });
});

// DAILY - QUIZES SECTION

//add quiz
AdminPanel.post(
    "/addQuiz",
    isAdmin,
    upload.single("file"),
    async (req, res) => {
        const {
            title,
            description,
            duration,
            language,
            no_ques,
            isNegative,
            negativeMarks,
            eachQueMarks,
            link,
            linkWith,
            isActive,
            created_at,
            resultType,
            category,
            subCategory
        } = req.body;
        jwt.verify(req.token, process.env.ADMIN_SECRET_KEY, async (err, Data) => {
            if (err) {
                res.status(401).json({
                    status: false,
                    data: null,
                    msg: err,
                });
            } else {
                const adminDetails = await findAdminTeacherUsingUserId(Data.studentId);
                if (created_at == 'null') {
                    return res.json({
                        status: false,
                        data: null,
                        msg: `Required Starting Date & Time`
                    })
                }
                let formatedDate = formatDate(created_at);
                if (!["", "scholarshipTest"].includes(link) && ['undefined', ""].includes(linkWith)) {
                    return res.json({
                        status: false,
                        data: null,
                        msg: "Please Select link With also"
                    })
                }
                if (link == 'batch') {
                    const isBatch = await BatchesTable.findOne({ _id: linkWith });
                    if (!isBatch) {
                        return res.json({
                            status: false,
                            data: null,
                            msg: 'Provide correct batch'
                        })
                    }

                }
                if (link == 'testSeries') {
                    const isTestSeries = await TestSeriesTable.findOne({ _id: linkWith });
                    if (!isTestSeries) {
                        return res.json({
                            status: false,
                            data: null,
                            msg: 'Provide correct testSeries'
                        })
                    }
                }
                let fileLoc = [];
                if (req.file) {
                    // for(let i=0;i<req.files.length;i++){
                    const helperString = Math.floor(Date.now() / 1000);
                    const filename = (req.file.originalname.split(".")[0]).replace(/\s+/g, '_').replace(/[^a-zA-Z0-9_]/g, '');
                    // let FileNameOf=req.files[i].originalname.split("/").pop();
                    const extension = "." + req.file.originalname.split(".").pop();
                    FileUploadLocation = `Quiz/${title?.replace(/\s+/g, '_').replace(/[^a-zA-Z0-9_]/g, '')}/${filename}_${helperString}${extension}`;
                    let helperfileLoc = await uploadFile(
                        req.file.path,
                        FileUploadLocation
                    );
                    fileLoc.push(helperfileLoc);
                    // fileLoc = helperfileLoc
                    // }
                }
                let categoriesId = category?.filter((item) => item != "");
                let subCategoriesId = subCategory?.filter((item) => item != "");
                const quiz = new QuizTable({
                    user: adminDetails._id,
                    quiz_title: title,
                    quiz_banner: fileLoc,
                    quiz_desc: description,
                    quiz_duration: duration,
                    language: language,
                    no_ques: no_ques,
                    is_negative: isNegative,
                    link,
                    linkWith: link === 'scholarshipTest' ? "" : linkWith,
                    negativeMarks: negativeMarks,
                    eachQueMarks: eachQueMarks,
                    is_active: isActive,
                    result_type: resultType,
                    is_manual: resultType,
                    category: categoriesId,
                    subCategory: subCategoriesId,
                    // created_at: formatedDate,
                    created_at

                });
                const result = await quiz.save();
                let link2 = `https://www.sdcampus.com?route=${`dailyQuizbyid`}&rootId=${result?._id}&childId=null`
                let details = {
                    "link": link2 ?? "",
                    "utmSource": "sdcampus_app",
                    "utmMedium": "refer",
                    "utmCampaign": "share_quiz",
                    "utmTerm": "",
                    "utmContent": "",
                    "socialTitle": title ?? "",
                    "socialDescription": "",
                    "socialImageLink": fileLoc[0] ?? ""
                }
                let data1 = await genrateDeepLink(details);
                await QuizTable.findByIdAndUpdate(result?._id, { shareLink: { link: data1.shortLink, text: title } })
                // if (isActive) {
                //     const data = {
                //         title: title,
                //         message: `New Test ${title} added`,
                //         fileUrl: result?.quiz_banner[0],
                //         route: "dailyQuizbyid",
                //         rootId: `${result?._id}`,
                //         childId: ""
                //     };
                //     await sendCustomNotification('all', data);
                // }
                if (result) {
                    res.json({
                        status: true,
                        data: result,
                        msg: "Quiz Details Added Successfully",
                    });
                } else {
                    res.json({
                        status: false,
                        data: null,
                        msg: "Quiz Details Not Added",
                    });
                }
            }
        });
    }
);
//get quizes
AdminPanel.get("/getQuizes", isAdmin, async (req, res) => {
    try {
        const { isActive, link } = req.query;
        jwt.verify(req.token, process.env.ADMIN_SECRET_KEY, async (err, Data) => {
            if (err) {
                res.status(401).json({
                    status: false,
                    data: null,
                    msg: err,
                });
            } else {
                const adminDetails = await findAdminTeacherUsingUserId(Data.studentId);
                if (adminDetails) {
                    let query = {}
                    if (isActive) {
                        query = { is_active: true }
                    }
                    if (link) {
                        query.link = link
                    }
                    const quiz = await QuizTable.find({ ...query }).populate("user", "FullName Role").sort({ createdAt: -1 });
                    const response = await Promise.all(quiz.map(async (item) => {
                        let linkWith = {};
                        let link = "";
                        let batchId = ""
                        if (item.link == 'batch') {
                            const batch = await BatchesTable.findOne({ _id: item.linkWith });
                            if (!batch) {
                                linkWith = { id: "NA", title: "NA" }
                            } else {
                                linkWith = { id: batch._id, title: batch.batch_name }
                                batchId = batch?.batchId

                            }
                            link = "Batch"

                        } else if (item.link == 'testSeries') {
                            const testSeries = await TestSeriesTable.findOne({ _id: item.linkWith });
                            if (!testSeries) {
                                linkWith = { id: "NA", title: "NA" }
                            } else {
                                linkWith = { id: testSeries?._id, title: testSeries?.testseries_name }

                            }
                            link = "Test Series"
                            // linkWith = { id: testSeries?._id, title: testSeries?.testseries_name }

                        }
                        else if (item.link == 'scholarshipTest') {
                            link = "Scholarship Test"
                            linkWith = { id: "NA", title: "NA" }
                        } else {
                            link = "None"
                            linkWith = { id: "NA", title: "NA" }
                        }

                        return {
                            id: item._id ?? "",
                            ...item?._doc,
                            label: item?.quiz_title,
                            value: item?._id,
                            link,
                            linkWith,
                            batchId,
                            user: { FullName: item?.user?.FullName ?? "NA", Role: item?.user?.Role ?? "NA" }

                        }
                    }))
                    if (quiz) {
                        res.json({
                            status: true,
                            // data: quiz.map((item) => {
                            //   return {
                            //     id: item?._id,
                            //     ...item._doc,
                            //   }
                            // }),
                            data: response,
                            msg: "Quiz Details",
                        });
                    } else {
                        res.json({
                            status: false,
                            data: null,
                            msg: "Quiz Details Not Found",
                        });
                    }
                } else {
                    res.json({
                        status: false,
                        data: null,
                        msg: "Not admin",
                    });
                }
            }
        });
    } catch (error) {
        return res.json({
            status: false,
            data: null,
            msg: error.message
        })
    }
});
//getQuizDetailsBy QuizId
AdminPanel.get("/getQuizDetails/:quizId", isAdmin, async (req, res) => {
    const { quizId } = req.params;
    jwt.verify(req.token, process.env.ADMIN_SECRET_KEY, async (err, Data) => {
        if (err) {
            res.status(401).json({
                status: false,
                data: null,
                msg: err,
            });
        } else {
            const adminDetails = await findAdminTeacherUsingUserId(Data.studentId);
            if (adminDetails) {
                if (quizId) {
                    const quiz = await QuizTable.findById(quizId);
                    let linkWith = {};
                    let link = "";
                    let value = {};
                    if (quiz?.link == 'batch') {
                        const batch = await BatchesTable.findOne({ _id: quiz?.linkWith });
                        if (!batch) {
                            linkWith = { id: "NA", title: "NA" }
                        }
                        link = "batch"
                        linkWith = { id: batch._id, title: batch.batch_name, value: batch?._id, label: batch?.batch_name },
                            value = { ...batch, value: batch?._id, label: batch?.batch_name }

                    } else if (quiz?.link == 'testSeries') {
                        const testSeries = await TestSeriesTable.findOne({ _id: quiz?.linkWith });
                        if (!testSeries) {
                            linkWith = { id: "NA", title: "NA" }
                        }
                        link = "testSeries"
                        linkWith = { id: testSeries._id, title: testSeries.testseries_name, value: testSeries?._id, label: testSeries?.testseries_name }
                        value = { testSeries, value: testSeries?._id, label: testSeries?.testseries_name }

                    } else {
                        link = "none"
                        linkWith = { id: "NA", title: "NA", value: "", label: "" }
                        value = { value: "", label: "" }
                    }
                    const GetTest = await TestSeriesTestTable.findById(quizId);
                    // console.log(quiz);
                    if (quiz || GetTest) {
                        res.json({
                            status: true,
                            data: { ...quiz?._doc, link, linkWith, value },
                            msg: "Quiz Details",
                        });
                    } else {
                        res.json({
                            status: false,
                            data: null,
                            msg: "Quiz Details Not Found",
                        });
                    }
                } else {
                    req.json({
                        status: false,
                        data: null,
                        msg: "Invalid QuizId",
                    });
                }
            } else {
                res.json({
                    status: false,
                    data: null,
                    msg: "Not admin",
                });
            }
        }
    });
});

AdminPanel.get("/getQuizsByBatchId/:batchId", isAdmin, async (req, res) => {
    const { batchId } = req.params;

    try {
        const decoded = jwt.verify(req.token, process.env.ADMIN_SECRET_KEY);
        const adminDetails = await findAdminTeacherUsingUserId(decoded.studentId);
        if (!adminDetails) {
            return res.json({
                status: false,
                data: null,
                msg: "Not an admin",
            });
        }
        if (batchId) {
            const quizs = await QuizTable.find({ link: 'batch', linkWith: batchId }).populate("user", "FullName Role");
            let resData = await Promise.all(quizs.map(async (quiz) => {
                let linkWith = {};
                let link = "none";
                if (quiz?.link == 'batch') {
                    const batch = await BatchesTable.findOne({ _id: quiz?.linkWith });
                    if (!batch) {
                        linkWith = { id: "NA", title: "NA" }
                    }
                    link = "batch"
                    linkWith = { id: batch._id, title: batch.batch_name }

                }
                return { ...quiz._doc, id: quiz?._doc?._id, link, linkWith }
            }))

            // const GetTest = await TestSeriesTestTable.findById(quizId);
            if (quizs) {
                res.json({
                    status: true,
                    data: resData,
                    msg: "Quiz Details",
                });
            } else {
                res.json({
                    status: false,
                    data: null,
                    msg: "Quiz Details Not Found",
                });
            }
        } else {
            req.json({
                status: false,
                data: null,
                msg: "Invalid BatchId",
            });
        }
    } catch (err) {
        res.status(401).json({
            status: false,
            data: null,
            msg: err.message,
        });
    }


});

AdminPanel.get("/getQuizDetailsByBatchId/:batchId", ValidateToken, async (req, res) => {
    const { batchId } = req.params;
    if (!batchId) {
        return res.json({
            status: false,
            data: null,
            msg: 'Required batchId'
        })
    }
    try {
        // console.log(batchId);
        const decoded = jwt.verify(req.token, process.env.ADMIN_SECRET_KEY);
        let QuizDetails;
        const studentDetails = await findUserByUserId(decoded.studentId);
        console.log(batchId)
        if (studentDetails) {
            const attemptedQuizes = await QuizResponseTable.find({
                user_id: studentDetails._id,
            });
            let checkArray = [];
            for (let i = 0; i < attemptedQuizes.length; i++) {
                checkArray.push(attemptedQuizes[i].quiz_id);
            }
            // console.log(checkArray);
            const isMyBatch = await MybatchTable.findOne({ user: studentDetails._id, batch_id: batchId });
            QuizDetails = await QuizTable.find(
                {
                    _id: { $nin: checkArray },
                    link: 'batch',
                    linkWith: batchId,
                    is_active: true,
                    no_ques: {
                        $gt: "0",
                    },
                    createdAt: { $exists: true, $gte: isMyBatch?.assignedDate }
                },
                { user: 0, __v: 0 }
            ).sort({ createdAt: -1 });
            let resArr = [];
            for (let j = 0; j < QuizDetails.length; j++) {
                const questions = await QuizQuestionsTable.find({
                    quiz_id: QuizDetails[j]._id,
                });
                let Res = {
                    id: QuizDetails[j]._id,
                    quiz_title: QuizDetails[j].quiz_title,
                    quiz_desc: QuizDetails[j].quiz_desc,
                    quiz_duration: QuizDetails[j].quiz_duration,
                    no_ques: questions.length.toString(),
                    quiz_banner: QuizDetails[j].quiz_banner[0] != "" ? QuizDetails[j].quiz_banner[0] : "https://static.sdcampus.com/Banner/Quiz_Banner/quizDefaultBanner_1732531006.png",
                    language: QuizDetails[j].language,
                    is_negative: QuizDetails[j].is_negative,
                    negativeMarks: QuizDetails[j].negativeMarks,
                    eachQueMarks: QuizDetails[j].eachQueMarks,
                    quiz_created_at: QuizDetails[j].created_at,
                };
                resArr.push(Res);
            }
            let atmptArr = [];
            QuizAteempted = await QuizTable.find(
                { _id: { $in: checkArray }, link: "batch", linkWith: batchId },
                { user: 0, __v: 0 }
            ).sort({ createdAt: -1 });
            for (let j = 0; j < QuizAteempted.length; j++) {
                let Res = {
                    id: QuizAteempted[j]._id,
                    quiz_title: QuizAteempted[j].quiz_title,
                    quiz_desc: QuizAteempted[j].quiz_desc,
                    quiz_duration: QuizAteempted[j].quiz_duration,
                    no_ques: QuizAteempted[j].no_ques.toString(),
                    // quiz_banner: QuizAteempted[j].quiz_banner[0],
                    quiz_banner: QuizAteempted[j].quiz_banner[0] != "" ? QuizAteempted[j].quiz_banner[0] : "https://static.sdcampus.com/Banner/Quiz_Banner/quizDefaultBanner_1732531006.png",
                    language: QuizAteempted[j].language,
                    is_negative: QuizAteempted[j].is_negative,
                    negativeMarks: QuizAteempted[j].negativeMarks,
                    eachQueMarks: QuizAteempted[j].eachQueMarks,
                    quiz_created_at: QuizAteempted[j].created_at,
                };
                atmptArr.push(Res);
            }
            if (QuizDetails) {
                res.json({
                    status: true,
                    data: {
                        is_attempted: atmptArr,
                        not_attempted: resArr,
                    },
                    msg: "Quizes",
                });
            } else {
                res.json({
                    status: false,
                    data: null,
                    msg: "Quizes Not Found",
                });
            }

        }
    } catch (err) {
        res.json({
            status: false,
            data: null,
            msg: err.message,
        });
    }


});
//delete quiz
AdminPanel.delete("/deleteQuiz/:id", isAdmin, async (req, res) => {
    const { id } = req.params;
    jwt.verify(req.token, process.env.ADMIN_SECRET_KEY, async (err, Data) => {
        if (err) {
            res.status(401).json({
                status: false,
                msg: err,
            });
        } else {
            const adminDetails = await findAdminTeacherUsingUserId(Data.studentId);
            if (adminDetails) {

                const quiz = await QuizTable.findByIdAndDelete(id);
                if (quiz) {
                    await savePanelEventLogs(
                        adminDetails._id,
                        "deleteQuiz",
                        "delete",
                        quiz
                    )
                    res.json({
                        status: true,
                        msg: "Quiz Deleted Successfully",
                    });
                } else {
                    res.json({
                        status: false,
                        msg: "Unable to delete quiz",
                    });
                }
            } else {
                res.json({
                    status: false,
                    msg: "Unable to delete quiz",
                });
            }
        }
    });
});
//edit quiz
AdminPanel.put(
    "/editQuiz/:id",
    isAdmin,
    upload.single("file"),
    async (req, res) => {
        const { id } = req.params;
        const {
            title,
            description,
            duration,
            language,
            NoOfQues,
            isNegative,
            link,
            linkWith,
            negativeMarks,
            eachQueMarks,
            isActive,
            category,
            subCategory,
        } = req.body;


        jwt.verify(req.token, process.env.ADMIN_SECRET_KEY, async (err, Data) => {
            if (err) {
                res.status(401).json({
                    status: false,
                    msg: err,
                });
            } else {
                const adminDetails = await findAdminTeacherUsingUserId(Data.studentId);
                if (!adminDetails) {
                    return res.status(401).json({
                        status: false,
                        data: null,
                        msg: "Not authorized",
                    });
                }
                if (isNegative == 'true' && negativeMarks.length === 0) {
                    return res.json({
                        status: false,
                        data: null,
                        msg: 'Please provide negative marks also'
                    })
                }
                if (!['none', 'batch', 'testSeries', 'scholarshipTest'].includes(link)) {
                    return res.json({
                        status: false,
                        data: null,
                        msg: 'Please priovide link details'
                    })
                }
                if (['batch', 'testSeries'].includes(link) && (!linkWith || linkWith == "" || linkWith == 'undifined')) {
                    return res.json({
                        status: false,
                        data: null,
                        msg: 'Please priovide linkWith details also'
                    })
                }
                if (link == 'batch') {
                    const isBatch = await BatchesTable.findOne({ _id: linkWith });
                    if (!isBatch) {
                        return res.json({
                            status: false,
                            data: null,
                            msg: 'Provide correct batch'
                        })
                    }

                }
                if (link == 'testSeries') {
                    const isTestSeries = await TestSeriesTable.findOne({ _id: linkWith });
                    if (!isTestSeries) {
                        return res.json({
                            status: false,
                            data: null,
                            msg: 'Provide correct testSeries'
                        })
                    }
                }
                const quizData = await QuizTable.findById(id);
                let categoriesId = category?.filter((item) => item != "");
                let subCategoriesId = subCategory?.filter((item) => item != "");
                // let fileLoc = quizData.quiz_banner;
                let fileLoc = [];
                if (req.file) {
                    const helperString = Math.floor(Date.now() / 1000);
                    const filename = (req.file.originalname.split(".")[0]).replace(/\s+/g, '_').replace(/[^a-zA-Z0-9_]/g, '');
                    const extension = "." + req.file.originalname.split(".").pop();
                    FileUploadLocation = `Quiz/${title?.replace(/\s+/g, '_').replace(/[^a-zA-Z0-9_]/g, '')}/${filename}_${helperString}${extension}`;
                    let helperfileLoc = await uploadFile(
                        req.file.path,
                        FileUploadLocation
                    );
                    fileLoc.push(helperfileLoc);
                } else {
                    fileLoc = quizData.quiz_banner;
                }

                const quiz = await QuizTable.findByIdAndUpdate(id, {
                    quiz_title: title,
                    quiz_banner: fileLoc,
                    quiz_desc: description,
                    quiz_duration: duration,
                    language: language,
                    no_ques: NoOfQues,
                    link,
                    linkWith: link === 'scholarshipTest' ? "" : linkWith,
                    is_negative: isNegative,
                    negativeMarks: negativeMarks,
                    eachQueMarks: eachQueMarks,
                    is_active: isActive,
                    category: categoriesId,
                    subCategory: subCategoriesId
                });
                // await savePanelEventLogs({
                //   user: adminDetails._id,
                //   event: "editQuiz",
                //   action: "update",
                //   data: {
                //     quiz_title: title,
                //     quiz_banner: fileLoc,
                //     quiz_desc: description,
                //     quiz_duration: duration,
                //     language: language,
                //     no_ques: NoOfQues,
                //     link,
                //     linkWith,
                //     is_negative: isNegative,
                //     negativeMarks: negativeMarks,
                //     eachQueMarks: eachQueMarks,
                //     is_active: isActive,
                //   }
                // })
                if (!quiz) {
                    return res.json({
                        status: false,
                        data: null,
                        msg: "Quiz Not Found",
                    });
                }

                const updatedQuiz = await QuizTable.findById(id);

                res.json({
                    status: true,
                    before: quiz,
                    after: updatedQuiz,
                    msg: "Quiz Updated Successfully",
                });
            }
        });
    }
);

AdminPanel.put("/makeActiveAndInActiveQuiz/:id", isAdmin, async (req, res) => {
    const { id } = req.params;
    if (!id) {
        return res.json({
            status: false,
            data: null,
            msg: `Required Id`
        })
    }
    try {
        const decoded = jwt.verify(req.token, process.env.ADMIN_SECRET_KEY);
        const admin = await findAdminTeacherUsingUserId(decoded.studentId);
        if (!admin) {
            return res.json({
                status: false,
                data: null,
                msg: `Not an admin`
            })
        }
        const isExist = await QuizTable.findOne({ _id: id });
        if (!isExist) {
            return res.json({
                status: false,
                data: null,
                msg: `Quiz Not Found`
            })
        }
        let isActive = isExist?.is_active == true ? false : true;
        const newQuiz = await QuizTable.findByIdAndUpdate(isExist?._id, { is_active: isActive }, { new: true, lean: true });
        return res.json({
            status: true,
            data: null,
            msg: `${newQuiz?.quiz_title} status chnages into ${isActive == true ? 'Active' : 'InActive'}`
        })
    } catch (error) {
        return res.json({
            status: false,
            data: null,
            msg: error.message
        })
    }
})
//QUIZ QUESTIONS

//add quiz question
AdminPanel.post("/addQuizQuestion/:quizId", isAdmin, async (req, res) => {
    const { quizId } = req.params;
    const {
        que_level,
        question_title,
        option1,
        option2,
        option3,
        option4,
        answer,
        correctAns,
        sectionId
    } = req.body;
    jwt.verify(req.token, process.env.ADMIN_SECRET_KEY, async (err, Data) => {
        if (err) {
            res.status(401).json({
                status: false,
                data: null,
                msg: err,
            });
        } else {
            const adminDetails = await findAdminTeacherUsingUserId(Data.studentId);
            const date = new Date(moment().add(5, "hours").add(30, "minutes"));
            let formatedDate = formatDate(date);
            const ques = new QuizQuestionsTable({
                quiz_id: quizId,
                que_level: que_level,
                question_title: question_title,
                option1: option1,
                option2: option2,
                option3: option3,
                option4: option4,
                answer: answer,
                correctOption: correctAns,
                created_at: formatedDate,
                sectionId
            });
            const result = await ques.save();
            const getQueCount = await QuizQuestionsTable.find({
                quiz_id: quizId,
            });
            await QuizTable.updateOne(
                { _id: quizId },
                { no_ques: getQueCount.length }
            );
            if (getQueCount) {
                res.json({
                    status: true,
                    data: getQueCount,
                    no_ques: getQueCount.length,
                    msg: "Quiz Question Added Successfully",
                });
            } else {
                res.json({
                    status: false,
                    data: null,
                    msg: "Quiz Question Not Added",
                });
            }
        }
    });
});

// upload bukl questions via Excel sheet
AdminPanel.post(
    "/uploadQuizQuestion/:quizId",
    isAdmin,
    upload.single("file"),
    async (req, res) => {
        const { quizId } = req.params;
        jwt.verify(req.token, process.env.ADMIN_SECRET_KEY, async (err, data) => {
            if (err) {
                res.status(401).json({
                    status: false,
                    data: null,
                    msg: err,
                });
            } else {
                const file = req.file;
                if (!file) {
                    return res.json({
                        status: false,
                        data: null,
                        message: "No file uploaded",
                    });
                }

                // Validate file type
                const allowedFileTypes = [".xls", ".xlsx"];
                const fileExtension = path.extname(file.originalname);
                if (!allowedFileTypes.includes(fileExtension)) {
                    return res.json({
                        status: false,
                        data: null,
                        message:
                            "Invalid file type. Only Excel files (.xls, .xlsx) are allowed.",
                    });
                }

                const quiz = await QuizTable.findById(quizId);
                if (quiz) {
                    // Read and validate Excel file columns
                    const workbook = xlsjs.readFile(file.path);
                    const sheetName = workbook.SheetNames[0];
                    const worksheet = workbook.Sheets[sheetName];
                    const data = xlsjs.utils.sheet_to_json(worksheet, { header: 1 });
                    const actualColumns = Object.values(data[0]);
                    const expectedColumns = [
                        "question_title_english",
                        "question_title_hindi",
                        "que_level_english",
                        "que_level_hindi",
                        "option1_english",
                        "option1_hindi",
                        "option2_english",
                        "option2_hindi",
                        "option3_english",
                        "option3_hindi",
                        "option4_english",
                        "option4_hindi",
                        "answer_english",
                        "answer_hindi",
                        "correctOption",
                        "is_active",
                        "sectionId"
                    ];
                    const missingColumns = expectedColumns.filter(
                        (column) => !actualColumns.includes(column)
                    );

                    if (missingColumns.length > 0) {
                        return res.json({
                            status: false,
                            data: null,
                            message: `Missing columns in the Excel file: ${missingColumns.join(
                                ", "
                            )}`,
                        });
                    }

                    // Continue with file processing
                    const date = moment().add(5, "hours").add(30, "minutes").toDate();
                    const formattedDate = formatDate(date);
                    const questions = [];
                    for (let i = 1; i < data.length; i++) {
                        const row = data[i];
                        console.log(row[16]);

                        // Ignore empty rows
                        if (row.filter((cell) => cell !== "").length === 0) {
                            continue;
                        }

                        const question = {
                            quiz_id: quizId.toString(),
                            question_title: {
                                e: row[0],
                                h: row[1],
                            },
                            que_level: {
                                e: row[2],
                                h: row[3],
                            },
                            option1: {
                                e: row[4],
                                h: row[5],
                            },
                            option2: {
                                e: row[6],
                                h: row[7],
                            },
                            option3: {
                                e: row[8],
                                h: row[9],
                            },
                            option4: {
                                e: row[10],
                                h: row[11],
                            },
                            answer: {
                                e: row[12],
                                h: row[13],
                            },
                            correctOption: row[14]?.toString(),
                            is_active: Boolean(row[15]),
                            sectionId: row[16] ?? null,
                            created_at: formattedDate,
                            updated_at: formattedDate,
                        };
                        questions.push(question);
                    }

                    try {
                        // console.log(questions);
                        // Save questions to the database
                        const savedQuestions = await QuizQuestionsTable.create(questions);
                        const questionCount = await QuizQuestionsTable.countDocuments({
                            quiz_id: quizId,
                        });
                        await QuizTable.updateOne(
                            { _id: quizId },
                            { no_ques: questionCount }
                        );

                        res.json({
                            status: true,
                            data: savedQuestions,
                            no_ques: questionCount,
                            msg: "Quiz questions added successfully",
                        });
                    } catch (error) {
                        res.json({
                            status: false,
                            data: error,
                            msg: "Failed to add quiz questions",
                        });
                    }
                } else {
                    const test = await TestSeriesTestTable.findById(quizId);
                    if (test) {
                        // Read and validate Excel file columns
                        const workbook = xlsjs.readFile(file.path);
                        const sheetName = workbook.SheetNames[0];
                        const worksheet = workbook.Sheets[sheetName];
                        const data = xlsjs.utils.sheet_to_json(worksheet, { header: 1 });
                        const actualColumns = Object.values(data[0]);
                        const expectedColumns = [
                            "question_title_english",
                            "question_title_hindi",
                            "que_level_english",
                            "que_level_hindi",
                            "option1_english",
                            "option1_hindi",
                            "option2_english",
                            "option2_hindi",
                            "option3_english",
                            "option3_hindi",
                            "option4_english",
                            "option4_hindi",
                            "answer_english",
                            "answer_hindi",
                            "correctOption",
                            "is_active",
                        ];
                        const missingColumns = expectedColumns.filter(
                            (column) => !actualColumns.includes(column)
                        );

                        if (missingColumns.length > 0) {
                            return res.json({
                                status: false,
                                data: null,
                                message: `Missing columns in the Excel file: ${missingColumns.join(
                                    ", "
                                )}`,
                            });
                        }

                        // Continue with file processing
                        const date = moment().add(5, "hours").add(30, "minutes").toDate();
                        const formattedDate = formatDate(date);
                        const questions = [];
                        for (let i = 1; i < data.length; i++) {
                            const row = data[i];

                            // Ignore empty rows
                            if (row.filter((cell) => cell !== "").length === 0) {
                                continue;
                            }

                            const question = {
                                quiz_id: quizId.toString(),
                                question_title: {
                                    e: row[0],
                                    h: row[1],
                                },
                                que_level: {
                                    e: row[2],
                                    h: row[3],
                                },
                                option1: {
                                    e: row[4],
                                    h: row[5],
                                },
                                option2: {
                                    e: row[6],
                                    h: row[7],
                                },
                                option3: {
                                    e: row[8],
                                    h: row[9],
                                },
                                option4: {
                                    e: row[10],
                                    h: row[11],
                                },
                                answer: {
                                    e: row[12],
                                    h: row[13],
                                },
                                correctOption: row[14]?.toString(),
                                is_active: Boolean(row[15]),
                                created_at: formattedDate,
                                updated_at: formattedDate,
                            };
                            questions.push(question);
                        }

                        try {
                            // Save questions to the database
                            const savedQuestions = await QuizQuestionsTable.create(questions);
                            const questionCount = await QuizQuestionsTable.countDocuments({
                                quiz_id: quizId,
                            });
                            await TestSeriesTestTable.updateOne(
                                { _id: quizId },
                                { No_of_questions: questionCount }
                            );

                            res.json({
                                status: true,
                                data: savedQuestions,
                                no_ques: questionCount,
                                msg: "Quiz questions added successfully",
                            });
                        } catch (error) {
                            res.json({
                                status: false,
                                data: error,
                                msg: "Failed to add quiz questions",
                            });
                        }
                    } else {
                        res.json({
                            status: false,
                            data: null,
                            message: "No Test found",
                        });
                    }
                }
            }
        });
    }
);

//upload objective type testseries questions
AdminPanel.post(
    "/uploadObjectiveTestQuestion/:testId",
    isAdmin,
    upload.single("file"),
    async (req, res) => {
        const { testId } = req.params;

        jwt.verify(req.token, process.env.ADMIN_SECRET_KEY, async (err, Data) => {
            if (err) {
                res.status(401).json({
                    status: false,
                    data: null,
                    msg: err,
                });
            } else {
                const file = req.file;
                if (!file) {
                    return res.json({
                        status: false,
                        data: null,
                        message: "No file uploaded",
                    });
                }

                // Validate file type
                const allowedFileTypes = [".xls", ".xlsx"];
                const fileExtension = path.extname(file.originalname);
                if (!allowedFileTypes.includes(fileExtension)) {
                    return res.json({
                        status: false,
                        data: null,
                        message:
                            "Invalid file type. Only Excel files (.xls, .xlsx) are allowed.",
                    });
                }

                const test = await TestSeriesTestTable.findById(testId);
                if (!test) {
                    return res.json({
                        status: false,
                        data: null,
                        message: "No Testseries test Found",
                    });
                }
                // Read and validate Excel file columns
                const workbook = xlsjs.readFile(file.path);
                const sheetName = workbook.SheetNames[0];
                const worksheet = workbook.Sheets[sheetName];
                const data = xlsjs.utils.sheet_to_json(worksheet, { header: 1 });
                const actualColumns = Object.values(data[0]);
                const expectedColumns = [
                    "question_title_english",
                    "question_title_hindi",
                    "que_level_english",
                    "que_level_hindi",
                    "option1_english",
                    "option1_hindi",
                    "option2_english",
                    "option2_hindi",
                    "option3_english",
                    "option3_hindi",
                    "option4_english",
                    "option4_hindi",
                    "answer_english",
                    "answer_hindi",
                    "correctOption",
                    "is_active",
                ];
                const missingColumns = expectedColumns.filter(
                    (column) => !actualColumns.includes(column)
                );

                if (missingColumns.length > 0) {
                    return res.json({
                        status: false,
                        data: null,
                        message: `Missing columns in the Excel file: ${missingColumns.join(
                            ", "
                        )}`,
                    });
                }

                // Continue with file processing
                const date = new Date(moment().add(5, "hours").add(30, "minutes"));
                let formattedDate = formatDate(date);
                const questions = [];
                for (let i = 1; i < data.length; i++) {
                    const row = data[i];

                    // Ignore empty rows
                    if (row.filter((cell) => cell !== "").length === 0) {
                        continue;
                    }

                    const question = {
                        quiz_id: testId.toString(),
                        question_title: {
                            e: row[0],
                            h: row[1],
                        },
                        que_level: {
                            e: row[2],
                            h: row[3],
                        },
                        option1: {
                            e: row[4],
                            h: row[5],
                        },
                        option2: {
                            e: row[6],
                            h: row[7],
                        },
                        option3: {
                            e: row[8],
                            h: row[9],
                        },
                        option4: {
                            e: row[10],
                            h: row[11],
                        },
                        answer: {
                            e: row[12],
                            h: row[13],
                        },
                        correctOption: row[14].toString(),
                        is_active: Boolean(row[15]),
                        created_at: formattedDate,
                        updated_at: formattedDate,
                    };
                    questions.push(question);
                }

                try {
                    // Save questions to the database
                    const savedQuestions = await QuizQuestionsTable.create(questions);
                    const questionCount = await QuizQuestionsTable.countDocuments({
                        quiz_id: testId,
                    });
                    await TestSeriesTestTable.updateOne(
                        { _id: testId },
                        { No_of_questions: questionCount }
                    );

                    res.json({
                        status: true,
                        data: savedQuestions,
                        no_ques: questionCount,
                        msg: "Testseries test questions added successfully",
                    });
                } catch (error) {
                    res.json({
                        status: false,
                        data: error,
                        msg: "Failed to add test questions",
                    });
                }
            }
        });
    }
);

//get quiz question
AdminPanel.get("/getQuizQuestions/:quizId", isAdmin, async (req, res) => {
    const { quizId } = req.params;
    jwt.verify(req.token, process.env.ADMIN_SECRET_KEY, async (err, Data) => {
        if (err) {
            res.status(401).json({
                status: false,
                data: null,
                msg: err,
            });
        } else {
            const adminDetails = await findAdminTeacherUsingUserId(Data.studentId);

            if (adminDetails) {
                const questions = await QuizQuestionsTable.find({
                    quiz_id: quizId,
                });
                if (questions) {
                    res.json({
                        status: true,
                        data: questions,
                        msg: "Quiz Question",
                    });
                } else {
                    res.json({
                        status: false,
                        data: null,
                        msg: "Quiz Question Not Found",
                    });
                }
            } else {
                res.json({
                    status: false,
                    data: null,
                    msg: "Not authorized",
                });
            }
        }
    });
});

AdminPanel.get("/getStudentDetails/:quizId", isAdmin, async (req, res) => {
    const { quizId } = req.params;
    jwt.verify(req.token, process.env.ADMIN_SECRET_KEY, async (err, Data) => {
        if (err) {
            res.status(401).json({
                status: false,
                data: null,
                msg: err,
            });
        } else {
            const adminDetails = await findAdminTeacherUsingUserId(Data.studentId);
            if (adminDetails) {
                let sArr = [];
                const students = await QuizResponseTable.find({
                    quiz_id: quizId,
                }).populate("user_id");
                if (students) {
                    students.forEach((user) => {
                        sArr.push({
                            userId: user.user_id._id,
                            userName: user.user_id.FullName,
                            is_published: user.is_active,
                        });
                    });
                    res.json({
                        status: true,
                        data: sArr,
                        msg: "Student Details",
                    });
                } else {
                    res.json({
                        status: false,
                        data: null,
                        msg: "Student Not Found",
                    });
                }
            } else {
                res.json({
                    status: false,
                    data: null,
                    msg: "Not authorized",
                });
            }
        }
    });
});
//delete quiz question
AdminPanel.delete("/deleteQuizQuestion/:id", isAdmin, async (req, res) => {
    try {
        const { id } = req.params;
        const decodedData = jwt.verify(req.token, process.env.ADMIN_SECRET_KEY);
        const adminDetails = await findAdminTeacherUsingUserId(
            decodedData.studentId
        );

        if (!adminDetails) {
            return res.json({
                status: false,
                data: null,
                msg: "Not authorized",
            });
        }

        const queRes = await QuizQuestionsTable.findById(id);
        if (!queRes) {
            return res.json({
                status: false,
                data: null,
                msg: "Quiz Question Not Found",
            });
        }
        await savePanelEventLogs(
            adminDetails._id,
            "deleteQuizQuestion",
            "delete",
            queRes
        )
        await QuizQuestionsTable.findByIdAndDelete(id);

        const getQueCount = await QuizQuestionsTable.countDocuments({
            quiz_id: queRes.quiz_id,
        });

        await QuizTable.updateOne(
            { _id: queRes.quiz_id },
            { no_ques: getQueCount }
        );

        res.json({
            status: true,
            data: getQueCount,
            msg: "Quiz Question Deleted Successfully",
        });
    } catch (err) {
        res.status(401).json({
            status: false,
            data: null,
            msg: err.message,
        });
    }
});

//edit quiz question
AdminPanel.put("/editQuizQuestion/:id", isAdmin, async (req, res) => {
    const { id } = req.params;
    const {
        que_level,
        question_title,
        option1,
        option2,
        option3,
        option4,
        answer,
        correctAns,
    } = req.body;
    jwt.verify(req.token, process.env.ADMIN_SECRET_KEY, async (err, Data) => {
        if (err) {
            res.status(401).json({
                status: false,
                data: null,
                msg: err,
            });
        } else {
            const adminDetails = await findAdminTeacherUsingUserId(Data.studentId);
            if (adminDetails) {
                const date = new Date(moment().add(5, "hours").add(30, "minutes"));
                let formatedDate = formatDate(date);
                const ques = await QuizQuestionsTable.findByIdAndUpdate(id, {
                    difficulty_level: que_level,
                    question_title: question_title,
                    option1: option1,
                    option2: option2,
                    option3: option3,
                    option4: option4,
                    answer: answer,
                    correctOption: correctAns,
                    updated_at: formatedDate,
                });
                if (ques) {
                    const updatedQuestion = await QuizQuestionsTable.findById(id);
                    res.json({
                        status: true,
                        data: updatedQuestion,
                        msg: "Quiz Question Updated Successfully",
                    });
                } else {
                    res.json({
                        status: false,
                        data: null,
                        msg: "Quiz Question Not Found",
                    });
                }
            } else {
                res.json({
                    status: false,
                    data: null,
                    msg: "Not authorized",
                });
            }
        }
    });
});

///  ATTEMPTED QUIZ BY STUDENT ////

//publish result by quiz id
AdminPanel.post("/publishResultByQuizId/:quizId", isAdmin, async (req, res) => {
    const { quizId } = req.params;
    jwt.verify(req.token, process.env.ADMIN_SECRET_KEY, async (err, Data) => {
        if (err) {
            res.status(401).json({
                status: false,
                data: null,
                msg: err,
            });
        } else {
            const adminDetails = await findAdminTeacherUsingUserId(Data.studentId);
            if (adminDetails) {
                const quizRes = await QuizQuestionsTable.find({
                    quiz_id: quizId,
                });
                if (quizRes.length == 0) {
                    return res.json({
                        status: false,
                        data: null,
                        msg: "Quiz  Not Found",
                    });
                }
                const quizResponses = await QuizResponseTable.updateMany(
                    {
                        quiz_id: quizId,
                    },
                    { is_active: true }
                );
                if (quizResponses) {
                    return res.json({
                        status: true,
                        data: null,
                        msg: "Result Published",
                    });
                } else {
                    return res.json({
                        status: false,
                        data: null,
                        msg: "Something went to worong ! Try again",
                    });
                }
            } else {
                return res.json({
                    status: false,
                    data: null,
                    msg: "Not an admin",
                });
            }
        }
    });
});

//publish result by studentId/quizId
AdminPanel.post(
    "/publishResultByStudentId/:studentId/:quizId",
    isAdmin,
    async (req, res) => {
        const { studentId, quizId } = req.params;
        jwt.verify(req.token, process.env.ADMIN_SECRET_KEY, async (err, Data) => {
            if (err) {
                res.status(401).json({
                    status: false,
                    data: null,
                    msg: err,
                });
            } else {
                const adminDetails = await findAdminTeacherUsingUserId(Data.studentId);
                if (adminDetails) {
                    const studentRes = await UserTable.findOne({ _id: studentId });
                    if (studentRes === null) {
                        return res.json({
                            status: false,
                            data: null,
                            msg: "Student Not Found",
                        });
                    }
                    const quiz = await QuizTable.findById(quizId);
                    const GetTest = await TestSeriesTestTable.findById(quizId);
                    if (quiz) {
                        const quizRes = await QuizQuestionsTable.find({
                            quiz_id: quizId,
                        });
                        if (quizRes.length == 0) {
                            return res.json({
                                status: false,
                                data: null,
                                msg: "Quiz  Not Found",
                            });
                        }
                        const quizResponses = await QuizResponseTable.updateOne(
                            {
                                quiz_id: quizId,
                                user_id: studentId,
                            },
                            { is_active: true }
                        );
                        let data;
                        if (studentRes.language === "hi") {
                            data = {
                                title: quiz.quiz_title,
                                message: `${quiz.quiz_title}          `,
                                route: "quizresult",
                            };
                        } else {
                            data = {
                                title: quiz.quiz_title,
                                message: `${quiz.quiz_title} result have been published. Do Check Now`,
                                route: "quizresult",
                            };
                        }
                        const myNotifi = new myNotificationModel({
                            user: studentRes._id,
                            title: data.title,
                            message: data.message,
                            route: data.route,
                        });
                        await myNotifi.save();
                        await sendPushNotification(studentRes.fcmToken, data);

                        if (quizResponses) {
                            return res.json({
                                status: true,
                                data: null,
                                msg: "Quiz Result Published",
                            });
                        } else {
                            return res.json({
                                status: false,
                                data: null,
                                msg: "Something went to worong ! Try again",
                            });
                        }
                    }
                    if (GetTest) {
                        const quizRes = await QuizQuestionsTable.find({
                            quiz_id: quizId,
                        });
                        if (quizRes.length == 0) {
                            return res.json({
                                status: false,
                                data: null,
                                msg: "Test Not Found",
                            });
                        }
                        const quizResponses = await QuizResponseTable.updateOne(
                            {
                                quiz_id: quizId,
                                user_id: studentId,
                            },
                            { is_active: true }
                        );

                        let data = {
                            title: GetTest.Test_title,
                            message: `${GetTest.Test_title} result have been published. Do Check Now`,
                            route: "quizresult",
                        };
                        const myNotifi = new myNotificationModel({
                            user: studentRes._id,
                            title: data.title,
                            message: data.message,
                            route: data.route,
                        });
                        await myNotifi.save();
                        await sendPushNotification(studentRes.fcmToken, data);

                        if (quizResponses) {
                            return res.json({
                                status: true,
                                data: null,
                                msg: ` ${data.title} Result Published`,
                            });
                        } else {
                            return res.json({
                                status: false,
                                data: null,
                                msg: "Something went to worong ! Try again",
                            });
                        }
                    }
                } else {
                    return res.json({
                        status: false,
                        data: null,
                        msg: "Not an admin",
                    });
                }
            }
        });
    }
);

// get Topper Score By QuizId
async function getTopperScore(quizId) {
    const score = await leaderBoardTable.findOne({
        quizId,
    });
    if (score !== null) return score.leaderBoard[0].myScore;
    else return "0.00";
}
//getResultByQuizIdAndStudentId
AdminPanel.get(
    "/getQuizResultByQuizIdAndStudentId/:quizId/:studentId",
    isAdmin,
    async (req, res) => {
        const { quizId, studentId } = req.params;
        jwt.verify(req.token, process.env.ADMIN_SECRET_KEY, async (err, Data) => {
            if (err) {
                res.status(401).json({
                    status: false,
                    data: null,
                    msg: err,
                });
            } else {
                const adminDetails = await findAdminTeacherUsingUserId(Data.studentId);
                if (adminDetails) {
                    const quiz = await QuizTable.findById(quizId);
                    const GetTest = await TestSeriesTestTable.findById(quizId);
                    if (!quiz && !GetTest) {
                        return res.json({
                            status: false,
                            data: null,
                            msg: "Test Or Quiz Not Found",
                        });
                    }

                    if (quiz) {
                        let studentRes = [];
                        let currectRes = [];
                        const quizResponse = await QuizResponseTable.find({
                            quiz_id: quizId,
                            user_id: studentId,
                        });
                        if (quizResponse) {
                            quizResponse.forEach((r) => {
                                studentRes.push(r.ans_res);
                            });
                            const quizQuestions = await QuizQuestionsTable.find({
                                quiz_id: quizId,
                            });
                            quizQuestions.forEach((e) => {
                                currectRes.push({
                                    ans_id: e._id,
                                    question_title: e.question_title[0],
                                    que_level: e.que_level[0],
                                    option1: e.option1[0],
                                    option2: e.option2[0],
                                    option3: e.option3[0],
                                    option4: e.option4[0],
                                    answer: e.answer[0],
                                    correctOption: e.correctOption,
                                });
                            });
                            studentRes = studentRes?.[0];
                            for (let i = 0; i < quizQuestions.length; i++) {
                                currectRes[i]["myAnswer"] = Object.values(
                                    quizResponse[0].ans_res[0]
                                )[i];
                            }
                            let correctAns = 0;
                            let skipped = 0;
                            let wrongAnswers = 0;
                            let easy = 0;
                            let medium = 0;
                            for (let i = 0; i < currectRes.length; i++) {
                                if (currectRes[i].myAnswer == "") skipped++;
                                if (currectRes[i].correctOption === currectRes[i].myAnswer)
                                    correctAns++;
                                else if (
                                    currectRes[i].correctOption !== currectRes[i].myAnswer &&
                                    currectRes[i].myAnswer !== ""
                                )
                                    wrongAnswers++;
                                if (currectRes[i]?.que_level?.e === "easy") easy++;
                                else if (currectRes[i]?.que_level?.e === "medium") medium++;
                            }
                            let myScore = 0;
                            if (quiz.is_negative) {
                                myScore =
                                    correctAns * parseFloat(quiz.eachQueMarks) -
                                    wrongAnswers * parseFloat(quiz.negativeMarks);
                            } else {
                                myScore = correctAns * parseFloat(quiz.eachQueMarks);
                            }
                            const topperScore = await getTopperScore(quizId);
                            const topperSc =
                                typeof topperScore === "number" ? topperScore : 0.0;
                            const topperPer =
                                (topperSc / (quiz.eachQueMarks * currectRes.length)) * 100;
                            const myScorePer =
                                (myScore / (quiz.eachQueMarks * currectRes.length)) * 100;
                            res.json({
                                status: true,
                                data: {
                                    is_published: false,
                                    quizId: quizId,
                                    totalMarks: (
                                        parseFloat(quiz.eachQueMarks) * currectRes.length
                                    ).toFixed(2),
                                    is_negative: quiz.is_negative,
                                    negativeMarks:
                                        quiz.negativeMarks !== ""
                                            ? parseFloat(quiz.negativeMarks).toFixed(2)
                                            : "0.00",
                                    myScore: {
                                        percentage: (myScorePer / 100).toFixed(2),
                                        number: myScore.toFixed(2),
                                    },
                                    accuracy: {
                                        percentage: (correctAns / currectRes.length).toFixed(2), // range b/w 0-1
                                        number: ((correctAns / currectRes.length) * 100).toFixed(2), // range 0-100
                                    },
                                    toperScore: {
                                        percentage: topperPer
                                            ? (topperPer / 100).toFixed(2)
                                            : "0.00",
                                        number: topperSc ? topperSc.toFixed(2) : "0.00",
                                    },
                                    summary: {
                                        noOfQues: currectRes.length,
                                        Attempted: currectRes.length - skipped,
                                        skipped,
                                        correctAns,
                                        wrongAnswers,
                                    },
                                    difficulty: {
                                        easy: {
                                            percentage: (easy / 100).toFixed(2),
                                            number: easy.toFixed(2),
                                        },
                                        medium: {
                                            percentage: (medium / 100).toFixed(2),
                                            number: medium.toFixed(2),
                                        },
                                        hard: {
                                            percentage: (
                                                (currectRes.length - (easy + medium)) /
                                                100
                                            ).toFixed(2),
                                            number: (currectRes.length - (easy + medium)).toFixed(2),
                                        },
                                    },
                                    response: currectRes,
                                },
                                msg: "Quiz Result !",
                            });
                        } else {
                            res.json({
                                status: false,
                                data: null,
                                msg: "Quiz Result Not Published !",
                            });
                        }
                    }
                    if (GetTest) {
                        let studentRes = [];
                        let currectRes = [];
                        const quizResponse = await QuizResponseTable.find({
                            quiz_id: quizId,
                            user_id: studentId,
                        });
                        if (quizResponse) {
                            quizResponse.forEach((r) => {
                                studentRes.push(r.ans_res);
                            });
                            const quizQuestions = await QuizQuestionsTable.find({
                                quiz_id: quizId,
                            });
                            quizQuestions.forEach((e) => {
                                currectRes.push({
                                    ans_id: e._id,
                                    question_title: e.question_title[0],
                                    que_level: e.que_level[0],
                                    option1: e.option1[0],
                                    option2: e.option2[0],
                                    option3: e.option3[0],
                                    option4: e.option4[0],
                                    answer: e.answer[0],
                                    correctOption: e.correctOption,
                                });
                            });
                            studentRes = studentRes?.[0];
                            for (let i = 0; i < quizQuestions.length; i++) {
                                currectRes[i]["myAnswer"] = Object.values(
                                    quizResponse[0].ans_res[0]
                                )[i];
                            }
                            let correctAns = 0;
                            let skipped = 0;
                            let wrongAnswers = 0;
                            let easy = 0;
                            let medium = 0;
                            for (let i = 0; i < currectRes.length; i++) {
                                if (currectRes[i].myAnswer == "") skipped++;
                                if (currectRes[i].correctOption === currectRes[i].myAnswer)
                                    correctAns++;
                                else if (
                                    currectRes[i].correctOption !== currectRes[i].myAnswer &&
                                    currectRes[i].myAnswer !== ""
                                )
                                    wrongAnswers++;
                                if (currectRes[i]?.que_level?.e === "easy") easy++;
                                else if (currectRes[i]?.que_level?.e === "medium") medium++;
                            }
                            let myScore = 0;
                            if (GetTest.negativemarking) {
                                myScore =
                                    correctAns * parseFloat(GetTest.eachQueMarks) -
                                    wrongAnswers * parseFloat(GetTest.negativeMarks);
                            } else {
                                myScore = correctAns * parseFloat(GetTest.eachQueMarks);
                            }
                            const topperScore = await getTopperScore(quizId);
                            const topperSc =
                                typeof topperScore === "number" ? topperScore : 0.0;
                            const topperPer =
                                (topperSc / (GetTest.eachQueMarks * currectRes.length)) * 100;
                            const myScorePer =
                                (myScore / (GetTest.eachQueMarks * currectRes.length)) * 100;
                            res.json({
                                status: true,
                                data: {
                                    is_published: false,
                                    quizId: quizId,
                                    totalMarks: (
                                        parseFloat(GetTest.eachQueMarks) * currectRes.length
                                    ).toFixed(2),
                                    is_negative: GetTest.negativemarking,
                                    negativeMarks:
                                        GetTest.negativeMarks !== ""
                                            ? parseFloat(GetTest.negativeMarks).toFixed(2)
                                            : "0.00",
                                    myScore: {
                                        percentage: (myScorePer / 100).toFixed(2),
                                        number: myScore.toFixed(2),
                                    },
                                    accuracy: {
                                        percentage: (correctAns / currectRes.length).toFixed(2), // range b/w 0-1
                                        number: ((correctAns / currectRes.length) * 100).toFixed(2), // range 0-100
                                    },
                                    toperScore: {
                                        percentage: topperPer
                                            ? (topperPer / 100).toFixed(2)
                                            : "0.00",
                                        number: topperSc ? topperSc.toFixed(2) : "0.00",
                                    },
                                    summary: {
                                        noOfQues: currectRes.length,
                                        Attempted: currectRes.length - skipped,
                                        skipped,
                                        correctAns,
                                        wrongAnswers,
                                    },
                                    difficulty: {
                                        easy: {
                                            percentage: (easy / 100).toFixed(2),
                                            number: easy.toFixed(2),
                                        },
                                        medium: {
                                            percentage: (medium / 100).toFixed(2),
                                            number: medium.toFixed(2),
                                        },
                                        hard: {
                                            percentage: (
                                                (currectRes.length - (easy + medium)) /
                                                100
                                            ).toFixed(2),
                                            number: (currectRes.length - (easy + medium)).toFixed(2),
                                        },
                                    },
                                    response: currectRes,
                                },
                                msg: "Quiz Result !",
                            });
                        } else {
                            res.json({
                                status: false,
                                data: null,
                                msg: "Quiz Result Not Published !",
                            });
                        }
                    }
                } else {
                    return res.json({
                        status: false,
                        data: null,
                        msg: "Not an admin",
                    });
                }
            }
        });
    }
);

//getResultByQuizId
AdminPanel.get("/getQuizResultByQuizId/:quizId", isAdmin, async (req, res) => {
    const { quizId } = req.params;
    jwt.verify(req.token, process.env.ADMIN_SECRET_KEY, async (err, Data) => {
        if (err) {
            res.status(401).json({
                status: false,
                data: null,
                msg: err,
            });
        } else {
            const adminDetails = await findAdminTeacherUsingUserId(Data.studentId);
            if (adminDetails) {
                const quiz = await QuizTable.findById(quizId);
                const GetTest = await TestSeriesTestTable.findById(quizId);
                if (!quiz && !GetTest) {
                    return res.json({
                        status: false,
                        data: null,
                        msg: "Test Or Quiz Not Found",
                    });
                }
                if (quiz) {
                    let studentRes = [];
                    let currectRes = [];
                    const quizResponse = await QuizResponseTable.find({
                        quiz_id: quizId,
                    });
                    if (quizResponse[0]?.is_active) {
                        quizResponse.forEach((r) => {
                            studentRes.push(r.user_id);
                        });
                        const quizQuestions = await QuizQuestionsTable.find({
                            quiz_id: quizId,
                        });
                        quizQuestions.forEach((e) => {
                            currectRes.push({
                                ans_id: e._id,
                                question_title: e.question_title[0],
                                que_level: e.que_level[0],
                                option1: e.option1[0],
                                option2: e.option2[0],
                                option3: e.option3[0],
                                option4: e.option4[0],
                                answer: e.answer[0],
                                correctOption: e.correctOption,
                            });
                        });
                        studentRes = studentRes?.[0];
                        for (let i = 0; i < quizQuestions.length; i++) {
                            currectRes[i]["myAnswer"] = Object.values(
                                quizResponse[0].ans_res[0]
                            )[i];
                        }
                        let correctAns = 0;
                        let skipped = 0;
                        let wrongAnswers = 0;
                        let easy = 0;
                        let medium = 0;
                        for (let i = 0; i < currectRes.length; i++) {
                            if (currectRes[i].myAnswer == "") skipped++;
                            if (currectRes[i].correctOption === currectRes[i].myAnswer)
                                correctAns++;
                            else if (
                                currectRes[i].correctOption !== currectRes[i].myAnswer &&
                                currectRes[i].myAnswer !== ""
                            )
                                wrongAnswers++;
                            if (currectRes[i]?.que_level?.e === "easy") easy++;
                            else if (currectRes[i]?.que_level?.e === "medium") medium++;
                        }
                        res.json({
                            status: true,
                            data: {
                                userId: studentRes,
                                negativeMarks: quiz.negativeMarks,
                                noOfQues: currectRes.length,
                                Attempted: currectRes.length - skipped,
                                skipped,
                                correctAns,
                                wrongAnswers,
                                easy,
                                medium,
                                hard: currectRes.length - (easy + medium),
                            },
                        });
                    } else {
                        res.json({
                            status: false,
                            data: null,
                            msg: "Quiz Result Not Published !",
                        });
                    }
                }
                if (GetTest) {
                    let studentRes = [];
                    let currectRes = [];
                    const quizResponse = await QuizResponseTable.find({
                        quiz_id: quizId,
                    });
                    if (quizResponse[0]?.is_active) {
                        quizResponse.forEach((r) => {
                            studentRes.push(r.user_id);
                        });
                        const quizQuestions = await QuizQuestionsTable.find({
                            quiz_id: quizId,
                        });
                        quizQuestions.forEach((e) => {
                            currectRes.push({
                                ans_id: e._id,
                                question_title: e.question_title[0],
                                que_level: e.que_level[0],
                                option1: e.option1[0],
                                option2: e.option2[0],
                                option3: e.option3[0],
                                option4: e.option4[0],
                                answer: e.answer[0],
                                correctOption: e.correctOption,
                            });
                        });
                        studentRes = studentRes?.[0];
                        for (let i = 0; i < quizQuestions.length; i++) {
                            currectRes[i]["myAnswer"] = Object.values(
                                quizResponse[0].ans_res[0]
                            )[i];
                        }
                        let correctAns = 0;
                        let skipped = 0;
                        let wrongAnswers = 0;
                        let easy = 0;
                        let medium = 0;
                        for (let i = 0; i < currectRes.length; i++) {
                            if (currectRes[i].myAnswer == "") skipped++;
                            if (currectRes[i].correctOption === currectRes[i].myAnswer)
                                correctAns++;
                            else if (
                                currectRes[i].correctOption !== currectRes[i].myAnswer &&
                                currectRes[i].myAnswer !== ""
                            )
                                wrongAnswers++;
                            if (currectRes[i]?.que_level?.e === "easy") easy++;
                            else if (currectRes[i]?.que_level?.e === "medium") medium++;
                        }
                        res.json({
                            status: true,
                            data: {
                                userId: studentRes,
                                negativeMarks: GetTest.negativeMarks,
                                noOfQues: currectRes.length,
                                Attempted: currectRes.length - skipped,
                                skipped,
                                correctAns,
                                wrongAnswers,
                                easy,
                                medium,
                                hard: currectRes.length - (easy + medium),
                            },
                        });
                    } else {
                        res.json({
                            status: false,
                            data: null,
                            msg: "Quiz Result Not Published !",
                        });
                    }
                }
            } else {
                return res.json({
                    status: false,
                    data: null,
                    msg: "Not an admin",
                });
            }
        }
    });
});

// function to design Quiz Leaderboard
// async function getQuizResults(quizId) {

//     const users = await QuizResponseTable.find({ quiz_id: quizId })
//         .populate("user_id")
//         .lean();
//     const usersArr = users.map((item) => ({
//         userId: item?.user_id?._id?.toString(),
//         FullName: item?.user_id?.FullName,
//         email: item?.user_id?.email,
//         mobileNumber: item?.user_id?.mobileNumber
//     }));
//     const quiz = await QuizTable.findById(quizId);
//     const GetTest = await TestSeriesTestTable.findById(quizId);
//     if (quiz) {
//         console.log("====================================", usersArr);
//         const quizResponseArr = await QuizResponseTable.find({
//             quiz_id: quizId,
//             user_id: { $in: usersArr.map((user) => user.userId) },
//         });
//         if (!quizResponseArr.length) {
//             return null;
//         }
//         const quizQuestions = await QuizQuestionsTable.find({ quiz_id: quizId });
//         const correctRes = quizQuestions.map((e) => ({
//             ans_id: e._id,
//             question_title: e.question_title[0],
//             que_level: e.que_level[0],
//             option1: e.option1[0],
//             option2: e.option2[0],
//             option3: e.option3[0],
//             option4: e.option4[0],
//             answer: e.answer[0],
//             correctOption: e.correctOption,
//         }));

//         const studentScores = [];
//         for (const quizResponse of quizResponseArr) {
//             const studentId = quizResponse.user_id.toString();
//             const studentRes = quizResponse.ans_res[0] || [];
//             correctRes.forEach((e, i) => {
//                 e.myAnswer = Object.values(studentRes)[i] || "";
//             });
//             let correctAns = 0;
//             let wrongAnswers = 0;
//             correctRes.forEach((e) => {
//                 if (e.correctOption === e.myAnswer) {
//                     correctAns++;
//                 } else if (e.myAnswer !== "") {
//                     wrongAnswers++;
//                 }
//             });
//             let myScore = 0;
//             if (quiz.is_negative) {
//                 myScore =
//                     correctAns * parseFloat(quiz.eachQueMarks) -
//                     wrongAnswers * parseFloat(quiz.negativeMarks);
//             } else {
//                 myScore = correctAns * parseFloat(quiz.eachQueMarks);
//             }
//             let studentName = "";
//             let email = "";
//             let mobileNumber = ""
//             const user = usersArr.find((e) => e.userId === studentId);
//             if (user) {
//                 studentName = user.FullName;
//                 email = user.email;
//                 mobileNumber = user.mobileNumber;
//             }
//             studentScores.push({
//                 studentId,
//                 studentName,
//                 email,
//                 mobileNumber,
//                 myScore,
//                 totalMarks: (parseFloat(quiz.eachQueMarks) * correctRes.length).toFixed(
//                     2
//                 ),
//                 accuracy: ((correctAns / correctRes.length) * 100).toFixed(2),
//             });
//         }
//         studentScores.sort((a, b) => {
//             if (b.myScore === a.myScore) {
//                 return b.accuracy - a.accuracy;
//             } else {
//                 return b.myScore - a.myScore;
//             }
//         });

//         return { quizId, studentScores };
//     }
//     if (GetTest) {
//         const quizResponseArr = await QuizResponseTable.find({
//             quiz_id: quizId,
//             user_id: { $in: usersArr.map((user) => user.userId) },
//         });
//         if (!quizResponseArr.length) {
//             return null;
//         }
//         const quizQuestions = await QuizQuestionsTable.find({ quiz_id: quizId });
//         const correctRes = quizQuestions.map((e) => ({
//             ans_id: e._id,
//             question_title: e.question_title[0],
//             que_level: e.que_level[0],
//             option1: e.option1[0],
//             option2: e.option2[0],
//             option3: e.option3[0],
//             option4: e.option4[0],
//             answer: e.answer[0],
//             correctOption: e.correctOption,
//         }));

//         const studentScores = [];
//         for (const quizResponse of quizResponseArr) {
//             const studentId = quizResponse.user_id.toString();
//             const studentRes = quizResponse.ans_res[0] || [];
//             correctRes.forEach((e, i) => {
//                 e.myAnswer = Object.values(studentRes)[i] || "";
//             });
//             let correctAns = 0;
//             let wrongAnswers = 0;
//             correctRes.forEach((e) => {
//                 if (e.correctOption === e.myAnswer) {
//                     correctAns++;
//                 } else if (e.myAnswer !== "") {
//                     wrongAnswers++;
//                 }
//             });
//             let myScore = 0;
//             if (GetTest.negativemarking) {
//                 myScore =
//                     correctAns * parseFloat(GetTest.eachQueMarks) -
//                     wrongAnswers * parseFloat(GetTest.negativeMarks);
//             } else {
//                 myScore = correctAns * parseFloat(GetTest.eachQueMarks);
//             }
//             let studentName = "";
//             let email = "";
//             const user = usersArr.find((e) => e.userId === studentId);
//             if (user) {
//                 studentName = user.FullName;
//                 email = user.email;
//             }
//             studentScores.push({
//                 studentId,
//                 studentName,
//                 email,
//                 myScore,
//                 totalMarks: (
//                     parseFloat(GetTest.eachQueMarks) * correctRes.length
//                 ).toFixed(2),
//                 accuracy: ((correctAns / correctRes.length) * 100).toFixed(2),
//             });
//         }
//         studentScores.sort((a, b) => {
//             if (b.myScore === a.myScore) {
//                 return b.accuracy - a.accuracy;
//             } else {
//                 return b.myScore - a.myScore;
//             }
//         });

//         return { quizId, studentScores };
//     }

// }

async function getQuizResults(quizId) {

    var users = await QuizResponseTable.find({ quiz_id: quizId })
        .populate("user_id")
        .lean();
    var usersArr = users.map((item) => ({
        userId: item?.user_id?._id?.toString(),
        FullName: item?.user_id?.FullName,
        email: item?.user_id?.email,
        mobileNumber: item?.user_id?.mobileNumber
    }));
    const quiz = await QuizTable.findById(quizId);
    if (quiz?.link == "batch") {
      const batch = await BatchesTable.findById(quiz?.linkWith);
      // console.log("====================================1", usersArr.length);
      users = await UserTable.find(
        { _id: { $in: batch?.student } },
        { _id: 1, FullName: 1, email: 1, mobileNumber: 1 }
      );
      usersArr = users.map((item) => ({
        userId: item?._id?.toString(),
        FullName: item?.FullName,
        email: item?.email,
        mobileNumber: item?.mobileNumber
      }));
      
    }
    const GetTest = await TestSeriesTestTable.findById(quizId);
    if (quiz) {
        // console.log("====================================2", usersArr.length);
        const quizResponseArr = await QuizResponseTable.find({
            quiz_id: quizId,
            user_id: { $in: usersArr.map((user) => user.userId) },
        });
        // console.log("====================================3", quizResponseArr[0]);
        if (!quizResponseArr.length) {
            return null;
        }
        const quizQuestions = await QuizQuestionsTable.find({ quiz_id: quizId });
        const correctRes = quizQuestions.map((e) => ({
            ans_id: e._id,
            question_title: e.question_title[0],
            que_level: e.que_level[0],
            option1: e.option1[0],
            option2: e.option2[0],
            option3: e.option3[0],
            option4: e.option4[0],
            answer: e.answer[0],
            correctOption: e.correctOption,
        }));

        const studentScores = [];
        for (const userLoop of usersArr) {
            const studentId = userLoop.userId;
            const studentRes = quizResponseArr.find(response => response.user_id.toString() === studentId)?.ans_res[0] || [];
            let is_attempted = false;
            if (studentRes.length === 0) {
                // console.log("No answers found for student:", studentId);
            } else {
                is_attempted = true;
            }
            // console.log("====================================4", studentRes);
            correctRes.forEach((e, i) => {
                e.myAnswer = Object.values(studentRes)[i] || "";
            });
            let correctAns = 0;
            let wrongAnswers = 0;
            correctRes.forEach((e) => {
                if (e.correctOption === e.myAnswer) {
                    correctAns++;
                } else if (e.myAnswer !== "") {
                    wrongAnswers++;
                }
            });
            let myScore = 0;
            if (quiz.is_negative) {
                myScore =
                    correctAns * parseFloat(quiz.eachQueMarks) -
                    wrongAnswers * parseFloat(quiz.negativeMarks);
            } else {
                myScore = correctAns * parseFloat(quiz.eachQueMarks);
            }
            let studentName = "";
            let email = "";
            let mobileNumber = ""
            // const user = usersArr.find((e) => e.userId === studentId);
            if (userLoop) {
                studentName = userLoop.FullName;
                email = userLoop.email;
                mobileNumber = userLoop.mobileNumber;
            }
            studentScores.push({
                studentId,
                studentName,
                email,
                mobileNumber,
                myScore,
                totalMarks: (parseFloat(quiz.eachQueMarks) * correctRes.length).toFixed(
                    2
                ),
                accuracy: ((correctAns / correctRes.length) * 100).toFixed(2),
                is_attempted: is_attempted,
            });
        }
        studentScores.sort((a, b) => {
            if (b.myScore === a.myScore) {
                return b.accuracy - a.accuracy;
            } else {
                return b.myScore - a.myScore;
            }
        });

        return { quizId, studentScores };
    }
    if (GetTest) {
        const quizResponseArr = await QuizResponseTable.find({
            quiz_id: quizId,
            user_id: { $in: usersArr.map((user) => user.userId) },
        });
        if (!quizResponseArr.length) {
            return null;
        }
        const quizQuestions = await QuizQuestionsTable.find({ quiz_id: quizId });
        const correctRes = quizQuestions.map((e) => ({
            ans_id: e._id,
            question_title: e.question_title[0],
            que_level: e.que_level[0],
            option1: e.option1[0],
            option2: e.option2[0],
            option3: e.option3[0],
            option4: e.option4[0],
            answer: e.answer[0],
            correctOption: e.correctOption,
        }));

        const studentScores = [];
        for (const userLoop of usersArr) {
          const studentId = userLoop.userId;
          const studentRes = quizResponseArr.find(response => response.user_id.toString() === studentId)?.ans_res[0] || [];
          let is_attempted = false;
            if (studentRes.length === 0) {
                // console.log("No answers found for student:", studentId);
            } else {
                is_attempted = true;
            }
          // console.log("====================================4", studentRes);
            correctRes.forEach((e, i) => {
                e.myAnswer = Object.values(studentRes)[i] || "";
            });
            let correctAns = 0;
            let wrongAnswers = 0;
            correctRes.forEach((e) => {
                if (e.correctOption === e.myAnswer) {
                    correctAns++;
                } else if (e.myAnswer !== "") {
                    wrongAnswers++;
                }
            });
            let myScore = 0;
            if (GetTest.negativemarking) {
                myScore =
                    correctAns * parseFloat(GetTest.eachQueMarks) -
                    wrongAnswers * parseFloat(GetTest.negativeMarks);
            } else {
                myScore = correctAns * parseFloat(GetTest.eachQueMarks);
            }
            let studentName = "";
            let email = "";
            // const user = usersArr.find((e) => e.userId === studentId);
            if (userLoop) {
              studentName = userLoop.FullName;
              email = userLoop.email;
              mobileNumber = userLoop.mobileNumber;
            }
            studentScores.push({
                studentId,
                studentName,
                email,
                myScore,
                totalMarks: (
                    parseFloat(GetTest.eachQueMarks) * correctRes.length
                ).toFixed(2),
                accuracy: ((correctAns / correctRes.length) * 100).toFixed(2),
                is_attempted: is_attempted,
            });
        }
        studentScores.sort((a, b) => {
            if (b.myScore === a.myScore) {
                return b.accuracy - a.accuracy;
            } else {
                return b.myScore - a.myScore;
            }
        });

        return { quizId, studentScores };
    }

}
// Quiz leaderBoard
AdminPanel.post("/leaderBoard/:quizId", isAdmin, async (req, res) => {
    try {
        const { quizId } = req.params;
        jwt.verify(req.token, process.env.ADMIN_SECRET_KEY, async (err, Data) => {
            if (err) {
                res.status(401).json({
                    status: false,
                    data: null,
                    msg: err,
                });
            } else {
                const adminDetails = await findAdminTeacherUsingUserId(Data.studentId);
                if (adminDetails) {
                    if (!quizId) {
                        return res.json({
                            status: false,
                            data: null,
                            msg: "quizId required",
                        });
                    }
                    const quiz = await QuizTable.findById(quizId);
                    const GetTest = await TestSeriesTestTable.findById(quizId);
                    if (quiz || GetTest) {
                        const ldrbrd = await leaderBoardTable.find({ quizId });
                        if (ldrbrd.length === 0) {
                            const usersScore = await getQuizResults(quizId);
                            if (usersScore) {
                                const saveLederBoard = new leaderBoardTable({
                                    quizId: usersScore.quizId,
                                    leaderBoard: usersScore.studentScores,
                                    publishedAt: new Date(
                                        moment().add(5, "hours").add(30, "minutes")
                                    ),
                                });
                                const data = await saveLederBoard.save();
                                if (!data) {
                                    return res.json({
                                        status: false,
                                        data: null,
                                        msg: "Error while saving LeaderBoard ",
                                    });
                                }
                                return res.json({
                                    status: true,
                                    data: {
                                        leaderBoardId: data._id,
                                        quizId: data.quizId,
                                        leaderBoard: data.leaderBoard,
                                        isActive: data.isActive,
                                        publishedAt: data.publishedAt,
                                    },
                                    msg: "LederBorad Published",
                                });
                            } else {
                                return res.json({
                                    status: false,
                                    data: null,
                                    msg: "Error while generating LeaderBoard ",
                                });
                            }
                        } else {
                            return res.json({
                                status: true,
                                data: {
                                    leaderBoardId: ldrbrd[0]._id,
                                    quizId: ldrbrd[0].quizId,
                                    leaderBoard: ldrbrd[0].leaderBoard,
                                    isActive: ldrbrd[0].isActive,
                                    publishedAt: ldrbrd[0].publishedAt,
                                },
                                msg: "LederBorad",
                            });
                        }
                    }
                } else {
                    return res.json({
                        status: false,
                        data: null,
                        msg: "Not an admin",
                    });
                }
            }
        });
    } catch (error) {
        return res.json({
            status: false,
            data: null,
            msg: error.message
        })
    }
});

//<--STUDENT ROUTES--> ///

// Quiz leaderBoard
AdminPanel.get("/getleaderBoard/:quizId", ValidateToken, async (req, res) => {
    const { quizId } = req.params;
    jwt.verify(req.token, process.env.SECRET_KEY, async (err, Data) => {
        if (err) {
            res.status(401).json({
                status: false,
                data: null,
                msg: err,
            });
        } else {
            const user = await findUserByUserId(Data.studentId);
            if (user) {
                if (!quizId) {
                    return res.json({
                        status: false,
                        data: null,
                        msg: "quizId required",
                    });
                }
                const quiz = await QuizTable.findById(quizId);
                // console.log(quiz);
                const GetTest = await TestSeriesTestTable.findById(quizId);
                if (quiz || GetTest) {
                    const ldrbrd = await leaderBoardTable.find({ quizId });
                    if (ldrbrd.length === 0) {
                        const usersScore = await getQuizResults(quizId);
                        if (usersScore) {
                            const saveLederBoard = new leaderBoardTable({
                                quizId: usersScore.quizId,
                                leaderBoard: usersScore.studentScores,
                                publishedAt: new Date(
                                    moment().add(5, "hours").add(30, "minutes")
                                ),
                            });
                            const data = await saveLederBoard.save();
                            if (!data) {
                                return res.json({
                                    status: false,
                                    data: null,
                                    msg: "Error while saving LeaderBoard ",
                                });
                            }
                            return res.json({
                                status: true,
                                data: {
                                    leaderBoardId: data._id,
                                    quizId: data.quizId,
                                    leaderBoard: data.leaderBoard.map((item) => {
                                        return {
                                            studentId: item.studentId,
                                            studentName: item.studentName,
                                            myScore: `${item.myScore}`,
                                            totalMarks: item.totalMarks,
                                            accuracy: item.accuracy,
                                            is_attempted: item.is_attempted
                                        }
                                    }),
                                    isActive: data.isActive,
                                    // publishedAt: data.publishedAt,
                                },
                                msg: "LederBorad",
                            });
                        } else {
                            return res.json({
                                status: false,
                                data: null,
                                msg: "Error while generating LeaderBoard ",
                            });
                        }
                    } else {
                        const usersScore = await getQuizResults(quizId);
                        if (usersScore) {
                            // let leaderBoard =  ldrbrd[0].leaderBoard ;
                            let leaderBoard = usersScore?.studentScores;
                            // leaderBoard.push(usersScore?.studentScores);
                            const data = await leaderBoardTable.findByIdAndUpdate(ldrbrd[0]?._id, { leaderBoard: leaderBoard }, { new: true, lean: true });
                            return res.json({
                                status: true,
                                data: {
                                    leaderBoardId: data._id,
                                    quizId: data.quizId,
                                    leaderBoard: data.leaderBoard.map((item) => {
                                        return {
                                            studentId: item.studentId,
                                            studentName: item.studentName,
                                            myScore: `${item.myScore}`,
                                            totalMarks: item.totalMarks,
                                            accuracy: item.accuracy,
                                            is_attempted: item.is_attempted
                                        }
                                    }),
                                    isActive: data.isActive,
                                    // publishedAt: ldrbrd[0].publishedAt,
                                },
                                msg: "LederBorad",
                            });
                        } else {
                            return res.json({
                                status: false,
                                data: null,
                                msg: "Error while generating LeaderBoard ",
                            });
                        }
                        // return res.json({
                        //     status: true,
                        //     data: {
                        //         leaderBoardId: ldrbrd[0]._id,
                        //         quizId: ldrbrd[0].quizId,
                        //         leaderBoard: ldrbrd[0].leaderBoard.map((item) => {
                        //             return {
                        //                 studentId: item.studentId,
                        //                 studentName: item.studentName,
                        //                 myScore: `${item.myScore}`,
                        //                 totalMarks: item.totalMarks,
                        //                 accuracy: item.accuracy
                        //             }
                        //         }),
                        //         isActive: ldrbrd[0].isActive,
                        //         // publishedAt: ldrbrd[0].publishedAt,
                        //     },
                        //     msg: "LederBorad",
                        // });
                    }
                }
            } else {
                return res.json({
                    status: false,
                    data: null,
                    msg: "Not an User",
                });
            }
        }
    });
});

//get all quizes
AdminPanel.get("/getAllQuizes", ValidateToken, async (req, res) => {
    try {
        jwt.verify(req.token, process.env.SECRET_KEY, async (err, Data) => {
            if (err) {
                res.status(401).json({
                    status: false,
                    data: null,
                    msg: err,
                });
            } else {
                let QuizDetails;
                const studentDetails = await findUserByUserId(Data.studentId);
                if (studentDetails) {
                    const attemptedQuizes = await QuizResponseTable.find({
                        user_id: studentDetails._id,
                    });
                    let checkArray = [];
                    for (let i = 0; i < attemptedQuizes.length; i++) {
                        checkArray.push(attemptedQuizes[i].quiz_id);
                    }
                    QuizDetails = await QuizTable.find(
                        {
                            _id: { $nin: checkArray },
                            is_active: true,
                            no_ques: {
                                $gt: "0",
                            },
                            link: 'none'
                        },
                        { user: 0, __v: 0 }
                    );
                    let resArr = [];
                    // console.log(QuizDetails);
                    for (let j = 0; j < QuizDetails.length; j++) {
                        // console.log(QuizDetails[j]?._id);

                        const questions = await QuizQuestionsTable.find({
                            quiz_id: QuizDetails[j]._id,
                        });
                        let Res = {
                            id: QuizDetails[j]._id,
                            quiz_title: QuizDetails[j].quiz_title,
                            quiz_desc: QuizDetails[j].quiz_desc,
                            quiz_duration: QuizDetails[j].quiz_duration,
                            no_ques: questions.length.toString(),
                            // quiz_banner: QuizDetails[j].quiz_banner[0],
                            quiz_banner: QuizDetails[j].quiz_banner[0] != "" ? QuizDetails[j].quiz_banner[0] : "https://static.sdcampus.com/Banner/Quiz_Banner/quizDefaultBanner_1732531006.png",
                            language: QuizDetails[j].language,
                            shareLink: "",
                            shareUrl: { link: QuizDetails[j]?.shareLink?.link ?? "", text: QuizDetails[j]?.shareLink?.text ?? "" },
                            is_negative: QuizDetails[j].is_negative,
                            negativeMarks: QuizDetails[j].negativeMarks,
                            eachQueMarks: QuizDetails[j].eachQueMarks,
                            quiz_created_at: QuizDetails[j].created_at,
                        };

                        resArr.push(Res);
                    }
                    let atmptArr = [];
                    QuizAteempted = await QuizTable.find(
                        { _id: { $in: checkArray }, link: 'none' },
                        { user: 0, __v: 0 }
                    );
                    for (let j = 0; j < QuizAteempted.length; j++) {
                        let Res = {
                            id: QuizAteempted[j]._id,
                            quiz_title: QuizAteempted[j].quiz_title,
                            quiz_desc: QuizAteempted[j].quiz_desc,
                            quiz_duration: QuizAteempted[j].quiz_duration,
                            no_ques: QuizAteempted[j].no_ques.toString(),
                            quiz_banner: QuizAteempted[j].quiz_banner[0] != "" ? QuizAteempted[j].quiz_banner[0] : "https://static.sdcampus.com/Banner/Quiz_Banner/quizDefaultBanner_1732531006.png",
                            language: QuizAteempted[j].language,
                            shareLink: "",
                            shareUrl: { link: QuizAteempted[j]?.shareLink?.link ?? "", text: QuizAteempted[j]?.shareLink?.text ?? "" },
                            is_negative: QuizAteempted[j].is_negative,
                            negativeMarks: QuizAteempted[j].negativeMarks,
                            eachQueMarks: QuizAteempted[j].eachQueMarks,
                            quiz_created_at: QuizAteempted[j].created_at,
                        };
                        atmptArr.push(Res);
                    }
                    if (QuizDetails) {
                        res.json({
                            status: true,
                            data: {
                                is_attempted: atmptArr,
                                not_attempted: resArr,
                            },
                            msg: "Quizes",
                        });
                    } else {
                        res.json({
                            status: false,
                            data: null,
                            msg: "Quizes Not Found",
                        });
                    }
                } else {
                    res.json({
                        status: false,
                        data: null,
                        msg: "Not authorized",
                    });
                }
            }
        });
    } catch (error) {
        return res.json({
            status: false,
            data: null,
            msg: error.message
        })
    }
});
//get questions by quiz id
AdminPanel.get(
    "/getQuestionsByQuizId/:quizId",
    ValidateToken,
    async (req, res) => {
        const { quizId } = req.params;
        jwt.verify(req.token, process.env.SECRET_KEY, async (err, Data) => {
            if (err) {
                res.status(401).json({
                    status: false,
                    data: null,
                    msg: err,
                });
            } else {
                const studentDetails = await findUserByUserId(Data.studentId);
                if (studentDetails) {
                    const GetQuiz = await QuizTable.find({ _id: quizId });
                    const GetTest = await TestSeriesTestTable.find({ _id: quizId });
                    const checkAtted = await QuizResponseTable.findOne({ quiz_id: GetQuiz[0]._id, user_id: studentDetails._id })
                    if (checkAtted) {
                        return res.json({
                            status: false,
                            data: null,
                            msg: "Quiz Already Attempted"
                        })
                    }
                    if (GetQuiz.length != 0 || GetTest.length != 0) {
                        const questions = await QuizQuestionsTable.find({
                            quiz_id: quizId,
                        }).populate('sectionId', 'title sectionId').then((data) =>
                            data.map((question) => {
                                return {
                                    _id: question._id,
                                    quiz_id: question.quiz_id,
                                    sectionId: question.sectionId ?? {
                                        _id: "",
                                        title: "",
                                        sectionId: ""
                                    },
                                    question_title: question.question_title[0],
                                    option1: question.option1[0],
                                    option2: question.option2[0],
                                    option3: question.option3[0],
                                    option4: question.option4[0],
                                };
                            })
                        );
                        if (questions.length > 0) {
                            res.json({
                                status: true,
                                data: questions,
                                msg: "Questions",
                            });
                        } else {
                            res.json({
                                status: false,
                                data: null,
                                msg: "Questions Not Found",
                            });
                        }
                    } else {
                        res.json({
                            status: false,
                            data: null,
                            msg: "Quiz Not Found",
                        });
                    }
                } else {
                    res.json({
                        status: false,
                        data: null,
                        msg: "Not authorized",
                    });
                }
            }
        });
    }
);
//attempt quiz
AdminPanel.post("/attemptQuiz/:quizId", ValidateToken, async (req, res) => {
    const { ans_res, timeSpent } = req.body;
    const { quizId } = req.params;
    jwt.verify(req.token, process.env.SECRET_KEY, async (err, Data) => {
        if (err) {
            res.status(401).json({
                status: false,
                data: null,
                msg: err,
            });
        } else {
            const date = new Date(moment().add(5, "hours").add(30, "minutes"));
            let formatedDate = formatDate(date);
            const studentDetails = await findUserByUserId(Data.studentId);
            if (studentDetails) {
                const quiz = await QuizTable.findById(quizId);
                const testTesseris = await TestSeriesTestTable.findById(quizId);
                if (quiz) {
                    const AttemtedQuizes = await QuizResponseTable.find({
                        quiz_id: quizId,
                        user_id: studentDetails._id,
                    });
                    // if (AttemtedQuizes.length == 0) {
                    const ansRes = new QuizResponseTable({
                        user_id: studentDetails._id,
                        quiz_id: quizId,
                        ans_res: ans_res,
                        timeSpent: timeSpent,
                        created_at: formatedDate,
                        is_active: quiz.is_manual ? false : true,
                    });
                    const attmtQuiz = await ansRes.save();
                    await QuizResumeTable.findOneAndDelete({ quizId: quiz._id });
                    let data;
                    if (studentDetails.language === "hi") {
                        data = {
                            title: quiz.quiz_title,
                            message: ` ${quiz.quiz_title}      `,
                            route: "attemptquiz",
                        };
                    } else {
                        data = {
                            title: quiz.quiz_title,
                            message: `You attempted ${quiz.quiz_title}  successfully`,
                            route: "attemptquiz",
                        };
                    }
                    const myNotifi = new myNotificationModel({
                        user: studentDetails._id,
                        title: data.title,
                        message: data.message,
                        route: data.route,
                    });
                    await myNotifi.save();
                    await sendPushNotification(studentDetails.fcmToken, data);
                    res.json({
                        status: true,
                        data: {
                            id: attmtQuiz._id,
                            quizId: attmtQuiz.quiz_id,
                            attemptedAt: attmtQuiz.created_at,
                            attemptedtype: attmtQuiz.attemptedtype,
                            timeSpent: attmtQuiz.timeSpent,
                            isResultPublished: attmtQuiz.is_active,
                        },
                        msg: "Quiz Attempted",
                    });
                    // } else {
                    //   res.json({
                    //     status: false,
                    //     data: null,
                    //     msg: "Quiz already Attempted",
                    //   });
                    // }
                } else if (testTesseris) {
                    const AttemtedQuizes = await QuizResponseTable.find({
                        quiz_id: quizId,
                        user_id: studentDetails._id,
                    });
                    // if (AttemtedQuizes.length == 0) {

                    const ansRes = new QuizResponseTable({
                        user_id: studentDetails._id,
                        quiz_id: quizId,
                        ans_res: ans_res,
                        timeSpent: timeSpent,
                        created_at: formatedDate,
                        is_active: testTesseris.is_manual ? false : true,
                    });
                    const RespionseSaved = await ansRes.save();
                    await QuizResumeTable.findOneAndDelete({ quizId: testTesseris._id });
                    let data;
                    if (studentDetails.language === "hi") {
                        data = {
                            title: testTesseris.Test_title,
                            message: ` ${testTesseris.Test_title}      `,
                            route: "attemptquiz",
                        };
                    } else {
                        data = {
                            title: testTesseris.Test_title,
                            message: `You attempted ${testTesseris.Test_title}  successfully`,
                            route: "attemptquiz",
                        };
                    }
                    const myNotifi = new myNotificationModel({
                        user: studentDetails._id,
                        title: data.title,
                        message: data.message,
                        route: data.route,
                    });
                    await myNotifi.save();
                    await sendPushNotification(studentDetails.fcmToken, data);
                    res.json({
                        status: true,
                        data: {
                            id: RespionseSaved._id,
                            quizId: RespionseSaved.quiz_id,
                            attemptedAt: RespionseSaved.created_at,
                            attemptedtype: RespionseSaved.attemptedtype,
                            timeSpent: RespionseSaved.timeSpent,
                            isResultPublished: RespionseSaved.is_active,
                        },
                        msg: `${testTesseris.Test_title} Attempted `,
                    });
                    // } else {
                    //   res.json({
                    //     status: true,
                    //     data: null,
                    //     msg: `${testTesseris.Test_title} already Attempted`,
                    //   });
                    // }
                } else {
                    res.json({
                        status: false,
                        data: null,
                        msg: "Invalid Request",
                    });
                }
            } else {
                res.json({
                    status: false,
                    data: null,
                    msg: "User not found",
                });
            }
        }
    });
});

AdminPanel.post("/resumeQuiz", ValidateToken, async (req, res) => {
    const { ans_res, quizId, timeSpent } = req.body;
    jwt.verify(req.token, process.env.SECRET_KEY, async (err, Data) => {
        if (err) {
            res.status(401).json({
                status: false,
                data: null,
                msg: err,
            });
        } else {
            console.log(ans_res, quizId, timeSpent);
            if (!ans_res && !quizId && !timeSpent) {
                return res.json({
                    status: false,
                    data: null,
                    msg: "All fields are required",
                });
            }
            const date = new Date(moment().add(5, "hours").add(30, "minutes"));
            let formatedDate = formatDate(date);
            const user = await findUserByUserId(Data.studentId);
            if (user) {
                const isResumed = await QuizResumeTable.find({ quizId });
                if (isResumed) {
                    await QuizResumeTable.findByIdAndUpdate(isResumed._id, {
                        userId: user._id,
                        quizId,
                        ans_res,
                        timeSpent,
                        createdAt: formatedDate,
                    });
                    return res.json({
                        status: true,
                        data: null,
                        msg: "Resumed Updated",
                    });
                }
                const savedRes = new QuizResumeTable({
                    userId: user._id,
                    quizId,
                    ans_res,
                    timeSpent,
                    createdAt: formatedDate,
                });
                await savedRes.save();
                return res.json({
                    status: true,
                    data: null,
                    msg: "Resumed",
                });
            }
        }
    });
});

AdminPanel.get("/getResumeQuiz/:quizId", ValidateToken, async (req, res) => {
    const { quizId } = req.params;
    jwt.verify(req.token, process.env.SECRET_KEY, async (err, Data) => {
        if (err) {
            res.status(401).json({
                status: false,
                data: null,
                msg: err,
            });
        } else {
            const user = await findUserByUserId(Data.studentId);
            if (user) {
                const quiz = await QuizTable.findById(quizId);
                const test = await TestSeriesTestTable.findById(quizId);
                if (quiz) {
                    const resumedQuiz = await QuizResumeTable.find({ quizId });
                    return res.json({
                        status: true,
                        data: resumedQuiz?.map((item) => {
                            return {
                                id: item._id,
                                quizId: item.quizId,
                                userId: item.userId,
                                ans_res: item.ans_res,
                                totaltime: quiz.quiz_duration,
                                timeSpent: item.timeSpent,
                            };
                        }),
                        msg: "Resumed Quizes",
                    });
                } else if (test) {
                    const resumedQuiz = await QuizResumeTable.find({ quizId });
                    return res.json({
                        status: true,
                        data: resumedQuiz?.map((item) => {
                            return {
                                id: item._id,
                                quizId: item.quizId,
                                userId: item.userId,
                                ans_res: item.ans_res,
                                totaltime: test.duration,
                                timeSpent: item.timeSpent,
                            };
                        }),
                        msg: "Resumed Tests",
                    });
                } else {
                    return res.json({
                        status: false,
                        data: null,
                        msg: "Invalid Request",
                    });
                }
            } else {
                return res.json({
                    status: false,
                    data: null,
                    msg: "Invalid User",
                });
            }
        }
    });
});

//get quiz result
AdminPanel.get("/getQuizResult", ValidateToken, async (req, res) => {
    const { quizId, attemptId } = req.query;
    jwt.verify(req.token, process.env.SECRET_KEY, async (err, Data) => {
        if (err) {
            res.status(401).json({
                status: false,
                data: null,
                msg: err,
            });
        } else {
            const studentDetails = await findUserByUserId(Data.studentId);
            if (studentDetails) {
                const quiz = await QuizTable.findById(quizId);
                const GetTest = await TestSeriesTestTable.findById(quizId);
                // console.log("Quiz", GetTest)
                if (quiz) {
                    let quizResFilter = {};
                    if (attemptId) {
                        quizResFilter = {
                            _id: attemptId,
                            quiz_id: quizId,
                            user_id: studentDetails._id,
                        };
                    } else {
                        quizResFilter = {
                            quiz_id: quizId,
                            user_id: studentDetails._id,
                        };
                    }
                    let studentRes = [];
                    let currectRes = [];
                    const quizResponse = await QuizResponseTable.findOne(quizResFilter)
                    .sort({ createdAt: -1 });
                    const topperScore = await getTopperScore(quizId);
                    if (quizResponse?.is_active) {
                        studentRes.push(quizResponse.ans_res);
                        const quizQuestions = await QuizQuestionsTable.find({
                            quiz_id: quizId,
                        });
                        quizQuestions.forEach((e) => {
                            currectRes.push({
                                ans_id: e._id,
                                question_title: e.question_title[0],
                                que_level: e.que_level[0],
                                option1: e.option1[0],
                                option2: e.option2[0],
                                option3: e.option3[0],
                                option4: e.option4[0],
                                answer: e.answer[0],
                                correctOption: e.correctOption,
                            });
                        });
                        studentRes = studentRes?.[0];
                        for (let i = 0; i < quizQuestions.length; i++) {
                            if(studentRes.length > 1) {
                              if (quizResponse?.ans_res && quizResponse?.ans_res[0]) {
                                currectRes[i]["myAnswer"] = Object.values(
                                  quizResponse.ans_res[i]
                                )[0] ?? "";
                              } else {
                                currectRes[i]["myAnswer"] = "";
                              }
                            } else {
                              currectRes[i]["myAnswer"] = Object.values(
                                quizResponse?.ans_res[0]
                              )[i] ?? "";
                            }
                            
                        }
                        let correctAns = 0;
                        let skipped = 0;
                        let wrongAnswers = 0;
                        let easy = 0;
                        let medium = 0;
                        for (let i = 0; i < currectRes.length; i++) {
                            if (currectRes[i].myAnswer == "") skipped++;
                            if (currectRes[i].correctOption === currectRes[i].myAnswer)
                                correctAns++;
                            else if (
                                currectRes[i].correctOption !== currectRes[i].myAnswer &&
                                currectRes[i].myAnswer !== ""
                            )
                                wrongAnswers++;
                            if (currectRes[i]?.que_level?.e === "easy") easy++;
                            else if (currectRes[i]?.que_level?.e === "medium") medium++;
                        }

                        let myScore = 0;
                        if (quiz.is_negative) {
                            myScore =
                                correctAns * parseFloat(quiz.eachQueMarks) -
                                wrongAnswers * parseFloat(quiz.negativeMarks);
                        } else {
                            myScore = correctAns * parseFloat(quiz.eachQueMarks);
                        }
                        const topperSc =
                            typeof topperScore === "number" ? topperScore : 0.0;
                        const topperPer =
                            (topperSc / (quiz.eachQueMarks * currectRes.length)) * 100;
                        const myScorePer =
                            (myScore / (quiz.eachQueMarks * currectRes.length)) * 100;
                        res.json({
                            status: true,
                            data: {
                                quizId: quizId,
                                is_published: true,
                                totalMarks: (
                                    parseFloat(quiz.eachQueMarks) * currectRes.length
                                ).toFixed(2),
                                is_negative: quiz.is_negative,
                                negativeMarks:
                                    quiz.negativeMarks !== ""
                                        ? parseFloat(quiz.negativeMarks).toFixed(2)
                                        : "0.00",
                                myScore: {
                                    percentage: (myScorePer / 100).toFixed(2),
                                    number: myScore.toFixed(2),
                                },
                                accuracy: {
                                    percentage: (correctAns / currectRes.length).toFixed(2), // range b/w 0-1
                                    number: ((correctAns / currectRes.length) * 100).toFixed(2), // range 0-100
                                },
                                toperScore: {
                                    percentage: topperPer ? (topperPer / 100).toFixed(2) : "0.00",
                                    number: topperSc ? topperSc.toFixed(2) : "0.00",
                                },
                                summary: {
                                    noOfQues: currectRes.length,
                                    Attempted: currectRes.length - skipped,
                                    skipped,
                                    correctAns,
                                    wrongAnswers,
                                },
                                difficulty: {
                                    easy: {
                                        percentage: (easy / currectRes.length).toFixed(2),
                                        number: easy.toFixed(2),
                                    },
                                    medium: {
                                        percentage: (medium / currectRes.length).toFixed(2),
                                        number: medium.toFixed(2),
                                    },
                                    hard: {
                                        percentage: (
                                            (currectRes.length - (easy + medium)) /
                                            currectRes.length
                                        ).toFixed(2),
                                        number: (currectRes.length - (easy + medium)).toFixed(2),
                                    },
                                },
                                response: currectRes,
                            },
                            msg: "Quiz result",
                        });
                    } else {
                        // quizResponse.forEach((r) => {
                        //     studentRes.push(r.ans_res);
                        // });
                        if (Array.isArray(quizResponse)) {
                            quizResponse.forEach((r) => {
                                studentRes.push(r.ans_res);
                            });
                        }
                        const quizQuestions = await QuizQuestionsTable.find({
                            quiz_id: quizId,
                        });
                        quizQuestions.forEach((e) => {
                            currectRes.push({
                                ans_id: e._id,
                                question_title: e.question_title[0],
                                que_level: e.que_level[0],
                                option1: e.option1[0],
                                option2: e.option2[0],
                                option3: e.option3[0],
                                option4: e.option4[0],
                                answer: e.answer[0],
                                correctOption: e.correctOption,
                            });
                        });
                        studentRes = studentRes?.[0];
                        for (let i = 0; i < quizQuestions.length; i++) {
                            currectRes[i]["myAnswer"] = Object.values(
                                quizResponse[0]?.ans_res[0]
                            )[i];
                        }
                        let correctAns = 0;
                        let skipped = 0;
                        let wrongAnswers = 0;
                        let easy = 0;
                        let medium = 0;
                        for (let i = 0; i < currectRes.length; i++) {
                            if (currectRes[i].myAnswer == "") skipped++;
                            if (currectRes[i].correctOption === currectRes[i].myAnswer)
                                correctAns++;
                            else if (
                                currectRes[i].correctOption !== currectRes[i].myAnswer &&
                                currectRes[i].myAnswer !== ""
                            )
                                wrongAnswers++;
                            if (currectRes[i]?.que_level?.e === "easy") easy++;
                            else if (currectRes[i]?.que_level?.e === "medium") medium++;
                        }
                        let myScore = 0;
                        if (quiz.is_negative) {
                            myScore =
                                correctAns * parseFloat(quiz.eachQueMarks) -
                                wrongAnswers * parseFloat(quiz.negativeMarks);
                        } else {
                            myScore = correctAns * parseFloat(quiz.eachQueMarks);
                        }
                        const topperSc =
                            typeof topperScore === "number" ? topperScore : 0.0;
                        const topperPer =
                            (topperSc / (quiz.eachQueMarks * currectRes.length)) * 100;
                        const myScorePer =
                            (myScore / (quiz.eachQueMarks * currectRes.length)) * 100;
                        res.json({
                            status: true,
                            data: {
                                is_published: false,
                                quizId: quizId,
                                totalMarks: (
                                    parseFloat(quiz.eachQueMarks) * currectRes.length
                                ).toFixed(2),
                                is_negative: quiz.is_negative,
                                negativeMarks:
                                    quiz.negativeMarks !== ""
                                        ? parseFloat(quiz.negativeMarks).toFixed(2)
                                        : "0.00",
                                myScore: {
                                    percentage: (myScorePer / 100).toFixed(2),
                                    number: myScore.toFixed(2),
                                },
                                accuracy: {
                                    percentage: (correctAns / currectRes.length).toFixed(2), // range b/w 0-1
                                    number: ((correctAns / currectRes.length) * 100).toFixed(2), // range 0-100
                                },
                                toperScore: {
                                    percentage: topperPer ? (topperPer / 100).toFixed(2) : "0.00",
                                    number: topperSc ? topperSc.toFixed(2) : "0.00",
                                },
                                summary: {
                                    noOfQues: currectRes.length,
                                    Attempted: currectRes.length - skipped,
                                    skipped,
                                    correctAns,
                                    wrongAnswers,
                                },
                                difficulty: {
                                    easy: {
                                        percentage: (easy / currectRes.length).toFixed(2),
                                        number: easy.toFixed(2),
                                    },
                                    medium: {
                                        percentage: (medium / currectRes.length).toFixed(2),
                                        number: medium.toFixed(2),
                                    },
                                    hard: {
                                        percentage: (
                                            (currectRes.length - (easy + medium)) /
                                            currectRes.length
                                        ).toFixed(2),
                                        number: (currectRes.length - (easy + medium)).toFixed(2),
                                    },
                                },
                                response: currectRes,
                            },
                            msg: "Quiz Result Not Published !",
                        });
                    }
                } else if (GetTest) {
                    let quizResFilter = {};
                    if (attemptId) {
                        quizResFilter = {
                            _id: attemptId,
                            quiz_id: quizId,
                            user_id: studentDetails._id,
                        };
                    } else {
                        quizResFilter = {
                            quiz_id: quizId,
                            user_id: studentDetails._id,
                        };
                    }
                    let studentRes = [];
                    let currectRes = [];
                    const quizResponse = await QuizResponseTable.find(quizResFilter);
                    const topperScore = await getTopperScore(quizId);
                    if (quizResponse[0]?.is_active) {
                        quizResponse.forEach((r) => {
                            studentRes.push(r.ans_res);
                        });
                        const quizQuestions = await QuizQuestionsTable.find({
                            quiz_id: quizId,
                        });
                        quizQuestions.forEach((e) => {
                            currectRes.push({
                                ans_id: e._id,
                                question_title: e.question_title[0],
                                que_level: e.que_level[0],
                                option1: e.option1[0],
                                option2: e.option2[0],
                                option3: e.option3[0],
                                option4: e.option4[0],
                                answer: e.answer[0],
                                correctOption: e.correctOption,
                            });
                        });
                        studentRes = studentRes?.[0];
                        for (let i = 0; i < quizQuestions.length; i++) {
                            currectRes[i]["myAnswer"] = Object.values(
                                quizResponse[0].ans_res[0]
                            )[i];
                        }
                        let correctAns = 0;
                        let skipped = 0;
                        let wrongAnswers = 0;
                        let easy = 0;
                        let medium = 0;
                        for (let i = 0; i < currectRes.length; i++) {
                            if (currectRes[i].myAnswer == "") skipped++;
                            if (currectRes[i].correctOption === currectRes[i].myAnswer)
                                correctAns++;
                            else if (
                                currectRes[i].correctOption !== currectRes[i].myAnswer &&
                                currectRes[i].myAnswer !== ""
                            )
                                wrongAnswers++;
                            if (currectRes[i]?.que_level?.e === "easy") easy++;
                            else if (currectRes[i]?.que_level?.e === "medium") medium++;
                        }

                        let myScore = 0;
                        if (GetTest.negativemarking) {
                            myScore =
                                correctAns * parseFloat(GetTest.eachQueMarks) -
                                wrongAnswers * parseFloat(GetTest.negativeMarks);
                        } else {
                            myScore = correctAns * parseFloat(GetTest.eachQueMarks);
                        }
                        const topperSc =
                            typeof topperScore === "number" ? topperScore : 0.0;
                        const topperPer =
                            (topperSc / (GetTest.eachQueMarks * currectRes.length)) * 100;
                        const myScorePer =
                            (myScore / (GetTest.eachQueMarks * currectRes.length)) * 100;
                        res.json({
                            status: true,
                            data: {
                                quizId: quizId,
                                is_published: true,
                                totalMarks: (
                                    parseFloat(GetTest.eachQueMarks) * currectRes.length
                                ).toFixed(2),
                                is_negative: GetTest.negativemarking,
                                negativeMarks:
                                    GetTest.negativeMarks !== ""
                                        ? parseFloat(GetTest.negativeMarks).toFixed(2)
                                        : "0.00",
                                myScore: {
                                    percentage: (myScorePer / 100).toFixed(2),
                                    number: myScore.toFixed(2),
                                },
                                accuracy: {
                                    percentage: (correctAns / currectRes.length).toFixed(2), // range b/w 0-1
                                    number: ((correctAns / currectRes.length) * 100).toFixed(2), // range 0-100
                                },
                                toperScore: {
                                    percentage: topperPer ? (topperPer / 100).toFixed(2) : "0.00",
                                    number: topperSc ? topperSc.toFixed(2) : "0.00",
                                },
                                summary: {
                                    noOfQues: currectRes.length,
                                    Attempted: currectRes.length - skipped,
                                    skipped,
                                    correctAns,
                                    wrongAnswers,
                                },
                                difficulty: {
                                    easy: {
                                        percentage: (easy / currectRes.length).toFixed(2),
                                        number: easy.toFixed(2),
                                    },
                                    medium: {
                                        percentage: (medium / currectRes.length).toFixed(2),
                                        number: medium.toFixed(2),
                                    },
                                    hard: {
                                        percentage: (
                                            (currectRes.length - (easy + medium)) /
                                            currectRes.length
                                        ).toFixed(2),
                                        number: (currectRes.length - (easy + medium)).toFixed(2),
                                    },
                                },
                                response: currectRes,
                            },
                            msg: "Quiz result",
                        });
                    } else {
                        quizResponse.forEach((r) => {
                            studentRes.push(r.ans_res);
                        });
                        const quizQuestions = await QuizQuestionsTable.find({
                            quiz_id: quizId,
                        });
                        quizQuestions.forEach((e) => {
                            currectRes.push({
                                ans_id: e._id,
                                question_title: e.question_title[0],
                                que_level: e.que_level[0],
                                option1: e.option1[0],
                                option2: e.option2[0],
                                option3: e.option3[0],
                                option4: e.option4[0],
                                answer: e.answer[0],
                                correctOption: e.correctOption,
                            });
                        });
                        studentRes = studentRes?.[0];
                        for (let i = 0; i < quizQuestions.length; i++) {
                            currectRes[i]["myAnswer"] = Object.values(
                                quizResponse[0]?.ans_res[0]
                            )[i];
                        }
                        let correctAns = 0;
                        let skipped = 0;
                        let wrongAnswers = 0;
                        let easy = 0;
                        let medium = 0;
                        for (let i = 0; i < currectRes.length; i++) {
                            if (currectRes[i].myAnswer == "") skipped++;
                            if (currectRes[i].correctOption === currectRes[i].myAnswer)
                                correctAns++;
                            else if (
                                currectRes[i].correctOption !== currectRes[i].myAnswer &&
                                currectRes[i].myAnswer !== ""
                            )
                                wrongAnswers++;
                            if (currectRes[i]?.que_level?.e === "easy") easy++;
                            else if (currectRes[i]?.que_level?.e === "medium") medium++;
                        }
                        let myScore = 0;
                        if (GetTest.negativemarking) {
                            myScore =
                                correctAns * parseFloat(GetTest.eachQueMarks) -
                                wrongAnswers * parseFloat(GetTest.negativeMarks);
                        } else {
                            myScore = correctAns * parseFloat(GetTest.eachQueMarks);
                        }
                        const topperSc =
                            typeof topperScore === "number" ? topperScore : 0.0;
                        const topperPer =
                            (topperSc / (GetTest.eachQueMarks * currectRes.length)) * 100;
                        const myScorePer =
                            (myScore / (GetTest.eachQueMarks * currectRes.length)) * 100;
                        res.json({
                            status: true,
                            data: {
                                is_published: false,
                                quizId: quizId,
                                totalMarks: (
                                    parseFloat(GetTest.eachQueMarks) * currectRes.length
                                ).toFixed(2),
                                is_negative: GetTest.negativemarking,
                                negativeMarks:
                                    GetTest.negativeMarks !== ""
                                        ? parseFloat(GetTest.negativeMarks).toFixed(2)
                                        : "0.00",
                                myScore: {
                                    percentage: (myScorePer / 100).toFixed(2),
                                    number: myScore.toFixed(2),
                                },
                                accuracy: {
                                    percentage: (correctAns / currectRes.length).toFixed(2), // range b/w 0-1
                                    number: ((correctAns / currectRes.length) * 100).toFixed(2), // range 0-100
                                },
                                toperScore: {
                                    percentage: topperPer ? (topperPer / 100).toFixed(2) : "0.00",
                                    number: topperSc ? topperSc.toFixed(2) : "0.00",
                                },
                                summary: {
                                    noOfQues: currectRes.length,
                                    Attempted: currectRes.length - skipped,
                                    skipped,
                                    correctAns,
                                    wrongAnswers,
                                },
                                difficulty: {
                                    easy: {
                                        percentage: (easy / currectRes.length).toFixed(2),
                                        number: easy.toFixed(2),
                                    },
                                    medium: {
                                        percentage: (medium / currectRes.length).toFixed(2),
                                        number: medium.toFixed(2),
                                    },
                                    hard: {
                                        percentage: (
                                            (currectRes.length - (easy + medium)) /
                                            currectRes.length
                                        ).toFixed(2),
                                        number: (currectRes.length - (easy + medium)).toFixed(2),
                                    },
                                },
                                response: currectRes,
                            },
                            msg: "Quiz Result Not Published !",
                        });
                    }
                } else {
                    res.json({
                        status: false,
                        data: null,
                        msg: "No Data Found",
                    });
                }
            } else {
                res.json({
                    status: false,
                    data: null,
                    msg: "Not authorized",
                });
            }
        }
    });
});

AdminPanel.post("/postIssueReport/:quizId", ValidateToken, async (req, res) => {
    const { que_title, desc } = req.body;
    if (!que_title || !desc) {
        return res.json({
            status: false,
            data: null,
            msg: "Please fill all the fields",
        });
    }

    const { quizId } = req.params; //backend
    jwt.verify(req.token, process.env.SECRET_KEY, async (err, Data) => {
        if (err) {
            res.status(401).json({
                status: false,
                data: null,
                msg: err,
            });
        } else {
            const date = new Date(moment().add(5, "hours").add(30, "minutes"));
            let formatedDate = formatDate(date);
            const studentDetails = await findUserByUserId(Data.studentId);
            if (studentDetails) {
                const issue = new issueReport({
                    user: studentDetails._id,
                    quiz_id: quizId,
                    que_title: que_title,
                    issue_desc: desc,
                    created_at: formatedDate,
                });

                const issueReportSaved = await issue.save();
                res.json({
                    status: true,
                    data: issueReportSaved,
                    msg: "Issue Reported Successfully",
                });
            } else {
                res.json({
                    status: false,
                    data: null,
                    msg: "User not found",
                });
            }
        }
    });
});

AdminPanel.get("/getIssueReport/:quizId", isAdmin, async (req, res) => {
    const { quizId } = req.params; //backend
    jwt.verify(req.token, process.env.ADMIN_SECRET_KEY, async (err, Data) => {
        if (err) {
            res.status(401).json({
                status: false,
                data: null,
                msg: err,
            });
        } else {
            const issueReports = await issueReport.find({ quiz_id: quizId });
            if (issueReports.length != 0) {
                res.json({
                    status: true,
                    data: issueReports,
                    msg: "Issue Reports Fetched Successfully",
                });
            } else {
                res.json({
                    status: false,
                    data: null,
                    msg: "Issue Reports Not Found",
                });
            }
        }
    });
});

AdminPanel.post("/postDoubts/:quizId", ValidateToken, async (req, res) => {
    const { que_title, desc } = req.body;
    const { quizId } = req.params; //backend
    if (!que_title || !desc) {
        return res.json({
            status: false,
            data: null,
            msg: "Please fill all the fields",
        });
    }
    jwt.verify(req.token, process.env.SECRET_KEY, async (err, Data) => {
        if (err) {
            res.status(401).json({
                status: false,
                data: null,
                msg: err,
            });
        } else {
            const date = new Date(moment().add(5, "hours").add(30, "minutes"));
            let formatedDate = formatDate(date);
            const studentDetails = await findUserByUserId(Data.studentId);
            if (studentDetails) {
                const doubt = new DoubtTable({
                    user: studentDetails._id,
                    quiz_id: quizId,
                    que_title: que_title,
                    doubt_desc: desc,
                    created_at: formatedDate,
                });
                const doubtSaved = await doubt.save();
                res.json({
                    status: true,
                    data: doubtSaved,
                    msg: "Doubt Posted Successfully",
                });
            } else {
                res.json({
                    status: false,
                    data: null,
                    msg: "User not found",
                });
            }
        }
    });
});

AdminPanel.get("/getDoubts/:quizId", isAdmin, async (req, res) => {
    const { quizId } = req.params; //backend
    jwt.verify(req.token, process.env.ADMIN_SECRET_KEY, async (err, Data) => {
        if (err) {
            res.status(401).json({
                status: false,
                data: null,
                msg: err,
            });
        } else {
            const doubts = await DoubtTable.find({ quiz_id: quizId });
            if (doubts.length != 0) {
                res.json({
                    status: true,
                    data: doubts,
                    msg: "Doubts Fetched Successfully",
                });
            } else {
                res.json({
                    status: false,
                    data: null,
                    msg: "Doubts Not Found",
                });
            }
        }
    });
});

AdminPanel.get("/getAttemptedQuizsByUserId", isAdmin, async (req, res) => {
    const { id } = req.query;
    if (!id) {
        return res.json({
            status: false,
            data: null,
            msg: 'Required id!'
        })
    }
    try {
        // const 
        const decoded = jwt.verify(req.token, process.env.ADMIN_SECRET_KEY);
        const adminDetails = await findAdminTeacherUsingUserId(decoded.studentId);
        if (!adminDetails) {
            return res.status(401).json({
                status: false,
                data: null,
                msg: "Not an admin",
            });
        }
        const user = await UserTable.findOne({ _id: id });
        if (!user) {
            return res.json({
                status: false,
                data: null,
                msg: `user not found`
            })
        }
        const list = await leaderBoardTable.find({ 'leaderBoard.studentId': id }).populate("quizId", "quiz_title");
        return res.json({
            status: true,
            data: list?.map((item, index) => {
                let leaderBoard = item?.leaderBoard?.find((user) => user.studentId == id)
                return {
                    sno: index + 1,
                    quizName: item?.quizId?.quiz_title ?? "",
                    score: leaderBoard?.myScore,
                    attempted: moment(item.createdAt).format("DD-MM-YYYY HH:mm:ss"),
                    // user:leaderBoard?.email
                }
                // msg : "Quizs attempted detail fetched"
            }),
            msg: `Attempted Quiz`
        })

    } catch (error) {
        return res.json({
            status: false,
            data: null,
            msg: error.message
        })
    }
})

//get all the data in the banner Table
AdminPanel.get("/getbannerdetails", async (req, res) => {
    const { BannerType, categoryName } = req.query;
    if (BannerType == "APP") {
        // let category ;
        let query = {
            BannerType: "APP",
            is_active: true
        }
        if (![undefined, '']?.includes(categoryName)) {
            let category = await categoryTable.findOne({ title: categoryName })
            query = {
                BannerType: "APP",
                link: 'category',
                linkWith: category?._id,
                is_active: true
            }
        }
        // console.log(query);
        let BannerDetail = await BannerTable.find(
            // { BannerType: "APP", is_active: true },
            { ...query },
            { language: 0, user: 0, __v: 0, category: 0, BannerType: 0 }
        ).sort({ createdAt: -1 }).limit(10);
        if (BannerDetail?.length == 0) {
            BannerDetail = await BannerTable.find(
                { BannerType: "APP", is_active: true },
                { language: 0, user: 0, __v: 0, category: 0, BannerType: 0 }
            ).sort({ createdAt: -1 }).limit(10)
        }
        if (BannerDetail) {

            res.json({
                status: true,
                data: BannerDetail?.map((item) => {
                    return {
                        _id: item?._id ?? "",
                        title: item?.title ?? "",
                        link: item?.link ?? "",
                        linkWith: { id: item?.linkWith ?? "", name: "" },
                        created_at: item?.created_at ?? "",
                        is_active: item?.is_active,
                        banner_url: item?.banner_url,
                    }
                }),
                msg: "Banner Details Fetched successfully ",
            });

        } else {
            res.json({
                status: false,
                data: null,
                msg: "No data found the Banner table",
            });
        }
    } else if (BannerType == "WEB") {
        const BannerDetail = await BannerTable.find(
            { BannerType: "WEB", is_active: true },
            { language: 0, user: 0, __v: 0, category: 0, BannerType: 0 }
        ).sort({ createdAt: -1 }).limit(10);
        // let responseData = [];
        if (BannerDetail) {
            let responseData = await Promise.all(BannerDetail.map(async (data) => {
                let link = "";
                let linkWith = { id: "", name: "" }
                if (data.link === 'batch') {
                    const batchDetails = await BatchesTable.findById(data?.linkWith);
                    if (!batchDetails) {
                        link = "none"
                        linkWith = { id: "NA", name: "NA" }
                    }
                    link = data?.link
                    linkWith = { id: batchDetails?._id ?? "", name: batchDetails?.batch_name ?? "" }
                } else if (data.link === 'testSeries') {
                    const testSeriesDetails = await TestSeriesTable.findById(data?.linkWith);
                    if (!testSeriesDetails) {
                        link = "none"
                        linkWith = { id: "NA", name: "NA" }
                    }
                    link = data?.link
                    linkWith = { id: testSeriesDetails?._id ?? "", name: testSeriesDetails?.testseries_name ?? "" }
                } else if (data.link === 'category') {
                    const category = await categoryTable.findOne({ _id: data.linkWith })
                    if (!category) {
                        link = "none"
                        linkWith = { id: "NA", name: "NA" }
                    }
                    link = data?.link
                    linkWith = { id: category?._id ?? "", name: category?.title ?? "", tags: category?.tags ?? "" }
                }
                else if (data.link === 'link') {
                    link = data?.link
                    linkWith = { id: data?.linkWith ?? "", name: data?.linkWith ?? "" }

                }
                else if (data?.link == 'scholarship') {
                    const scholarship = await scholarshipTestTable.findOne({ _id: data?.linkWith });
                    if (!scholarship) {
                        link = "none"
                        linkWith = { id: "NA", name: "NA" }
                    }
                    link = data?.link
                    linkWith = { id: scholarship?._id, name: scholarship?.title }
                }
                else {
                    link = "none"
                    linkWith = { id: "NA", name: "NA" }
                }
                return {
                    _id: data?._id,
                    title: data?.title,
                    created_at: data?.created_at,
                    link,
                    linkWith,
                    is_active: data?.is_active,
                    banner_url: data?.banner_url,
                    BannerType: data?.BannerType,
                }
            }));
            if (responseData) {
                res.json({
                    status: true,
                    data: responseData,
                    msg: "Banner Details Fetched successfully ",
                });
            }
        }
        else {
            res.json({
                status: false,
                data: null,
                msg: "No data found the Banner table",
            });
        }
    } else if (BannerType == "TAB") {
        const BannerDetail = await BannerTable.find(
            { BannerType: "TAB", is_active: true },
            { language: 0, user: 0, __v: 0, category: 0, BannerType: 0 }
        ).sort({ createdAt: -1 }).limit(10);
        if (BannerDetail) {
            let responseData = await Promise.all(BannerDetail.map(async (data) => {
                let link = "";
                let linkWith = { id: "", name: "" }
                if (data.link === 'batch') {
                    const batchDetails = await BatchesTable.findById(data?.linkWith);
                    if (!batchDetails) {
                        link = "none"
                        linkWith = { id: "NA", name: "NA" }
                    }
                    link = data?.link
                    linkWith = { id: batchDetails?._id ?? "", name: batchDetails?.batch_name ?? "" }
                } else if (data.link === 'testSeries') {
                    const testSeriesDetails = await TestSeriesTable.findById(data?.linkWith);
                    if (!testSeriesDetails) {
                        link = "none"
                        linkWith = { id: "NA", name: "NA" }
                    }
                    link = data?.link
                    linkWith = { id: testSeriesDetails?._id ?? "", name: testSeriesDetails?.testseries_name ?? "" }
                } else if (data.link === 'category') {
                    const category = await categoryTable.findOne({ _id: data.linkWith })
                    if (!category) {
                        link = "none"
                        linkWith = { id: "NA", name: "NA" }
                    }
                    link = data?.link
                    linkWith = { id: category?._id ?? "", name: category?.title ?? "", tags: category?.tags ?? [] }
                }
                else if (data.link === 'link') {
                    link = data?.link
                    linkWith = { id: data?.linkWith ?? "", name: data?.linkWith ?? "" }

                }
                else if (data?.link == 'scholarship') {
                    const scholarship = await scholarshipTestTable.findOne({ _id: data?.linkWith });
                    if (!scholarship) {
                        link = "none"
                        linkWith = { id: "NA", name: "NA" }
                    }
                    link = data?.link
                    linkWith = { id: scholarship?._id, name: scholarship?.title }
                }
                else {
                    link = "none"
                    linkWith = { id: "NA", name: "NA" }
                }
                return {
                    _id: data?._id,
                    title: data?.title,
                    created_at: data?.created_at,
                    link,
                    linkWith,
                    is_active: data?.is_active,
                    banner_url: data?.banner_url,
                    BannerType: data?.BannerType,
                }
            }));
            if (responseData) {
                res.json({
                    status: true,
                    data: responseData,
                    msg: "Banner Details Fetched successfully ",
                });
            }
        } else {
            res.json({
                status: false,
                data: null,
                msg: "No data found the Banner table",
            });
        }
    } else if (BannerType == "ALL") {
        const BannerDetail = await BannerTable.find(
            {},
            { language: 0, __v: 0, category: 0 }
        ).populate('user', '_id FullName Role').sort({ createdAt: -1 });
        if (BannerDetail) {
            let responseData = await Promise.all(BannerDetail.map(async (data) => {
                let link = "";
                let linkWith = { id: "", name: "" }
                if (data.link === 'batch') {
                    const batchDetails = await BatchesTable.findById(data?.linkWith);
                    if (!batchDetails) {
                        link = "none"
                        linkWith = { id: "NA", name: "NA" }
                    }
                    link = data?.link
                    linkWith = { id: batchDetails?._id ?? "", name: batchDetails?.batch_name ?? "" }
                } else if (data.link === 'testSeries') {
                    const testSeriesDetails = await TestSeriesTable.findById(data?.linkWith);
                    if (!testSeriesDetails) {
                        link = "none"
                        linkWith = { id: "NA", name: "NA" }
                    }
                    link = data?.link
                    linkWith = { id: testSeriesDetails?._id ?? "", name: testSeriesDetails?.testseries_name ?? "" }
                } else if (data.link === 'category') {
                    const category = await categoryTable.findOne({ _id: data.linkWith })
                    if (!category) {
                        link = "none"
                        linkWith = { id: "NA", name: "NA" }
                    }
                    link = data?.link
                    linkWith = { id: category?._id ?? "", name: category?.title ?? "", tags: category?.tags ?? [] }
                }
                else if (data.link === 'link') {
                    link = data?.link
                    linkWith = { id: data?.linkWith ?? "", name: data?.linkWith ?? "" }

                }
                else if (data?.link == 'scholarship') {
                    const scholarship = await scholarshipTestTable.findOne({ _id: data?.linkWith });
                    if (!scholarship) {
                        link = "none"
                        linkWith = { id: "NA", name: "NA" }
                    }
                    link = data?.link
                    linkWith = { id: scholarship?._id, name: scholarship?.title }
                }
                else {
                    link = "none"
                    linkWith = { id: "NA", name: "NA" }
                }
                return {
                    id: data?._id,
                    _id: data?._id,
                    title: data?.title,
                    admin: { id: data?.user?._id, name: data?.user?.FullName ?? "", role: data?.user?.Role ?? "" },
                    created_at: data?.created_at,
                    link,
                    linkWith,
                    is_active: data?.is_active,
                    banner_url: data?.banner_url,
                    BannerType: data?.BannerType,
                }
            }));
            if (responseData) {
                res.json({
                    status: true,
                    data: responseData,
                    msg: "Banner Details Fetched successfully ",
                });
            }
        } else {
            res.json({
                status: false,
                data: null,
                msg: "No data found the Banner table",
            });
        }
    } else {
        const BannerDetail = await BannerTable.find(
            { BannerType: "APP", is_active: true },
            { language: 0, user: 0, __v: 0, category: 0, BannerType: 0 }
        ).sort({ createdAt: -1 }).limit(10);
        if (BannerDetail) {
            let responseData = await Promise.all(BannerDetail.map(async (data) => {
                let link = "";
                let linkWith = { id: "", name: "" }
                if (data.link === 'batch') {
                    const batchDetails = await BatchesTable.findById(data?.linkWith);
                    if (!batchDetails) {
                        link = "none"
                        linkWith = { id: "NA", name: "NA" }
                    }
                    link = data?.link
                    linkWith = { id: batchDetails?._id ?? "", name: batchDetails?.batch_name ?? "" }
                } else if (data.link === 'testSeries') {
                    const testSeriesDetails = await TestSeriesTable.findById(data?.linkWith);
                    if (!testSeriesDetails) {
                        link = "none"
                        linkWith = { id: "NA", name: "NA" }
                    }
                    link = data?.link
                    linkWith = { id: testSeriesDetails?._id ?? "", name: testSeriesDetails?.testseries_name ?? "" }
                } else if (data.link === 'category') {
                    const category = await categoryTable.findOne({ _id: data.linkWith })
                    if (!category) {
                        link = "none"
                        linkWith = { id: "NA", name: "NA" }
                    }
                    link = data?.link
                    linkWith = { id: category?._id ?? "", name: category?.title ?? "", tags: category?.tags ?? [] }
                }
                else if (data.link === 'link') {
                    link = data?.link
                    linkWith = { id: data?.linkWith ?? "", name: data?.linkWith ?? "" }

                }
                else if (data?.link == 'scholarship') {
                    const scholarship = await scholarshipTestTable.findOne({ _id: data?.linkWith });
                    if (!scholarship) {
                        link = "none"
                        linkWith = { id: "NA", name: "NA" }
                    }
                    link = data?.link
                    linkWith = { id: scholarship?._id, name: scholarship?.title }
                }
                else {
                    link = "none"
                    linkWith = { id: "NA", name: "NA" }
                }
                return {
                    _id: data?._id,
                    title: data?.title,
                    created_at: data?.created_at,
                    link,
                    linkWith,
                    is_active: data?.is_active,
                    banner_url: data?.banner_url,
                    BannerType: data?.BannerType,
                }
            }));
            if (responseData) {
                res.json({
                    status: true,
                    data: responseData,
                    msg: "Banner Details Fetched successfully ",
                });
            }
        } else {
            res.json({
                status: false,
                data: null,
                msg: "No data found the Banner table",
            });
        }
    }
});

//add a banner data into the banner table
AdminPanel.post(
    "/addBannerDetails",
    ValidateToken,
    //  uploadTester.array("file"),
    upload.single("file"),
    // isAdmin,
    async (req, res) => {
        const { title, category, language, is_active, BannerType, link, linkWith } = req.body;
        jwt.verify(req.token, process.env.ADMIN_SECRET_KEY, async (err, Data) => {
            if (err) {
                res.status(401).json({
                    err: err,
                    status: false,
                    data: null,
                    msg: "not an admin",
                });
            } else {
                const date = new Date(moment().add(5, "hours").add(30, "minutes"));
                const adminDetails = await findAdminTeacherUsingUserId(Data.studentId);
                if (
                    adminDetails.Role == "admin" ||
                    adminDetails.Role == "subadmin" ||

                    adminDetails.accessToContent.includes("Banner")
                ) {
                    // const categoryFind = await categoryTable.findOne({ title: category });
                    let fileLoc = [];
                    if (req.file) {
                        // for(let i=0;i<req.files.length;i++){
                        let size = req.file.size / (1024);
                        if (size > 150) {
                            return res.json({
                                status: false,
                                data: null,
                                msg: 'Maximum banner size 100KB allowed'
                            })
                        }
                        const helperString = Math.floor(Date.now() / 1000);
                        const filename = (req.file.originalname.split(".")[0]).replace(/\s+/g, '_').replace(/[^a-zA-Z0-9_]/g, '');
                        const extension = "." + req.file.originalname.split(".").pop();
                        FileUploadLocation = `Banner/${title?.replace(/\s+/g, '_').replace(/[^a-zA-Z0-9_]/g, '')}/${filename}_${helperString}${extension}`;
                        let helperfileLoc = await uploadFile(
                            req.file.path,
                            FileUploadLocation
                        );
                        fileLoc.push(helperfileLoc);
                        // }
                    }

                    let formatedDate = formatDate(date);
                    const BannerDetail = new BannerTable({
                        user: adminDetails._id,
                        banner_url: fileLoc[0],
                        category: category, //categoryFind._id,
                        title: title,
                        link: link,
                        linkWith: linkWith,
                        is_active: is_active,
                        created_at: formatedDate,
                        language: language,
                        BannerType: BannerType,
                    });
                    await BannerDetail.save();
                    const fetchBannerDetail = await BannerTable.findOne({
                        _id: BannerDetail.id,
                    }).populate("category");
                    res.json({
                        status: true,
                        data: [fetchBannerDetail, { FileUploadedLocation: fileLoc }],
                        msg: "Banner Details added successfully",
                    });
                } else {
                    res.json({
                        status: false,
                        data: null,
                        msg: "Admin details not found in database",
                    });
                }
            }
        });
    }
);

//deleting the Banner Details
AdminPanel.delete(
    "/DeleteBannerDetails/:id",
    ValidateToken,
    isAdmin,
    async (req, res) => {
        jwt.verify(req.token, process.env.SECRET_KEY, async (err, Data) => {
            if (err) {
                res.status(401).json({
                    err: err,
                    status: false,
                    data: null,
                    msg: "not an admin",
                });
            } else {
                const id = req.params.id;
                const adminDetails = await findAdminTeacherUsingUserId(Data.studentId);
                if (adminDetails) {
                    const checkbanner = await BannerTable.findOne({ _id: id })
                    if (!checkbanner) {
                        return res.json({
                            status: false,
                            data: null,
                            msg: "Banner not found"
                        })
                    }
                    await savePanelEventLogs(
                        adminDetails._id,
                        "deleteBanner",
                        "delete",
                        checkbanner
                    )
                    await BannerTable.findByIdAndDelete({ _id: id });
                    res.json({
                        status: true,
                        data: null,
                        msg: "successfully deleted the banner details",
                    });
                }

            }
        });
    }
);

//Updating the Banner Details
AdminPanel.put(
    "/updatedBannerDetails/:id",
    ValidateToken,
    upload.single("file"),
    isAdmin,
    async (req, res) => {
        let { title, category, is_active, language, BannerType, link, linkWith } = req.body;
        if (link !== 'none' && (linkWith == "" || linkWith == "NA" || linkWith == "none" || typeof (linkWith) == 'undefined')) {
            return res.json({
                status: false,
                data: null,
                msg: "Please select linkWith also!"
            })
        }
        if (link == 'none') linkWith = '';
        jwt.verify(req.token, process.env.ADMIN_SECRET_KEY, async (err, Data) => {
            if (err) {
                res.status(401).json({
                    err: err,
                    status: false,
                    data: null,
                    msg: "not an admin",
                });
            } else {
                const { id } = req.params;
                const BannerDetail = await BannerTable.findOne({ _id: id });
                if (!BannerDetail) {
                    res.status(401).json({
                        err: err,
                        status: false,
                        data: null,
                        msg: "Banner not found",
                    })
                }

                let fileLoc;
                if (req.file) {
                    let size = req.file.size / (1024);
                    if (size > 100) {
                        return res.json({
                            status: false,
                            data: null,
                            msg: 'Maximum banner size 100KB allowed'
                        })
                    }
                    const helperString = Math.floor(Date.now() / 1000);
                    const filename = (req.file.originalname.split(".")[0])?.replace(/\s+/g, '_').replace(/[^a-zA-Z0-9_]/g, '');
                    const extension = "." + req.file.originalname.split(".").pop();
                    FileUploadLocation = `Banner/${title?.replace(/\s+/g, '_').replace(/[^a-zA-Z0-9_]/g, '')}/${filename}_${helperString}${extension}`;
                    fileLoc = await uploadFile(req.file.path, FileUploadLocation);
                } else {
                    fileLoc = BannerDetail?.banner_url
                }
                await BannerTable.findByIdAndUpdate(
                    { _id: id },
                    {
                        banner_url: fileLoc,
                        title: title,
                        BannerType: BannerType,
                        language: language,
                        link: link,
                        linkWith: linkWith,
                        category: category ? category : BannerDetail?.category,
                        is_active: is_active,
                    },
                    {
                        runValidators: true,
                    }
                );
                // await savePanelEventLogs({
                //   user: adminDetails._id,
                //   event: "updateBanner",
                //   action: "update",
                //   data: {
                //     banner_url: fileLoc,
                //     title: title,
                //     BannerType: BannerType,
                //     language: language,
                //     link: link,
                //     linkWith: linkWith,
                //     category: category ? category : BannerDetail?.category,
                //     is_active: is_active,
                //   }
                // })
                res.json({
                    status: true,
                    data: id,
                    msg: "Updated the Banner details",
                });

            }
        });
    }
);

// get banner Data by Id
AdminPanel.get("/getBannerById/:id", ValidateToken, async (req, res) => {
    const { id } = req.params;
    if (!id) {
        return res.json({
            status: false,
            data: null,
            msg: 'Id not found'
        });
    }
    const BannerDetail = await BannerTable.findById(
        id,
        { language: 0, user: 0, __v: 0, category: 0 }
    );
    if (BannerDetail) {
        let linkWith = {};
        // let link = BannerDetail?.link;
        if (BannerDetail?.link == 'batch' && BannerDetail?.linkWith != "") {
            const batchDetails = await BatchesTable.findById(BannerDetail?.linkWith);
            if (batchDetails) {
                linkWith = { id: batchDetails?._id, name: batchDetails?.batch_name }
            }
        } else if (BannerDetail?.link == 'testSeries' && BannerDetail?.linkWith != "") {
            const testSeriesDetails = await TestSeriesTable.findById(BannerDetail?.linkWith);
            if (testSeriesDetails) {
                linkWith = { id: testSeriesDetails?._id, name: testSeriesDetails?.testseries_name }
            }
        } else if (BannerDetail?.link == 'category' && BannerDetail?.linkWith != "") {
            const category = await categoryTable.findById(BannerDetail?.linkWith);
            if (category) {
                linkWith = { id: category?._id, name: category?.title, tags: category?.tags ?? "" }
            }
        }
        else if (BannerDetail?.link == 'scholarship' && BannerDetail?.linkWith != "") {
            const scholarship = await scholarshipTestTable.findById(BannerDetail?.linkWith);
            if (scholarship) {
                linkWith = { id: scholarship?._id, name: scholarship?.title }
            }
        }
        else if (BannerDetail?.link == 'link' && BannerDetail?.linkWith != "") {

            linkWith = { id: BannerDetail?.linkWith, name: BannerDetail?.linkWith }

        }
        else {
            linkWith = { id: "", name: "" }
        }
        const responseData = {
            _id: BannerDetail?._id,
            title: BannerDetail?.title,
            created_at: BannerDetail?.created_at,
            link: BannerDetail?.link,
            linkWith: linkWith,
            BannerType: BannerDetail?.BannerType,
            is_active: BannerDetail?.is_active,
            banner_url: BannerDetail?.banner_url,
        }

        return res.json({
            status: false,
            data: responseData,
            msg: "Banner Details fetched"
        })


    } else {
        return res.json({
            status: false,
            data: null,
            msg: 'Banner details not found'
        });
    }

})

//get all the data from YouTube table
AdminPanel.get("/YouTubeDetails", ValidateToken, async (req, res) => {
    const { language } = req.query;
    jwt.verify(req.token, process.env.SECRET_KEY, async (err, Data) => {
        if (err) {
            res.status(401).json({
                err: err,
                status: false,
                data: null,
                msg: "not an admin",
            });
        } else {
            const YouTubeDetail = await YouTube_Url.find({
                is_active: true,
            });
            if (YouTube_Url.length != 0) {
                if (language) {
                    let YouTubeByLang = YouTubeDetail.filter((YouTube) => {
                        return YouTube.language == language;
                    });
                    res.json({
                        status: true,
                        data: YouTubeByLang,
                        msg: "fetched all the YouTube table data",
                    });
                } else {
                    res.json({
                        status: true,
                        data: YouTubeDetail,
                        msg: "fetched all the YouTube table data",
                    });
                }
            } else {
                res.json({
                    status: false,
                    data: null,
                    msg: "No data found ",
                });
            }
        }
    });
});



//add the youtube details to the youtube table
AdminPanel.post("/addYouTubeDetails",
    upload.fields([
        {
            name: "notes",
            maxCount: 4,
        },
    ]),
    ValidateToken, async (req, res) => {
        try {
            const { video_url, title, language, is_active, category, subCategory, subject, desc } = req.body;
            jwt.verify(req.token, process.env.ADMIN_SECRET_KEY, async (err, Data) => {
                if (err) {
                    res.status(401).json({
                        status: false,
                        data: null,
                        msg: err,
                    });
                } else {
                    const adminDetails = await findAdminTeacherUsingUserId(Data.studentId);
                    const date = new Date(moment().add(5, "hours").add(30, "minutes"));
                    let formatedDate = formatDate(date);
                    if (
                        adminDetails.Role == "admin" ||
                        adminDetails.Role == "subadmin" ||

                        adminDetails.accessToContent.includes("Youtube")
                    ) {
                        let fileArray = [];
                        // console.log(req.files?.notes);
                        // console.log(req.files);
                        // console.log(req)
                        if (req?.files?.notes?.length > 0) {
                            for (const file of req?.files?.notes) {
                                // console.log(file);
                                const helperString = Math.floor(Date.now() / 1000);
                                const filename = file?.originalname.split(".")[0]?.replace(/\s+/g, '_');
                                const extension = "." + file.originalname.split(".").pop();
                                FileUploadLocation = `videoLearning/${filename}_${helperString}${extension}`;
                                let fileLocHelper = await uploadFile(file.path, FileUploadLocation);
                                let details = fileDetails(file, fileLocHelper);
                                fileArray.push(details);
                            }
                        }
                        let slug = await generateSlug(title);
                        let categoriesId = category?.filter((item) => item != "");
                        let subCategoriesId = subCategory?.filter((item) => item != "");
                        const newYouTubeData = await new YouTube_Url({
                            user: adminDetails._id,
                            video_url: video_url,
                            is_active: is_active,
                            title: title,
                            slug,
                            created_at: formatedDate,
                            language: language,
                            category: categoriesId,
                            subCategory: subCategoriesId,
                            subject,
                            notes: fileArray,
                            desc

                        });
                        const savedYt = await newYouTubeData.save();
                        let link = `https://www.sdcampus.com?route=${`ytvideosbyid`}&rootId=${savedYt?._id}&childId=null`
                        let details = {
                            "link": link ?? "",
                            "utmSource": "web_app",
                            "utmMedium": "refer",
                            "utmCampaign": "batch_share",
                            "utmTerm": "",
                            "utmContent": "",
                            "socialTitle": title ?? "",
                            "socialDescription": "",
                            "socialImageLink": ""
                        }
                        let data1 = await genrateDeepLink(details);
                        await YouTube_Url.findByIdAndUpdate(savedYt?._id, { shareLink: { link: data1.shortLink, text: title } })



                        res.json({
                            status: true,
                            data: newYouTubeData,
                            msg: "added youtube details successfully",
                        });
                    } else {
                        res.json({
                            status: false,
                            data: null,
                            msg: "admin not found",
                        });
                    }
                }
            });
        } catch (error) {
            return res.json({
                status: false,
                data: null,
                msg: error.message
            })
        }
    });

//Deleting the YouTube Details
AdminPanel.delete(
    "/DeleteYouTubeDetails/:id",
    ValidateToken,
    async (req, res) => {
        jwt.verify(req.token, process.env.SECRET_KEY, async (err, Data) => {
            if (err) {
                res.status(401).json({
                    err: err,
                    status: false,
                    data: null,
                    msg: "not an admin",
                });
            } else {
                const adminDetails = await findAdminTeacherUsingUserId(Data.studentId);
                if (
                    adminDetails.Role == "admin" ||
                    adminDetails.Role == "subadmin" ||

                    adminDetails.accessToContent.includes("Youtube")
                ) {
                    const id = req.params.id;
                    const findYouTubeDetails = await YouTube_Url.findOne({
                        _id: id,
                    });
                    if (findYouTubeDetails) {
                        await savePanelEventLogs(
                            adminDetails._id,
                            "deleteYoutubeVideo",
                            "delete",
                            findYouTubeDetails
                        )
                        await YouTube_Url.findByIdAndDelete({ _id: id });
                        res.json({
                            status: true,
                            data: null,
                            msg: "successfully deleted the YouTube details",
                        });
                    } else {
                        res.json({
                            status: false,
                            data: null,
                            msg: "the YouTube details not found ",
                        });
                    }
                } else {
                    res.json({
                        status: false,
                        data: null,
                        msg: "no authority to perform the specific task",
                    });
                }
            }
        });
    }
);

//Updating the Banner Details
AdminPanel.put(
    "/updatedYouTubeDetails/:id",
    upload.fields([
        {
            name: "notes",
            maxCount: 4,
        },
    ]),
    ValidateToken,
    async (req, res) => {
        try {
            const { title, video_url, is_active, language, desc, category, subCategory, subject } = req.body;
            jwt.verify(req.token, process.env.ADMIN_SECRET_KEY, async (err, Data) => {
                if (err) {
                    res.status(401).json({
                        err: err,
                        status: false,
                        data: null,
                        msg: "not an admin",
                    });
                } else {
                    const date = new Date(moment().add(5, "hours").add(30, "minutes"));
                    const adminDetails = await findAdminTeacherUsingUserId(Data.studentId);
                    if (
                        adminDetails.Role == "admin" ||
                        adminDetails.Role == "subadmin" ||

                        adminDetails.accessToContent.includes("Youtube")
                    ) {
                        const id = req.params.id;
                        const YouTubeDetail = await YouTube_Url.findOne({
                            _id: id,
                        });
                        let fileArray = YouTubeDetail?.notes ?? [];
                        if (req?.files?.notes?.length > 0) {
                            fileArray = [];
                            for (const file of req?.files?.notes) {
                                const helperString = Math.floor(Date.now() / 1000);
                                const filename = file?.originalname.split(".")[0]?.replace(/\s+/g, '_');
                                const extension = "." + file.originalname.split(".").pop();
                                FileUploadLocation = `videoLearning/${filename}_${helperString}${extension}`;
                                let fileLocHelper = await uploadFile(file.path, FileUploadLocation);
                                let details = fileDetails(file, fileLocHelper);
                                fileArray.push(details);
                            }
                        }
                        let categoriesId = category?.filter((item) => item != "");
                        let subCategoriesId = subCategory?.filter((item) => item != "");

                        let slug = await generateSlug(title);
                        if (YouTubeDetail) {
                            await YouTube_Url.findByIdAndUpdate(
                                { _id: id },
                                {
                                    video_url: video_url,
                                    title: title,
                                    slug,
                                    category: categoriesId,
                                    subCategory: subCategoriesId,
                                    subject: subject,
                                    notes: fileArray,
                                    desc: desc,
                                    is_active,
                                    language
                                },
                                {
                                    runValidators: true,
                                }
                            );
                            res.json({
                                status: true,
                                data: id,
                                msg: "Updated the YouTube details",
                            });
                        } else {
                            res.json({
                                status: false,
                                data: null,
                                msg: "YouTube detail not found",
                            });
                        }
                    } else {
                        res.json({
                            status: false,
                            data: null,
                            msg: "Admin details not found in database",
                        });
                    }
                }
            });
        } catch (error) {
            return res.json({
                status: false,
                data: null,
                msg: error.message
            })
        }
    }
);


AdminPanel.get("/getAllYoutubeVideo", isAdmin, async (req, res) => {
    try {
        const decoded = jwt.verify(req.token, process.env.ADMIN_SECRET_KEY);
        const adminDetails = await findAdminTeacherUsingUserId(decoded.studentId);
        if (!adminDetails) {
            return res.json({
                status: false,
                data: null,
                msg: "Not an admin",
            });
        }
        const allVideo = await YouTube_Url.find({}).populate('category', 'title').populate('subject', 'title').populate('subCategory', 'title');
        if (allVideo) {
            let responseData =
                allVideo.map((data) => {

                    return {
                        id: data._id ?? "",
                        title: data.title ?? "",
                        video_url: data.video_url,
                        subject: data?.subject?.title ?? "",
                        category: data?.category?.reduce((acc, curr) => acc + curr.title + " , ", ""),
                        subCategory: data?.subCategory?.reduce((acc, curr) => acc + curr.title + " , ", ""),
                        language: data.language ?? "",
                        createdAt: data.created_at ?? "",
                        isActive: data.is_active ?? "",
                        desc: data?.desc ?? "",

                    };

                })

            if (responseData) {
                return res.json({
                    status: true,
                    data: responseData,
                    msg: "All Video Fetched.",
                });
            }
        }
    } catch (error) {
        return res.json({
            status: false,
            data: null,
            msg: error.message || `Store Banner not fetched`,
        });
    }
});

//get all storeBaneerBy Id for admin
AdminPanel.get("/getYoutubeVideo/:id", isAdmin, async (req, res) => {
    try {
        const { id } = req.params;

        if (!id) {
            return res.json({
                status: false,
                data: null,
                msg: "Required Id",
            });
        }
        const decoded = jwt.verify(req.token, process.env.ADMIN_SECRET_KEY);
        const adminDetails = await findAdminTeacherUsingUserId(decoded.studentId);
        if (!adminDetails) {
            return res.status(401).json({
                status: false,
                data: null,
                msg: "Not an admin",
            });
        }
        const data = await YouTube_Url.findById(id).populate('subject', '_id title');

        if (data) {

            return res.json({
                status: true,
                data: {
                    id: data._id ?? "",
                    title: data.title ?? "",
                    video_url: data.video_url,
                    category: data?.category ?? [],
                    subCategory: data?.subCategory ?? [],
                    subject: data?.subject,
                    language: data.language ?? "",
                    desc: data?.desc ?? "",
                    is_active: data.is_active ?? "",

                },
                msg: 'Video fetched'
            })


        } else {
            return res.json({
                status: false,
                data: null,
                msg: `Video  not found.`,
            });
        }
    } catch (error) {
        return res.json({
            status: false,
            data: null,
            msg: error.message || `Error fetching Video by ID`,
        });
    }
});
//get all the data from Telegram table
AdminPanel.get("/TelegramDetails", ValidateToken, async (req, res) => {
    jwt.verify(req.token, process.env.SECRET_KEY, async (err, Data) => {
        if (err) {
            res.status(401).json({
                err: err,
                status: false,
                data: null,
                msg: "not an admin",
            });
        } else {
            const TelegramDetails = await Telegram_Channel.find({});
            if (TelegramDetails.length != 0) {
                res.json({
                    status: true,
                    data: TelegramDetails,
                    msg: "fetched all the Telegram table data",
                });
            } else {
                res.json({
                    status: false,
                    data: null,
                    msg: "No data found ",
                });
            }
        }
    });
});

//added data into the Telegram table
AdminPanel.post(
    "/addTelegramChannelDetails",
    ValidateToken,
    async (req, res) => {
        const { channel_url, title, is_active } = req.body;
        jwt.verify(req.token, process.env.ADMIN_SECRET_KEY, async (err, Data) => {
            if (err) {
                res.status(401).json({
                    status: false,
                    data: null,
                    msg: err,
                });
            } else {
                const adminDetails = await findAdminTeacherUsingUserId(Data.studentId);
                const date = new Date(moment().add(5, "hours").add(30, "minutes"));
                let formatedDate = formatDate(date);
                if (
                    adminDetails.Role == "admin" ||
                    adminDetails.Role == "subadmin" ||

                    adminDetails.accessToContent.includes("Telegram")
                ) {
                    const newTelegramData = new Telegram_Channel({
                        user: adminDetails._id,
                        channel_url: channel_url,
                        is_active: is_active,
                        title: title,
                        created_at: formatedDate,
                    });
                    await newTelegramData.save();
                    res.json({
                        status: true,
                        data: newTelegramData,
                        msg: "added Telegram  details successfully",
                    });
                } else {
                    res.json({
                        status: false,
                        data: null,
                        msg: "not an admin",
                    });
                }
            }
        });
    }
);

//Deleting the Telegram Details
AdminPanel.delete(
    "/DeleteTelegramDetails/:id",
    ValidateToken,
    async (req, res) => {
        jwt.verify(req.token, process.env.SECRET_KEY, async (err, Data) => {
            if (err) {
                res.status(401).json({
                    err: err,
                    status: false,
                    data: null,
                    msg: "not an admin",
                });
            } else {
                const adminDetails = await findAdminTeacherUsingUserId(Data.studentId);
                if (
                    adminDetails.Role == "admin" ||
                    adminDetails.Role == "subadmin" ||
                    adminDetails.accessToContent.includes("Telegram")
                ) {
                    const { id } = req.params;
                    const telegram = await Telegram_Channel.findByIdAndDelete({ _id: id });
                    await savePanelEventLogs(
                        adminDetails._id,
                        "deleteTelegramChannel",
                        "delete",
                        telegram
                    )
                    res.json({
                        status: true,
                        data: null,
                        msg: "successfully deleted the Telegram details",
                    });
                } else {
                    res.json({
                        status: false,
                        data: null,
                        msg: "the Telegram details not found ",
                    });
                }
                // } else {
                //   res.json({
                //     status: false,
                //     data: null,
                //     msg: "no authority to perform the specific task",
                //   });
                // }
            }
        });
    }
);

//Updating the Telegram Details
AdminPanel.put(
    "/updatedTelegramDetails/:id",
    ValidateToken,
    async (req, res) => {
        const { channel_url, title, is_active } = req.body;
        jwt.verify(req.token, process.env.ADMIN_SECRET_KEY, async (err, Data) => {
            if (err) {
                res.status(401).json({
                    err: err,
                    status: false,
                    data: null,
                    msg: "not an admin",
                });
            } else {
                const date = new Date(moment().add(5, "hours").add(30, "minutes"));
                const adminDetails = await findAdminTeacherUsingUserId(Data.studentId);
                if (
                    adminDetails.Role == "admin" ||
                    adminDetails.Role == "subadmin" ||
                    adminDetails.accessToContent.includes("Telegram")
                ) {
                    const id = req.params.id;
                    // const TelegramDetail = await Telegram_Channel.findOne({ _id: id });
                    // if (TelegramDetail) {
                    await Telegram_Channel.findByIdAndUpdate(
                        { _id: id },
                        {
                            channel_url: channel_url,
                            title: title,
                            is_active: is_active,
                        },
                        {
                            runValidators: true,
                        }
                    );
                    res.json({
                        status: true,
                        data: id,
                        msg: `Updated the ${channel_url} details`,
                    });
                    // } else {
                    //   res.json({
                    //     status: false,
                    //     data: null,
                    //     msg: `${channel_url} not found`,
                    //   });
                    // }
                } else {
                    res.json({
                        status: false,
                        data: null,
                        msg: "Admin details not found in database",
                    });
                }
            }
        });
    }
);

//get all the data from Contact_Info table
AdminPanel.get("/contactinfodetails", ValidateToken, async (req, res) => {
    const { Category, id } = req.query;
    jwt.verify(req.token, process.env.SECRET_KEY, async (err, Data) => {
        if (err) {
            res.status(401).json({
                err: err,
                status: false,
                data: null,
                msg: "not an admin",
            });
        } else {
            const ContactDetails = await Contact_Info.find({}).populate("category");
            if (ContactDetails) {
                if (Category && !id) {
                    const FindCategory = await categoryTable.findOne({
                        title: Category,
                    });
                    let filterdArray = ContactDetails.filter((Contact) => {
                        return Contact.category._id == "" + FindCategory._id;
                    });
                    res.json({
                        status: true,
                        data: filterdArray,
                        msg: "Contact Details Fetched successfully",
                    });
                } else if (id && !Category) {
                    let filterdArray = ContactDetails.filter((contact) => {
                        return contact._id == id;
                    });
                    res.json({
                        status: true,
                        data: filterdArray,
                        msg: "Contact Details Fetched successfully",
                    });
                } else if (Category && id) {
                    const FindCategory = await categoryTable.findOne({
                        title: Category,
                    });
                    let filterdArray = ContactDetails.filter((contact) => {
                        return (
                            contact.category._id == "" + FindCategory._id && contact._id == id
                        );
                    });
                    res.json({
                        status: true,
                        data: filterdArray,
                        msg: "contact Details Fetched successfully",
                    });
                } else {
                    res.json({
                        status: true,
                        data: ContactDetails,
                        msg: "contact Details Fetched successfully ",
                    });
                }
            } else {
                res.json({
                    status: false,
                    data: null,
                    msg: "No data found the contact table",
                });
            }
        }
    });
});

//added data into the Contact_info table
AdminPanel.post("/addcontactdetails", ValidateToken, async (req, res) => {
    const { category, title, data, is_active } = req.body;
    jwt.verify(req.token, process.env.ADMIN_SECRET_KEY, async (err, Data) => {
        if (err) {
            res.status(401).json({
                status: false,
                data: null,
                msg: err,
            });
        } else {
            const adminDetails = await findAdminTeacherUsingUserId(Data.studentId);
            const date = new Date(moment().add(5, "hours").add(30, "minutes"));
            let formatedDate = formatDate(date);
            if (
                adminDetails.Role == "admin" ||
                adminDetails.Role == "subadmin" ||
                adminDetails.accessToContent.includes("Contact Us")
            ) {
                const categoryFind = await categoryTable.findOne({
                    title: category,
                });
                const newContactData = new Contact_Info({
                    user: adminDetails._id,
                    category: categoryFind._id,
                    data: data,
                    is_active: is_active,
                    title: title,
                    created_at: formatedDate,
                });
                await newContactData.save();
                res.json({
                    status: true,
                    data: newContactData,
                    msg: "added contact  details successfully",
                });
            } else {
                res.json({
                    status: false,
                    data: null,
                    msg: "not an admin",
                });
            }
        }
    });
});

//Deleting the Conatct Details
AdminPanel.delete(
    "/DeleteContactDetails/:id",
    ValidateToken,
    async (req, res) => {
        jwt.verify(req.token, process.env.SECRET_KEY, async (err, Data) => {
            if (err) {
                res.status(401).json({
                    err: err,
                    status: false,
                    data: null,
                    msg: "not an admin",
                });
            } else {
                const adminDetails = await findAdminTeacherUsingUserId(Data.studentId);
                if (
                    adminDetails.Role == "admin" ||
                    adminDetails.Role == "subadmin" ||

                    adminDetails.accessToContent.includes("Contact Us")
                ) {
                    const id = req.params.id;
                    const findContactDetails = await Contact_Info.findOne({
                        _id: id,
                    });
                    if (findContactDetails) {
                        await savePanelEventLogs(
                            adminDetails._id,
                            "deleteContact",
                            "delete",
                            findContactDetails
                        )
                        await Contact_Info.findByIdAndDelete({ _id: id });
                        res.json({
                            status: true,
                            data: null,
                            msg: "successfully deleted the Contact details",
                        });
                    } else {
                        res.json({
                            status: false,
                            data: null,
                            msg: "the Contact details not found ",
                        });
                    }
                } else {
                    res.json({
                        status: false,
                        data: null,
                        msg: "no authority to perform the specific task",
                    });
                }
            }
        });
    }
);

//Updating the Contact Details
AdminPanel.put(
    "/updatedContactDetails/:id",
    ValidateToken,
    async (req, res) => {
        const { category, title, is_active, data } = req.body;
        jwt.verify(req.token, process.env.ADMIN_SECRET_KEY, async (err, Data) => {
            if (err) {
                res.status(401).json({
                    err: err,
                    status: false,
                    data: null,
                    msg: "not an admin",
                });
            } else {
                const adminDetails = await findAdminTeacherUsingUserId(Data.studentId);
                if (
                    adminDetails.Role == "admin" ||
                    adminDetails.Role == "subadmin" ||

                    adminDetails.accessToContent.includes("Contact Us")
                ) {
                    const id = req.params.id;
                    const ContactDetail = await Contact_Info.findOne({
                        _id: id,
                    });
                    if (ContactDetail) {
                        const categoryFind = await categoryTable.findOne({
                            title: category,
                        });
                        if (categoryFind) {
                            await Contact_Info.findByIdAndUpdate(
                                { _id: id },
                                {
                                    category: categoryFind._id,
                                    title: title,
                                    is_active: is_active,
                                    data: data,
                                },
                                {
                                    runValidators: true,
                                }
                            );
                            res.json({
                                status: true,
                                data: id,
                                msg: `Updated the ${title} contact  details`,
                            });
                        } else {
                            res.json({
                                status: false,
                                data: null,
                                msg: "Invalid category ",
                            });
                        }
                    } else {
                        res.json({
                            status: false,
                            data: null,
                            msg: `${title} not found`,
                        });
                    }
                } else {
                    res.json({
                        status: false,
                        data: null,
                        msg: "Admin details not found in database",
                    });
                }
            }
        });
    }
);

//get all the data from Resources table
AdminPanel.get("/ResourceDetails", ValidateToken, async (req, res) => {
    const { Category, id, language } = req.query;
    jwt.verify(req.token, process.env.SECRET_KEY, async (err, Data) => {
        if (err) {
            res.status(401).json({
                err: err,
                status: false,
                data: null,
                msg: "not an admin",
            });
        } else {
            const userDetails = await UserTable.findOne({
                userId: Data.studentId,
            });
            let BannerDetail;
            if (userDetails) {
                BannerDetail = await ResourcesTable.find(
                    { is_active: true },
                    { user: 0, __v: 0 }
                )
                    .populate("category", { user: 0, __v: 0, type: 0 })
                    .populate("subject");
            } else {
                BannerDetail = await ResourcesTable.find({}, { user: 0, __v: 0 })
                    .populate("category", { user: 0, __v: 0, type: 0 })
                    .populate("subject");
            }
            if (BannerDetail) {
                if (Category && !id && !language) {
                    const FindCategory = await categoryTable.findOne({
                        title: Category,
                    });
                    let filterdArray = BannerDetail.filter((Banners) => {
                        return Banners.category._id == "" + FindCategory._id;
                    });
                    res.json({
                        status: true,
                        data: filterdArray,
                        msg: "Resource Details Fetched successfully",
                    });
                } else if (id && !Category && !language) {
                    let filterdArray = BannerDetail.filter((Banners) => {
                        return Banners._id == id;
                    });
                    res.json({
                        status: true,
                        data: filterdArray,
                        msg: "Resource Details Fetched successfully",
                    });
                } else if (Category && id && !language) {
                    const FindCategory = await categoryTable.findOne({
                        title: Category,
                    });
                    let filterdArray = BannerDetail.filter((Banners) => {
                        return (
                            Banners.category._id == "" + FindCategory._id && Banners._id == id
                        );
                    });
                    res.json({
                        status: true,
                        data: filterdArray,
                        msg: "Resource Details Fetched successfully",
                    });
                } else if (Category && id && language) {
                    const FindCategory = await categoryTable.findOne({
                        title: Category,
                    });
                    let filterdArray = BannerDetail.filter((Banners) => {
                        return (
                            Banners.category._id == "" + FindCategory._id &&
                            Banners._id == id &&
                            Banners.language == language
                        );
                    });
                    res.json({
                        status: true,
                        data: filterdArray,
                        msg: "Resource Details Fetched successfully",
                    });
                } else if (!Category && id && language) {
                    let filterdArray = BannerDetail.filter((Banners) => {
                        return Banners._id == id && Banners.language == language;
                    });
                    res.json({
                        status: true,
                        data: filterdArray,
                        msg: "Resource Details Fetched successfully",
                    });
                } else if (Category && !id && language) {
                    const FindCategory = await categoryTable.findOne({
                        title: Category,
                    });
                    let filterdArray = BannerDetail.filter((Banners) => {
                        return (
                            Banners.category._id == "" + FindCategory._id &&
                            Banners.language == language
                        );
                    });
                    res.json({
                        status: true,
                        data: filterdArray,
                        msg: "Resource Details Fetched successfully",
                    });
                } else if (!Category && !id && language) {
                    const FindCategory = await categoryTable.findOne({
                        title: Category,
                    });
                    let filterdArray = BannerDetail.filter((Banners) => {
                        return Banners.language == language;
                    });
                    let helperArray = filterdArray.filter((arraElem) => {
                        const extension = "." + arraElem.fileLoc.split(".").pop();
                        arraElem.extension = extension;
                        return arraElem;
                    });
                    res.json({
                        status: true,
                        data: filterdArray,
                        msg: "Resource Details Fetched successfully",
                    });
                } else {
                    res.json({
                        status: true,
                        data: BannerDetail,
                        msg: "Resource Details Fetched successfully ",
                    });
                }
            } else {
                res.json({
                    status: false,
                    data: null,
                    msg: "No data found",
                });
            }
        }
    });
});

//added data into the Resource table
AdminPanel.post(
    "/addResourceDetails",
    ValidateToken,
    upload.single("file"),
    async (req, res) => {
        try {
            const {
                category,
                title,
                language,
                subject,
                is_active,
                resource_type,
                link,
                year,
                subjectId
            } = req.body;
            jwt.verify(req.token, process.env.ADMIN_SECRET_KEY, async (err, Data) => {
                if (err) {
                    res.status(401).json({
                        status: false,
                        data: null,
                        msg: err,
                    });
                } else {
                    const adminDetails = await findAdminTeacherUsingUserId(Data.studentId);
                    const date = new Date(moment().add(5, "hours").add(30, "minutes"));
                    let formatedDate = formatDate(date);
                    if (
                        adminDetails.Role == "admin" ||
                        adminDetails.Role == "subadmin" ||

                        adminDetails.accessToContent.includes("Pathyakram")
                    ) {
                        // console.log(catro)
                        const categoryFind = await categoryTable.findOne({
                            _id: category,
                        });
                        // console.log(categoryFind);
                        let FileUploadLocation;
                        let fileLoc;
                        let helperFileObject;
                        if (resource_type == "file") {
                            if (req.file) {
                                const helperString = Math.floor(Date.now() / 1000);
                                const filename = req.file.originalname.split(".")[0];
                                const extension = "." + req.file.originalname.split(".").pop();
                                FileUploadLocation = `Resources/${subject}/${filename}_${helperString}${extension}`;
                                fileLoc = await uploadFile(req.file.path, FileUploadLocation);
                                helperFileObject = {
                                    fileLoc: fileLoc,
                                    fileName: filename,
                                    fileSize: `${(req.file.size / 1000000).toFixed(2)} MB`,
                                };
                            }
                        } else {
                            helperFileObject = {
                                fileLoc: link,
                                fileName: null,
                                fileSize: null,
                            };
                        }
                        const newResourceData = new ResourcesTable({
                            user: adminDetails._id,
                            category: categoryFind._id,
                            subject: subject,
                            subjectId: subjectId,
                            file_url: helperFileObject,
                            is_active: is_active,
                            language: language,
                            title: title,
                            resource_type: resource_type,
                            Created_At: formatedDate,
                            year
                        });
                        await newResourceData.save();
                        // if (is_active) {
                        //     const data = {
                        //         title: title,
                        //         message: `New Resource ${title} added`,
                        //         fileUrl: "",
                        //         route: "syllabus",
                        //         rootId: "",
                        //         childId: ""
                        //     };
                        //     // await sendCustomNotification('all', data);
                        // }


                        res.json({
                            status: true,
                            data: [newResourceData, { fileuploadLoc: fileLoc }],
                            msg: "added Resource details successfully",
                        });
                    } else {
                        res.json({
                            status: false,
                            data: null,
                            msg: "not an admin",
                        });
                    }
                }
            });
        } catch (error) {
            return res.json({
                status: false,
                data: null,
                msg: error.message
            })
        }
    }
);

//Deleting the Telegram Details
AdminPanel.delete(
    "/DeleteResourcesDetails/:id",
    ValidateToken,
    async (req, res) => {
        jwt.verify(req.token, process.env.SECRET_KEY, async (err, Data) => {
            if (err) {
                res.status(401).json({
                    err: err,
                    status: false,
                    data: null,
                    msg: "not an admin",
                });
            } else {
                const adminDetails = await findAdminTeacherUsingUserId(Data.studentId);
                if (
                    adminDetails.Role == "admin" ||
                    adminDetails.Role == "subadmin" ||

                    adminDetails.accessToContent.includes("Pathyakram")
                ) {
                    const id = req.params.id;
                    const findResourcesDetails = await ResourcesTable.findOne({
                        _id: id,
                    });
                    if (findResourcesDetails) {
                        await ResourcesTable.findByIdAndDelete({
                            _id: id,
                        });
                        await savePanelEventLogs(
                            adminDetails._id,
                            "deleteResourcesDetails(Pathyakrams)",
                            "delete",
                            findResourcesDetails
                        )
                        res.json({
                            status: true,
                            data: null,
                            msg: "successfully deleted the Resource details",
                        });
                    } else {
                        res.json({
                            status: false,
                            data: null,
                            msg: "the Resource details not found ",
                        });
                    }
                } else {
                    res.json({
                        status: false,
                        data: null,
                        msg: "no authority to perform the specific task",
                    });
                }
            }
        });
    }
);

//Updating the Resource Details
AdminPanel.put(
    "/updatedResourceDetails/:id",
    ValidateToken,
    upload.single("file"),
    async (req, res) => {
        const {
            is_active,
            category,
            title,
            language,
            subject,
            resource_type,
            link,
        } = req.body;
        jwt.verify(req.token, process.env.ADMIN_SECRET_KEY, async (err, Data) => {
            if (err) {
                res.status(401).json({
                    err: err,
                    status: false,
                    data: null,
                    msg: "not an admin",
                });
            } else {
                const adminDetails = await findAdminTeacherUsingUserId(Data.studentId);
                if (
                    adminDetails.Role == "admin" ||
                    adminDetails.Role == "subadmin" ||

                    adminDetails.accessToContent.includes("Pathyakram")
                ) {
                    const id = req.params.id;
                    const ResourceDetail = await ResourcesTable.findOne({ _id: id });
                    if (ResourceDetail) {
                        const categoryFind = await categoryTable.findOne({
                            title: category,
                        });
                        if (categoryFind) {
                            let fileLoc;
                            let helperFileObject;
                            if (resource_type == "file") {
                                if (req.file) {
                                    const helperString = Math.floor(Date.now() / 1000);
                                    const filename = (req.file.originalname.split(".")[0])?.replace(/\s+/g, '_').replace(/[^a-zA-Z0-9_]/g, '');
                                    const extension =
                                        "." + req.file.originalname.split(".").pop();

                                    FileUploadLocation = `Resources/${subject}/${filename}_${helperString}${extension}`;
                                    fileLoc = await uploadFile(req.file.path, FileUploadLocation);
                                    helperFileObject = {
                                        fileLoc: fileLoc,
                                        fileName: filename,
                                        fileSize: `${(req.file.size / 1000000).toFixed(2)} MB`,
                                    };
                                }
                            } else {
                                helperFileObject = {
                                    fileLoc: link,
                                };
                            }
                            await ResourcesTable.findByIdAndUpdate(
                                { _id: id },
                                {
                                    category: categoryFind._id,
                                    title: title,
                                    file_url: fileLoc,
                                    language: language,
                                    is_active: is_active,
                                    subject: subject,
                                    resource_type: resource_type,
                                    link: link,
                                },
                                {
                                    runValidators: true,
                                }
                            );
                            res.json({
                                status: true,
                                data: id,
                                msg: "Updated the Resource details",
                            });
                        } else {
                            res.json({
                                status: false,
                                data: null,
                                msg: "Invalid category ",
                            });
                        }
                    } else {
                        res.json({
                            status: false,
                            data: null,
                            msg: "Resource not found",
                        });
                    }
                } else {
                    res.json({
                        status: false,
                        data: null,
                        msg: "Admin details not found in database",
                    });
                }
            }
        });
    }
);

//get all the data from Resources table
AdminPanel.get("/getNotesDetails", ValidateToken, async (req, res) => {
    try {
        const { language, Notes_type, category, subCategory } = req.query;

        jwt.verify(req.token, process.env.SECRET_KEY, async (err, Data) => {
            if (err) {
                res.status(401).json({
                    err: err,
                    status: false,
                    data: null,
                    msg: "Unauthorization",
                });
            } else {
                let query = { is_active: true }
                if (category) {
                    query.category = category
                }
                if (subCategory) {
                    query.subCategory = subCategory
                }
                const NotesDetails = await NotesTable.find({ ...query }).sort({ createdAt: -1 });
                if (NotesDetails?.length > 0) {
                    return res.json({
                        status: true,
                        data: NotesDetails,
                        msg: "Fetched all the notes",
                    });

                } else {
                    return res.json({
                        status: true,
                        data: [],
                        msg: "No data found ",
                    });
                }
            }
        })
    } catch (error) {
        return res.json({
            status: false,
            data: null,
            msg: error.message
        })
    }
});


//added data into the Resource table
AdminPanel.post(
    "/addNotesDetails",
    ValidateToken,
    upload.single("file"),
    async (req, res) => {
        try {
            const { notes_type, subject, title, is_active, language, category, subCategory } = req.body;
            if (!category || !subCategory) {
                return res.json({
                    status: false,
                    data: null,
                    msg: 'Category Or SubCategory Required'
                })
            }
            jwt.verify(req.token, process.env.ADMIN_SECRET_KEY, async (err, Data) => {
                if (err) {
                    res.status(401).json({
                        status: false,
                        data: null,
                        msg: err,
                    });
                } else {
                    const adminDetails = await findAdminTeacherUsingUserId(Data.studentId);
                    const date = new Date(moment().add(5, "hours").add(30, "minutes"));
                    if (
                        adminDetails.Role == "admin" ||
                        adminDetails.Role == "subadmin" ||

                        adminDetails.accessToContent.includes("Notes")
                    ) {
                        let FileUploadLocation;
                        let fileLoc;
                        let formatedDate = formatDate(date);
                        if (req.file) {
                            const helperString = Math.floor(Date.now() / 1000);
                            const filename = (req.file.originalname.split(".")[0]).replace(/\s+/g, '_').replace(/[^a-zA-Z0-9_]/g, '');
                            const extension = "." + req.file.originalname.split(".").pop();
                            FileUploadLocation = `Notes/${title?.replace(/\s+/g, '_').replace(/[^a-zA-Z0-9_]/g, '')}/${filename}_${helperString}${extension}`;
                            let fileLocHelper = await uploadFile(
                                req.file.path,
                                FileUploadLocation
                            );
                            fileLoc = fileDetails(req.file, fileLocHelper);
                        }
                        const newNotesData = new NotesTable({
                            user: adminDetails._id,
                            notes_type: notes_type,
                            file_url: fileLoc,
                            is_active: is_active,
                            title: title,
                            created_at: formatedDate,
                            language: language,
                            category: category,
                            subCategory: subCategory,
                            subject: subject
                        });
                        await newNotesData.save();
                        res.json({
                            status: true,
                            data: [newNotesData, { fileUploadLoc: fileLoc }],
                            msg: "added Notes details successfully",
                        });
                    } else {
                        res.json({
                            status: false,
                            data: null,
                            msg: "not an admin",
                        });
                    }
                }

            })
        } catch (error) {
            return res.json({
                status: false,
                data: null,
                msg: error.message
            })
        }
    }

);

//Deleting the Notes Details
AdminPanel.delete(
    "/DeleteNotesDetails/:id",
    ValidateToken,
    async (req, res) => {
        jwt.verify(req.token, process.env.SECRET_KEY, async (err, Data) => {
            if (err) {
                res.status(401).json({
                    err: err,
                    status: false,
                    data: null,
                    msg: "not an admin",
                });
            } else {
                const adminDetails = await findAdminTeacherUsingUserId(Data.studentId);
                if (
                    adminDetails.Role == "admin" ||
                    adminDetails.Role == "subadmin" ||

                    adminDetails.accessToContent.includes("Notes")
                ) {
                    const id = req.params.id;
                    const findNotesDetails = await NotesTable.findOne({
                        _id: id,
                    });
                    if (findNotesDetails) {
                        await NotesTable.findByIdAndDelete({ _id: id });
                        await savePanelEventLogs(
                            adminDetails._id,
                            "deleteNotes",
                            "delete",
                            findNotesDetails
                        )
                        res.json({
                            status: true,
                            data: null,
                            msg: "successfully deleted the Notes details",
                        });
                    } else {
                        res.json({
                            status: false,
                            data: null,
                            msg: "the Notes details not found ",
                        });
                    }
                } else {
                    res.json({
                        status: false,
                        data: null,
                        msg: "no authority to perform the specific task",
                    });
                }
            }
        });
    }
);

//Updating the Notes Details
AdminPanel.put(
    "/updatedNotesDetails/:id",
    ValidateToken,
    upload.single("file"),
    async (req, res) => {
        const { title, notes_type, is_active, language } = req.body;
        jwt.verify(req.token, process.env.ADMIN_SECRET_KEY, async (err, Data) => {
            if (err) {
                res.status(401).json({
                    err: err,
                    status: false,
                    data: null,
                    msg: "not an admin",
                });
            } else {
                const date = new Date(moment().add(5, "hours").add(30, "minutes"));
                const adminDetails = await findAdminTeacherUsingUserId(Data.studentId);
                if (
                    adminDetails.Role == "admin" ||
                    adminDetails.Role == "subadmin" ||

                    adminDetails.accessToContent.includes("Notes")
                ) {
                    const id = req.params.id;
                    const NotesDetails = await NotesTable.findOne({
                        _id: id,
                    });
                    if (NotesDetails) {
                        let FileUploadLocation;
                        let fileLoc;
                        let formatedDate = formatDate(date);
                        if (req.file) {
                            const helperString = Math.floor(Date.now() / 1000);
                            const filename = (req.file.originalname.split(".")[0]).replace(/\s+/g, '_').replace(/[^a-zA-Z0-9_]/g, '');
                            const extension = "." + req.file.originalname.split(".").pop();
                            FileUploadLocation = `Notes/${title?.replace(/\s+/g, '_').replace(/[^a-zA-Z0-9_]/g, '')}/${filename}_${helperString}${extension}`;
                            let fileLocHelper = await uploadFile(
                                req.file.path,
                                FileUploadLocation
                            );
                            fileLoc = fileDetails(req.file, fileLocHelper);
                        }
                        await NotesTable.findByIdAndUpdate(
                            { _id: id },
                            {
                                title: title,
                                file_url: fileLoc,
                                notes_type: notes_type,
                                language: language,
                                is_active: is_active,
                            },
                            {
                                runValidators: true,
                            }
                        );
                        res.json({
                            status: true,
                            data: id,
                            msg: "Updated the Notes details",
                        });
                    } else {
                        res.json({
                            status: false,
                            data: null,
                            msg: "Resource not found",
                        });
                    }
                } else {
                    res.json({
                        status: false,
                        data: null,
                        msg: "Admin details not found in database",
                    });
                }
            }
        });
    }
);

//get all the data from Resources table
AdminPanel.get("/getNewsClips", ValidateToken, async (req, res) => {
    const { language, category_id } = req.query;
    jwt.verify(req.token, process.env.SECRET_KEY, async (err, Data) => {
        if (err) {
            res.status(401).json({
                err: err,
                status: false,
                data: null,
                msg: "not an admin",
            });
        } else {
            const NewsClipDetails = await NewsClipsTable.find(
                {},
                { user: 0, __v: 0, category: 0 }
            );
            if (NewsClipDetails.length != 0) {
                if (language && !category_id) {
                    let NewsByLang = NewsClipDetails.filter((News) => {
                        return News.language == language;
                    });
                    res.json({
                        status: true,
                        data: NewsByLang,
                        msg: "fetched all the NewsClip table data",
                    });
                }
                //  else if (category_id && !language) {
                //     let NewsByCat = NewsClipDetails.filter((News) => {
                //         return News.category == category_id;
                //     });
                //     res.json({
                //         status: true,
                //         data: NewsByCat,
                //         msg: "Fetched the news Details ",
                //     });
                // } else if (language && category_id) {
                //     let NewsByCatandLang = NewsClipDetails.filter((News) => {
                //         return News.category == category_id && News.language == language;
                //     });
                //     res.json({
                //         status: true,
                //         data: NewsByCatandLang,
                //         msg: "Fetched the news Details ",
                //     });
                // } 
                else {
                    res.json({
                        status: true,
                        data: NewsClipDetails,
                        msg: "fetched all the NewsClip table data",
                    });
                }
            } else {
                res.json({
                    status: false,
                    data: NewsClipDetails,
                    msg: "No data found ",
                });
            }
        }
    });
});

//added data into the Resource table
AdminPanel.post(
    "/addNewsClips",
    ValidateToken,
    upload.single("file"),
    async (req, res) => {
        const { title, language, is_active, category_id } = req.body;
        jwt.verify(req.token, process.env.ADMIN_SECRET_KEY, async (err, Data) => {
            if (err) {
                res.status(401).json({
                    status: false,
                    data: null,
                    msg: err,
                });
            } else {
                const adminDetails = await findAdminTeacherUsingUserId(Data.studentId);
                const date = new Date(moment().add(5, "hours").add(30, "minutes"));
                let formatedDate = formatDate(date);
                if (
                    adminDetails.Role == "admin" ||
                    adminDetails.Role == "subadmin" ||

                    adminDetails.accessToContent.includes("News Clip")
                ) {
                    // const FindCategory = await categoryTable.findOne({
                    //     title: category_id,
                    // });
                    // if (!FindCategory) {
                    //     res.json({
                    //         status: false,
                    //         data: null,
                    //         msg: "Category not found",
                    //     });
                    // } else {
                    let FileUploadLocation;
                    let fileLoc;
                    if (req.file) {
                        const helperString = Math.floor(Date.now() / 1000);
                        const filename = (req.file.originalname.split(".")[0]).replace(/\s+/g, '_').replace(/[^a-zA-Z0-9_]/g, '');
                        const extension = "." + req.file.originalname.split(".").pop();
                        FileUploadLocation = `NewsClip/${title?.replace(/\s+/g, '_').replace(/[^a-zA-Z0-9_]/g, '')}/${filename}_${helperString}${extension}`;
                        fileLoc = await uploadFile(req.file.path, FileUploadLocation);
                    }
                    const filename = (req.file.originalname.split(".")[0]).replace(/\s+/g, '_').replace(/[^a-zA-Z0-9_]/g, '');
                    const newNewsClipData = new NewsClipsTable({
                        user: adminDetails._id,
                        file_url: {
                            fileLoc: fileLoc,
                            fileName: filename,
                            fileSize: `${(req.file.size / 1000000).toFixed(2)} MB`,
                        },
                        // category: FindCategory._id,
                        is_active: is_active,
                        title: title,
                        language: language,
                        created_at: formatedDate,
                    });
                    await newNewsClipData.save();
                    res.json({
                        status: true,
                        data: [newNewsClipData, { fileUploadLoc: fileLoc }],
                        msg: "added NewsClipData details successfully",
                    });
                    // }
                } else {
                    res.json({
                        status: false,
                        data: null,
                        msg: "not an admin",
                    });
                }
            }
        });
    }
);

//Deleting the Notes Details
AdminPanel.delete(
    "/DeleteNewsClipsDetails/:id",
    ValidateToken,
    async (req, res) => {
        jwt.verify(req.token, process.env.SECRET_KEY, async (err, Data) => {
            if (err) {
                res.status(401).json({
                    err: err,
                    status: false,
                    data: null,
                    msg: "not an admin",
                });
            } else {
                const adminDetails = await findAdminTeacherUsingUserId(Data.studentId);
                if (
                    adminDetails.Role == "admin" ||
                    adminDetails.Role == "subadmin" ||

                    adminDetails.accessToContent.includes("News Clip")
                ) {
                    const id = req.params.id;
                    const findNewsClipsDetails = await NewsClipsTable.findOne({
                        _id: id,
                    });
                    if (findNewsClipsDetails) {
                        await NewsClipsTable.findByIdAndDelete({
                            _id: id,
                        });
                        await savePanelEventLogs(
                            adminDetails._id,
                            "deleteNewsClip",
                            "delete",
                            NewsClipsTable
                        )
                        res.json({
                            status: true,
                            data: null,
                            msg: "successfully deleted the NewsClip details",
                        });
                    } else {
                        res.json({
                            status: false,
                            data: null,
                            msg: "the NewsClip details not found ",
                        });
                    }
                } else {
                    res.json({
                        status: false,
                        data: null,
                        msg: "no authority to perform the specific task",
                    });
                }
            }
        });
    }
);

//Updating the Notes Details
AdminPanel.put(
    "/updatedNewsClipsDetails/:id",
    ValidateToken,
    upload.single("file"),
    async (req, res) => {
        const { title, is_active, language } = req.body;
        jwt.verify(req.token, process.env.ADMIN_SECRET_KEY, async (err, Data) => {
            if (err) {
                res.status(401).json({
                    err: err,
                    status: false,
                    data: null,
                    msg: "not an admin",
                });
            } else {
                const date = new Date(moment().add(5, "hours").add(30, "minutes"));
                const adminDetails = await findAdminTeacherUsingUserId(Data.studentId);
                if (
                    adminDetails.Role == "admin" ||
                    adminDetails.Role == "subadmin" ||

                    adminDetails.accessToContent.includes("News Clip")
                ) {
                    const id = req.params.id;
                    const NewsClipsDetails = await NewsClipsTable.findOne({ _id: id });
                    if (NewsClipsDetails) {
                        let FileUploadLocation;
                        let fileLoc;
                        if (req.file) {
                            const helperString = Math.floor(Date.now() / 1000);
                            const filename = (req.file.originalname.split(".")[0]).replace(/\s+/g, '_').replace(/[^a-zA-Z0-9_]/g, '');
                            const extension = "." + req.file.originalname.split(".").pop();
                            FileUploadLocation = `NewsClip/${title?.replace(/\s+/g, '_').replace(/[^a-zA-Z0-9_]/g, '')}/${filename}_${helperString}${extension}`;
                            let fileLocHelper = await uploadFile(
                                req.file.path,
                                FileUploadLocation
                            );
                            fileLoc = fileDetails(req.file, fileLocHelper);
                        }
                        await NewsClipsTable.findByIdAndUpdate(
                            { _id: id },
                            {
                                title: title,
                                file_url: fileLoc,
                                is_active: is_active,
                                language: language,
                            },
                            {
                                runValidators: true,
                            }
                        );
                        res.json({
                            status: true,
                            data: id,
                            msg: "Updated the NewsClips details",
                        });
                    } else {
                        res.json({
                            status: false,
                            data: null,
                            msg: "NewsClips not found",
                        });
                    }
                } else {
                    res.json({
                        status: false,
                        data: null,
                        msg: "Admin details not found in database",
                    });
                }
            }
        });
    }
);

//get all the data from Resources table
AdminPanel.get("/getallindiaradio", ValidateToken, async (req, res) => {
    const { language } = req.query;
    jwt.verify(req.token, process.env.SECRET_KEY, async (err, Data) => {
        if (err) {
            res.status(401).json({
                err: err,
                status: false,
                data: null,
                msg: "not an user",
            });
        } else {
            const AIRDETAILS = await AIRTable.find({});
            if (AIRDETAILS.length != 0) {
                if (language) {
                    let AIRBYLANG = AIRDETAILS.filter((AIR) => {
                        return AIR.language == language;
                    });
                    res.json({
                        status: true,
                        data: AIRBYLANG,
                        msg: "fetched all the AIR details based on language ",
                    });
                } else {
                    res.json({
                        status: true,
                        data: AIRDETAILS,
                        msg: "fetched all the AIR details",
                    });
                }
            } else {
                res.json({
                    status: false,
                    data: null,
                    msg: "No data found ",
                });
            }
        }
    });
});

//added data into the Resource table
AdminPanel.post(
    "/addAIRdetails",
    ValidateToken,
    upload.single("file"),
    async (req, res) => {
        const { audio_file, language, data, is_active } = req.body;
        jwt.verify(req.token, process.env.ADMIN_SECRET_KEY, async (err, Data) => {
            if (err) {
                res.status(401).json({
                    status: false,
                    data: null,
                    msg: err,
                });
            } else {
                const adminDetails = await findAdminTeacherUsingUserId(Data.studentId);
                const date = new Date(moment().add(5, "hours").add(30, "minutes"));
                let formatedDate = formatDate(date);
                if (
                    adminDetails.Role == "admin" ||
                    adminDetails.Role == "subadmin" ||

                    adminDetails.accessToContent.includes("AIR")
                ) {
                    let FileUploadLocation;
                    let fileLoc;
                    if (req.file) {
                        const helperString = Math.floor(Date.now() / 1000);
                        const filename = (req.file.originalname.split(".")[0]).replace(/\s+/g, '_').replace(/[^a-zA-Z0-9_]/g, '');
                        const extension = "." + req.file.originalname.split(".").pop();
                        FileUploadLocation = `AIR/${language}/${filename}_${helperString}${extension}`;
                        let fileLocHelper = await uploadFile(
                            req.file.path,
                            FileUploadLocation
                        );
                        fileLoc = fileDetails(req.file, fileLocHelper);
                    }
                    const newAIRData = new AIRTable({
                        user: adminDetails._id,
                        data: data,
                        is_active: is_active,
                        audio_file: fileLoc,
                        language: language,
                        created_at: formatedDate,
                    });
                    await newAIRData.save();
                    res.json({
                        status: true,
                        data: [newAIRData, { fileUploadLoc: fileLoc }],
                        msg: "added AIR details successfully",
                    });
                } else {
                    res.json({
                        status: false,
                        data: null,
                        msg: "not an admin",
                    });
                }
            }
        });
    }
);

//Deleting the Notes Details
AdminPanel.delete(
    "/DeleteAllIndiaRadioDetails/:id",
    ValidateToken,
    async (req, res) => {
        jwt.verify(req.token, process.env.SECRET_KEY, async (err, Data) => {
            if (err) {
                res.status(401).json({
                    err: err,
                    status: false,
                    data: null,
                    msg: "not an admin",
                });
            } else {
                const adminDetails = await findAdminTeacherUsingUserId(Data.studentId);
                if (
                    adminDetails.Role == "admin" ||
                    adminDetails.Role == "subadmin" ||

                    adminDetails.accessToContent.includes("AIR")
                ) {
                    const id = req.params.id;
                    const findAIRDetails = await AIRTable.findOne({
                        _id: id,
                    });
                    if (findAIRDetails) {
                        await AIRTable.findByIdAndDelete({ _id: id });
                        await savePanelEventLogs(
                            adminDetails._id,
                            "deleteAIR",
                            "delete",
                            findAIRDetails
                        )
                        res.json({
                            status: true,
                            data: null,
                            msg: "successfully deleted the AllIndiaRadio details",
                        });
                    } else {
                        res.json({
                            status: false,
                            data: null,
                            msg: "the AllIndiaRadio details not found ",
                        });
                    }
                } else {
                    res.json({
                        status: false,
                        data: null,
                        msg: "no authority to perform the specific task",
                    });
                }
            }
        });
    }
);

//Updating the Notes Details
AdminPanel.put(
    "/updatedAllIndiaRadioDetails/:id",
    ValidateToken,
    upload.single("file"),
    async (req, res) => {
        const { data, audio_file, is_active, language } = req.body;
        jwt.verify(req.token, process.env.ADMIN_SECRET_KEY, async (err, Data) => {
            if (err) {
                res.status(401).json({
                    err: err,
                    status: false,
                    data: null,
                    msg: "not an admin",
                });
            } else {
                const date = new Date(moment().add(5, "hours").add(30, "minutes"));
                const adminDetails = await findAdminTeacherUsingUserId(Data.studentId);
                if (
                    adminDetails.Role == "admin" ||
                    adminDetails.Role == "subadmin" ||

                    adminDetails.accessToContent.includes("AIR")
                ) {
                    const id = req.params.id;
                    const AIRDetails = await AIRTable.findOne({
                        _id: id,
                    });
                    if (AIRDetails) {
                        let FileUploadLocation;
                        let fileLoc;
                        if (req.file) {
                            const helperString = Math.floor(Date.now() / 1000);
                            const filename = (req.file.originalname.split(".")[0]).replace(/\s+/g, '_').replace(/[^a-zA-Z0-9_]/g, '');
                            const extension = "." + req.file.originalname.split(".").pop();
                            FileUploadLocation = `AIR/${language}/${filename}_${helperString}${extension}`;
                            let fileLocHelper = await uploadFile(
                                req.file.path,
                                FileUploadLocation
                            );
                            fileLoc = fileDetails(req.file, fileLocHelper);
                        }
                        await AIRTable.findByIdAndUpdate(
                            { _id: id },
                            {
                                language: language,
                                audio_file: fileLoc,
                                is_active: is_active,
                                data: data,
                            },
                            {
                                runValidators: true,
                            }
                        );
                        res.json({
                            status: true,
                            data: id,
                            msg: "Updated the All India Radio details",
                        });
                    } else {
                        res.json({
                            status: false,
                            data: null,
                            msg: "All India Radio not found",
                        });
                    }
                } else {
                    res.json({
                        status: false,
                        data: null,
                        msg: "Admin details not found in database",
                    });
                }
            }
        });
    }
);

//Fetching the Batches Details
AdminPanel.get("/getBatchesDetails", ValidateToken, async (req, res) => {
    let { Category, id, language, teacher_id, stream, exam_type, page, pageSize } = req.query;
    jwt.verify(req.token, process.env.SECRET_KEY, async (err, Data) => {
        if (err) {
            res.status(401).json({
                err: err,
                status: false,
                data: null,
                msg: "not an admin",
            });
        } else {
            page = parseInt(page) || 1;
            pageSize = parseInt(pageSize) || 300;
            let BatchesDetails;
            const user = await findUserByUserId(Data.studentId);
            const TeacherDetails = await findAdminTeacherUsingUserId(Data.studentId);
            if (user) {
                const userBatches = await MybatchTable.find({
                    user: user._id,
                }).sort({ createdAt: -1 });
                let checkArray = [];
                for (let i = 0; i < userBatches.length; i++) {
                    checkArray.push(userBatches[i].batch_id);
                }
                BatchesDetails = await BatchesTable.find(
                    { _id: { $nin: checkArray }, is_active: true },
                    { user: 0, __v: 0 }
                )
                    .populate({
                        path: 'teacher',
                        select: "FullName profilePhoto",
                        populate: {
                            path: 'subject',
                            select: 'title'
                        }
                    })
                    .populate("subject", { _id: 1, title: 1 }).sort({ createdAt: -1 }).skip((page - 1) * pageSize).limit(pageSize);
            } else {
                BatchesDetails = await BatchesTable.find({}, { user: 0, __v: 0 })
                    .populate({
                        path: 'teacher',
                        select: "FullName profilePhoto",
                        populate: {
                            path: 'subject',
                            select: 'title'
                        }
                    })
                    .populate("subject", { _id: 1, title: 1 }).sort({ createdAt: -1 }).skip((page - 1) * pageSize).limit(pageSize);
            }
            if (BatchesDetails) {
                if (id && !language && !teacher_id && !stream) {
                    let BatchesDetailsTeacher;
                    if (user) {
                        BatchesDetailsTeacher = await BatchesTable.find({
                            _id: id,
                            is_active: true,
                        })
                            .populate({
                                path: 'teacher',
                                select: "FullName profilePhoto",
                                populate: {
                                    path: 'subject',
                                    select: 'title'
                                }
                            })
                            .populate("subject", { _id: 1, title: 1 }).sort({ createdAt: -1 }).skip((page - 1) * pageSize).limit(pageSize);
                    } else if (TeacherDetails) {
                        BatchesDetailsTeacher = await BatchesTable.find({
                            _id: id,
                        })

                            .populate({
                                path: 'teacher',
                                select: "FullName profilePhoto",
                                populate: {
                                    path: 'subject',
                                    select: 'title'
                                }
                            })
                            .populate("subject", { _id: 1, title: 1 })
                            .populate('category', '_id title slug')
                            .populate('subCategory', '_id title slug')
                            .populate('features', 'feature')
                            .sort({ createdAt: -1 }).skip((page - 1) * pageSize).limit(pageSize);
                    }
                    // console.log(BatchesDetailsTeacher);
                    res.json({
                        status: true,
                        // data: BatchesDetailsTeacher,
                        data: await Promise.all(BatchesDetailsTeacher?.map(async (item) => {
                            const validities = await ValidityTable.find({ batch: item?._id })
                            return {
                                ...item?._doc,
                                category: item?.category?.map((item) => {
                                    return item?._id
                                }),
                                subCategory: item?.subCategory?.map((item) => {
                                    return item?._id
                                }),
                                categoryDetails: item?.category,
                                subCategoryDetails: item?.subCategory,
                                // validity : validities?.map((item2) => {
                                //     return  item2?.month
                                // })
                                features: item?.features?.reduce((acc, curr, index) => {
                                    return (index == item?.features.length - 1) ? acc + (String(curr?.feature).charAt(0).toUpperCase() + curr?.feature.slice(1)) +
                                        "" : acc + (String(curr?.feature).charAt(0).toUpperCase() + curr?.feature.slice(1)) + ", "
                                }, ""),
                                validities: validities?.map((item2) => {
                                    return `Month : ${item2?.month}  Sale Price : ${item2?.salePrice} Regular Price : ${item2?.regularPrice}`
                                })
                            }
                        })),
                        msg: "Batches Details Fetched successfully",
                    });
                } else if (id && !language && !teacher_id && !stream) {
                    let filterdArray = BatchesDetails.filter((Banners) => {
                        return Banners._id == id;
                    });
                    res.json({
                        status: true,
                        data: filterdArray,
                        msg: "Batches Details Fetched successfully",
                    });
                } else if (id && language && !teacher_id && !stream) {
                    let filterdArray = BatchesDetails.filter((Banners) => {
                        return Banners._id == id && Banners.language == language;
                    });
                    res.json({
                        status: true,
                        data: filterdArray,
                        msg: "Batches Details Fetched successfully",
                    });
                } else if (!id && language && !teacher_id && !stream) {
                    let filterdArray = BatchesDetails.filter((Banners) => {
                        return Banners.language == language;
                    });
                    res.json({
                        status: true,
                        data: filterdArray,
                        msg: "Batches Details Fetched successfully",
                    });
                } else if (teacher_id && !id && !language && !stream) {
                    const isSubAdmin = await adminTeacherTable.findOne({
                        _id: teacher_id,
                        Role: "subadmin",
                    });
                    // subadmin batch list
                    if (isSubAdmin) {
                        res.json({
                            status: false,
                            data: BatchesDetails,
                            msg: "fetched all the batches based on the subadmin",
                        });
                    } else {
                        // teacher batch list
                        let FilterTeacher = BatchesDetails.filter((Batch) => {
                            let check = false;
                            for (let i = 0; i < Batch.teacher.length; i++) {
                                if (Batch.teacher[i]._id == teacher_id) {
                                    check = true;
                                    break;
                                }
                            }
                            return check == true;
                        });
                        res.json({
                            status: false,
                            data: FilterTeacher,
                            msg: "fetched all the batches based on the teacher",
                        });
                    }
                } else if (teacher_id && id && !language && !stream) {
                    let FilterTeacherCategory = BatchesDetails.filter((Batch) => {
                        let check = false;
                        for (let i = 0; i < Batch.teacher.length; i++) {
                            if (Batch.teacher[i]._id == teacher_id) {
                                check = true;
                                break;
                            }
                        }
                        return check == true && Batch._id == id;
                    });
                    res.json({
                        status: false,
                        data: FilterTeacherCategory,
                        msg: "fetched all the batches details",
                    });
                } else if (teacher_id && language && !id && !stream) {
                    let FilterTeacherCategory = BatchesDetails.filter((Batch) => {
                        let check = false;
                        for (let i = 0; i < Batch.teacher.length; i++) {
                            if (Batch.teacher[i]._id == teacher_id) {
                                check = true;
                                break;
                            }
                        }
                        return check == true && Batch.language == language;
                    });
                    res.json({
                        status: false,
                        data: FilterTeacherCategory,
                        msg: "fetched all the batches details",
                    });
                } else if (teacher_id && id && language && !stream) {
                    let FilterTeacherCategory = BatchesDetails.filter((Batch) => {
                        let check = false;
                        for (let i = 0; i < Batch.teacher.length; i++) {
                            if (Batch.teacher[i]._id == teacher_id) {
                                check = true;
                                break;
                            }
                        }
                        return (
                            check == true && Batch._id == id && Batch.language == language
                        );
                    });
                    res.json({
                        status: false,
                        data: FilterTeacherCategory,
                        msg: "fetched all the batches details",
                    });
                } else if (id && !language && !teacher_id && stream) {
                    let finalBatchesArray = [];
                    for (let i = 0; i < stream.length; i++) {
                        let filterdArray;
                        if (exam_type) {
                            filterdArray = BatchesDetails.filter((Batch) => {
                                return (
                                    Batch._id == id &&
                                    Batch.stream == stream[i] &&
                                    Batch.exam_type == exam_type
                                );
                            });
                        } else {
                            filterdArray = BatchesDetails.filter((Batch) => {
                                return Batch._id == id && Batch.stream == stream[i];
                            });
                        }
                        // console.log(filterdArray)
                        finalBatchesArray.push(...filterdArray);
                    }
                    // const
                    res.json({
                        status: true,
                        data: finalBatchesArray,
                        msg: "Batches Details Fetched successfully",
                    });
                } else if (!id && language && !teacher_id && stream) {
                    let finalBatchesArray = [];
                    for (let i = 0; i < stream.length; i++) {
                        let filterdArray;
                        if (exam_type) {
                            filterdArray = BatchesDetails.filter((Batch) => {
                                return (
                                    Batch.language == language &&
                                    Batch.stream == stream[i] &&
                                    Batch.exam_type == exam_type
                                );
                            });
                        } else {
                            filterdArray = BatchesDetails.filter((Batch) => {
                                return Batch.language == language && Batch.stream == stream[i];
                            });
                        }
                        // console.log(filterdArray)
                        finalBatchesArray.push(...filterdArray);
                    }
                    // const
                    res.json({
                        status: true,
                        data: finalBatchesArray,
                        msg: "Batches Details Fetched successfully",
                    });
                } else if (!id && !language && teacher_id && stream) {
                    let finalBatchesArray = [];
                    for (let i = 0; i < stream.length; i++) {
                        let filterdArray;
                        if (exam_type) {
                            filterdArray = BatchesDetails.filter((Batch) => {
                                let check = false;
                                for (let i = 0; i < Batch.teacher.length; i++) {
                                    if (Batch.teacher[i]._id == teacher_id) {
                                        check = true;
                                        break;
                                    }
                                }
                                return (
                                    check == true &&
                                    Batch.stream == stream[i] &&
                                    Batch.exam_type == exam_type
                                );
                            });
                        } else {
                            filterdArray = BatchesDetails.filter((Batch) => {
                                let check = false;
                                for (let i = 0; i < Batch.teacher.length; i++) {
                                    if (Batch.teacher[i]._id == teacher_id) {
                                        check = true;
                                        break;
                                    }
                                }
                                return check == true && Batch.stream == stream[i];
                            });
                        }
                        // console.log(filterdArray)
                        finalBatchesArray.push(...filterdArray);
                    }
                    // const
                    res.json({
                        status: true,
                        data: finalBatchesArray,
                        msg: "Batches Details Fetched successfully",
                    });
                } else if (id && !language && teacher_id && stream) {
                    let finalBatchesArray = [];
                    for (let i = 0; i < stream.length; i++) {
                        let filterdArray;
                        if (exam_type) {
                            filterdArray = BatchesDetails.filter((Batch) => {
                                let check = false;
                                for (let i = 0; i < Batch.teacher.length; i++) {
                                    if (Batch.teacher[i]._id == teacher_id) {
                                        check = true;
                                        break;
                                    }
                                }
                                return (
                                    check == true &&
                                    Batch._id == id &&
                                    Batch.stream == stream[i] &&
                                    Batch.exam_type == exam_type
                                );
                            });
                        } else {
                            filterdArray = BatchesDetails.filter((Batch) => {
                                let check = false;
                                for (let i = 0; i < Batch.teacher.length; i++) {
                                    if (Batch.teacher[i]._id == teacher_id) {
                                        check = true;
                                        break;
                                    }
                                }
                                return (
                                    check == true && Batch._id == id && Batch.stream == stream[i]
                                );
                            });
                        }
                        // console.log(filterdArray)
                        finalBatchesArray.push(...filterdArray);
                    }
                    // const
                    res.json({
                        status: true,
                        data: finalBatchesArray,
                        msg: "Batches Details Fetched successfully",
                    });
                } else if (!id && language && teacher_id && stream) {
                    let finalBatchesArray = [];
                    for (let i = 0; i < stream.length; i++) {
                        let filterdArray;
                        if (exam_type) {
                            filterdArray = BatchesDetails.filter((Batch) => {
                                let check = false;
                                for (let i = 0; i < Batch.teacher.length; i++) {
                                    if (Batch.teacher[i]._id == teacher_id) {
                                        check = true;
                                        break;
                                    }
                                }
                                return (
                                    check == true &&
                                    Batch.language == language &&
                                    Batch.stream == stream[i] &&
                                    Batch.exam_type == exam_type
                                );
                            });
                        } else {
                            filterdArray = BatchesDetails.filter((Batch) => {
                                let check = false;
                                for (let i = 0; i < Batch.teacher.length; i++) {
                                    if (Batch.teacher[i]._id == teacher_id) {
                                        check = true;
                                        break;
                                    }
                                }
                                return (
                                    check == true &&
                                    Batch.language == language &&
                                    Batch.stream == stream[i]
                                );
                            });
                        }
                        // console.log(filterdArray)
                        finalBatchesArray.push(...filterdArray);
                    }
                    // const
                    res.json({
                        status: true,
                        data: finalBatchesArray,
                        msg: "Batches Details Fetched successfully",
                    });
                } else if (!id && !language && !teacher_id && stream) {
                    let finalBatchesArray = [];
                    for (let i = 0; i < stream.length; i++) {
                        let filterdArray;
                        if (exam_type) {
                            filterdArray = BatchesDetails.filter((Batch) => {
                                return (
                                    Batch.stream == stream[i] && Batch.exam_type == exam_type
                                );
                            });
                        } else {
                            filterdArray = BatchesDetails.filter((Batch) => {
                                return Batch.stream == stream[i];
                            });
                        }
                        // console.log(filterdArray)
                        finalBatchesArray.push(...filterdArray);
                    }
                    // const
                    res.json({
                        status: true,
                        data: finalBatchesArray,
                        msg: "Batches Details Fetched successfully",
                    });
                } else {
                    // let filterdArrayfinal = [];
                    // if (user) {
                    //   for (let i = 0; i < user.Stream.length; i++) {
                    //     let filterdArray = BatchesDetails.filter((Batch) => {
                    //       return (
                    //         Batch.stream == user.Stream[i]
                    //       );
                    //     });
                    //     // console.log(user.Stream)
                    //     filterdArrayfinal.push(...filterdArray);
                    //   }
                    // } else {
                    //   filterdArrayfinal = BatchesDetails;
                    // }
                    res.json({
                        status: true,
                        data: BatchesDetails,
                        msg: "Batches Details Fetched student successfully ",
                    });
                }
            } else {
                res.json({
                    status: false,
                    data: [],
                    msg: "No data found the Batches table",
                });
            }
        }
    });
});

// getBatch details 
AdminPanel.get("/getBatches", isAdmin, async (req, res) => {
    try {
        const decoded = jwt.verify(req.token, process.env.ADMIN_SECRET_KEY);
        const adminDetails = await findAdminTeacherUsingUserId(decoded.studentId);
        if (!adminDetails) {
            return res.json({
                status: false,
                data: null,
                msg: "Not an admin",
            });
        }
        console.log(adminDetails.Role);
        const allowedAdmins = [
            // "86df1fe0-21cc-11f0-a0f3-a741f85a7bb0", //Atul
            "47a585d0-8d43-11ef-ae6c-4f94e78fc8db", // Akasnsha
            "0baa4580-648d-11f0-8325-39b97643a69b" //Dinesh
          ];
        var batches = [];
        const { userId } = adminDetails;
        if (allowedAdmins.includes(userId)) {
            batches = await BatchesTable.find({is_active: true}).populate("user", "_id FullName Role").populate("features", '_id feature icon isActive').sort({ is_active: -1, createdAt: -1, batchOrder: 1 }).collation({ locale: "en_US", numericOrdering: true });
        } else {
            batches = await BatchesTable.find({}).populate("user", "_id FullName Role").populate("features", '_id feature icon isActive').sort({ is_active: -1, createdAt: -1, batchOrder: 1 }).collation({ locale: "en_US", numericOrdering: true });
        }
        return res.json({
            status: true,
            data: batches.map((item) => {
                return {
                    ...item._doc, id: item._id, value: item?._id, name: item?.batch_name, label: item?.batch_name, batchId: item?.batchId ?? "",
                    features: item?.features?.filter((item2) => item2.isActive != false).map((item2) => {
                        return {
                            value: item2?._id,
                            label: item2?.feature,
                            featureId: item2?._id ?? "",
                            feature: item2?.feature ?? "",
                        }
                    }),
                }

            }),
            msg: 'Batches fetched'
        })

    } catch (error) {
        return res.json({
            status: false,
            data: null,
            msg: error.message
        })
    }
})

AdminPanel.get(
    "/getBatchDetailsWithId/:id",
    ValidateToken,
    async (req, res) => {
        const { id } = req.params;
        jwt.verify(req.token, process.env.SECRET_KEY, async (err, Data) => {
            if (err) {
                res.status(401).json({
                    err: err,
                    status: false,
                    data: null,
                    msg: "not an admin",
                });
            } else {
                const user = await findUserByUserId(Data.studentId);
                const batchDetails = await BatchesTable.findOne(
                    { _id: id, is_active: true },
                    { user: 0, __v: 0 }
                ).populate("subject", { title: 1 })
                    .populate({
                        path: 'teacher',
                        select: "FullName profilePhoto qualification demoVideo",
                        populate: {
                            path: 'subject',
                            select: 'title'
                        }
                    }).populate([{ path: 'faqs', select: 'question answer', strictPopulate: false }])
                    .populate('features', '_id feature icon isActive order');



                if (batchDetails) {
                    const countRecordedVideos = await LectureTable.countDocuments({
                        batch: id,
                        LiveOrRecorded: 'Recorded'
                    });
                    // const lectureResoursceDetails = await LectureResourceTable.find({
                    //   batch: id,
                    // });
                    const isExist = await MybatchTable.findOne({ batch_id: batchDetails._id, user: user?._id });
                    let batchObj = { ...batchDetails?._doc };
                    delete batchObj.features;
                    // console.log( batchObj);
                    res.json({
                        status: true,
                        data: {
                            batchDetails: {
                                // ...batchDetails?._doc, 
                                ...batchObj,
                                featureVideo: {
                                    videoType: batchObj?.featureVideo?.videoType ?? "",
                                    url: batchObj?.featureVideo?.url ?? ""
                                },
                                shareLink: "",
                                batchFeatures: batchDetails?.features?.filter((item) => item.isActive != false).sort((a, b) => a.order - b.order).map((item) => {
                                    return {
                                        featureId: item?._id ?? "",
                                        icon: item?.icon ?? "",
                                        feature: item?.feature ?? "",
                                    }
                                }),
                                shareUrl: { link: batchDetails?.shareLink?.link ?? "", text: batchDetails?.shareLink?.text ?? "" },
                                featureVideo: {
                                    videoType: batchObj?.featureVideo?.videoType ?? "yt",//yt , upload
                                    url: batchObj?.featureVideo?.url ?? "https://www.youtube.com/watch?v=iWTDZdv9llw" //https://static.sdcampus.com/videos/doubt_community.mp4
                                },
                            },
                            NoOfVideos: countRecordedVideos,
                            NoofNotes: 0,
                        },
                        msg: "Fectched the batch details",
                        isPurchase: isExist ? true : false,
                    });
                } else {
                    res.json({
                        status: false,
                        data: null,
                        msg: "Batch Details not found",
                        isPurchase: false,
                    });
                }
            }
        });
    }
);

//Adding the Batches Details
AdminPanel.post(
    "/addBatchesDetails",
    ValidateToken,
    // upload.single("file"),
    upload.fields([
        {
            name: "file",
            maxCount: 1,
        },
        {
            name: "demoVideo",
            maxCount: 3,
        },
        {
            name: 'file1',
            maxCount: 1,
        },
        {
            name: 'featureVideoFile',
            maxCount: 1,
        }
    ]),
    // upload.single('file2'),
    async (req, res) => {
        try {
            let {
                batch_name,
                exam_type,
                subject,
                starting_date,
                ending_date,
                mode,
                demoVideoLink,
                isPaid,
                discount,
                charges,
                metaTitle,
                metaDesc,
                description,
                teacher,
                language,
                is_active,
                stream,
                remark,
                materials,
                validity,
                course_review,
                bannerfileType,
                demoVideoType,
                isCoinApplicable,
                maxAllowedCoins,
                isEmi,
                emiOptions,
                category,
                subCategory,
                featureVideoType,
                featureVideoFile
            } = req.body;
            // console.log(featureVideoType, featureVideoFile);
            if (!metaDesc || !metaTitle) {
                return res.json({
                    status: false,
                    data: null,
                    msg: "Meta Description Required"
                })
            }
            const ytCheck = /^(?:https?:\/\/)?(?:www\.)?(?:youtube\.com\/(?:watch\?v=|embed\/|v\/|shorts\/)|youtu\.be\/)([a-zA-Z0-9_-]{11})(?:\S+)?$/;
            let featureVideo = {
                videoType: "yt", // yt , upload
                url: "https://www.youtube.com/watch?v=iWTDZdv9llw",
            }
            if (featureVideoType == 'yt') {
                // console.log(ytCheck.test(featureVideoFile))
                if (!ytCheck.test(featureVideoFile)) {
                    return res.json({
                        status: false,
                        data: null,
                        msg: `Provide Youtube url for feature video.`
                    })
                } else {
                    featureVideo = {
                        videoType: "yt", // yt , upload
                        url: featureVideoFile,
                    }
                }

            } else if (featureVideoType == 'upload') {
                // console.log(req.files);
                if (req.files.featureVideoFile) {
                    const helperString = Math.floor(Date.now() / 1000);
                    const filename = (req.files.featureVideoFile[0].originalname.split(".")[0]).replace(/\s+/g, '_').replace(/[^a-zA-Z0-9_]/g, '');
                    const extension = "." + req.files.featureVideoFile[0].originalname.split(".").pop();
                    let FileUploadLocation = `Batches/${batch_name?.replace(/\s+/g, '_').replace(/[^a-zA-Z0-9_]/g, '')}/${filename}_${helperString}${extension}`;;
                    let fileLocHelper = await uploadFile(
                        req.files.featureVideoFile[0].path,
                        FileUploadLocation
                    );
                    featureVideo = {
                        videoType: "upload", // yt , upload
                        url: fileLocHelper,
                    }
                } else {
                    return res.json({
                        status: false,
                        data: null,
                        msg: 'Please Upload Feature Video'
                    })
                }
            } else {
                featureVideo = {
                    videoType: "yt", // yt , upload
                    url: "https://www.youtube.com/watch?v=iWTDZdv9llw",
                }
            }

            if (isEmi == 'true' && emiOptions.length < 2) {
                return res.json({
                    status: false,
                    data: null,
                    msg: 'Emi Options should be more than one'
                })
            }
            if (discount && charges) {
                if (parseFloat(charges) < parseFloat(discount)) {
                    return res.json({
                        status: false,
                        data: null,
                        msg: `Discount Price must lower or equal to regular price`
                    })
                }
            } else {
                discount = charges
            }

            jwt.verify(req.token, process.env.ADMIN_SECRET_KEY, async (err, Data) => {
                if (err) {
                    res.status(401).json({
                        status: false,
                        data: null,
                        msg: err,
                    });
                } else {
                    const adminDetails = await findAdminTeacherUsingUserId(Data.studentId);
                    const date = new Date(moment().add(5, "hours").add(30, "minutes"));
                    let formatedDate = formatDate(date);
                    if (
                        adminDetails.Role == "admin" ||
                        adminDetails.Role == "subadmin" ||

                        adminDetails.accessToContent.includes("Add Batch")
                    ) {
                        let FileUploadLocation;
                        let fileLoc;
                        let DemoVideoUploadLocation;
                        let DemoVideoLoc = [];
                        let planner;
                        // console.log(req.files.file[0])
                        if (req.files) {
                            if (req.files.file) {
                                let size = req.files.file[0].size / (1024);
                                if (size > 100) {
                                    return res.json({
                                        status: false,
                                        data: null,
                                        msg: 'Maximum banner size 100KB allowed'
                                    })
                                }
                                const helperString = Math.floor(Date.now() / 1000);
                                const filename = (req.files.file[0].originalname.split(".")[0]).replace(/\s+/g, '_').replace(/[^a-zA-Z0-9_]/g, '');
                                const extension =
                                    "." + req.files.file[0].originalname.split(".").pop();
                                FileUploadLocation = `Batches/${batch_name?.replace(/\s+/g, '_').replace(/[^a-zA-Z0-9_]/g, '')}/${filename}_${helperString}${extension}`;
                                let fileLocHelper = await uploadFile(
                                    req.files.file[0].path,
                                    FileUploadLocation
                                );
                                fileLoc = {
                                    fileLoc: fileLocHelper,
                                    fileName: filename,
                                    fileSize: `${(req.files.file[0].size / 1000000).toFixed(2)} MB`,
                                    bannerfileType: bannerfileType,
                                };
                            }
                            if (req.files.file1) {
                                const helperString = Math.floor(Date.now() / 1000);
                                const filename = (req.files.file1[0].originalname.split(".")[0]).replace(/\s+/g, '_').replace(/[^a-zA-Z0-9_]/g, '');
                                const extension = "." + req.files.file1[0].originalname.split(".").pop();
                                FileUploadLocation = `Batches/${batch_name?.replace(/\s+/g, '_').replace(/[^a-zA-Z0-9_]/g, '')}/${filename}_${helperString}${extension}`;;
                                let fileLocHelper = await uploadFile(
                                    req.files.file1[0].path,
                                    FileUploadLocation
                                );
                                planner = fileDetails(req.files.file1[0], fileLocHelper);
                            }
                            if (req.files.demoVideo) {
                                for (let j = 0; j < req.files.demoVideo.length; j++) {
                                    // console.log(req.files.demoVideo[j].originalname);
                                    const helperString1 = Math.floor(Date.now() / 1000);
                                    const filename1 =
                                        (req.files.demoVideo[j].originalname.split(".")[0]).replace(/\s+/g, '_').replace(/[^a-zA-Z0-9_]/g, '');
                                    const extension1 =
                                        "." + req.files.demoVideo[j].originalname.split(".").pop();
                                    DemoVideoUploadLocation = `Batches/${batch_name?.replace(/\s+/g, '_').replace(/[^a-zA-Z0-9_]/g, '')}/DemoVideos/${filename1}_${helperString1}${extension1}`;
                                    // console.log("Demo "+DemoVideoUploadLocation)
                                    let fileLocHelper1 = await uploadFile(
                                        req.files.demoVideo[j].path,
                                        DemoVideoUploadLocation
                                    );
                                    // console.log(fileLocHelper1)

                                    let helperDemoVideoLoc = {
                                        fileLoc: fileLocHelper1,
                                        fileName: filename1,
                                        fileSize: `${(req.files.demoVideo[j].size / 1000000).toFixed(
                                            2
                                        )} MB`,
                                        DemoVideofileType: demoVideoType,
                                    };
                                    DemoVideoLoc.push(helperDemoVideoLoc);
                                }
                            } else {
                                if (typeof demoVideoLink == "string") {
                                    let helperDemoVideoLoc = {
                                        fileLoc: demoVideoLink,
                                        fileName: " ",
                                        fileSize: ` `,
                                        DemoVideofileType: demoVideoType,
                                    };
                                    DemoVideoLoc.push(helperDemoVideoLoc);
                                } else {
                                    for (let i = 0; i < demoVideoLink.length; i++) {
                                        let helperDemoVideoLoc = {
                                            fileLoc: demoVideoLink[i],
                                            fileName: " ",
                                            fileSize: ` `,
                                            DemoVideofileType: demoVideoType,
                                        };
                                        DemoVideoLoc.push(helperDemoVideoLoc);
                                    }
                                }
                            }
                        }
                        let categoriesId = category?.filter((item) => item != "");
                        let subCategoriesId = subCategory?.filter((item) => item != "");
                        // console.log( categoriesId , subCategoriesId);
                        let batchId = await getLatestBatchId();
                        // console.log(batchId);
                        // console.log(validity)
                        let slug = await generateSlug(batch_name);
                        const newBatchDetails = await new BatchesTable({
                            user: adminDetails._id,
                            batch_name: batch_name,
                            slug,
                            subject: subject,
                            exam_type: exam_type,
                            starting_date: starting_date,
                            ending_date: ending_date,
                            materials: materials,
                            isPaid,
                            charges: charges,
                            discount: discount,
                            is_active: is_active,
                            description: description,
                            banner: [fileLoc],
                            language: language,
                            teacher: teacher,
                            demoVideo: DemoVideoLoc,
                            remark: remark,
                            validity: validity,
                            course_review: course_review,
                            mode: mode,
                            stream: stream,
                            created_at: formatedDate,
                            isCoinApplicable,
                            maxAllowedCoins,
                            metaTitle,
                            metaDesc,
                            planner: planner,
                            isEmi,
                            emiOptions,
                            subCategory: subCategoriesId,
                            category: categoriesId,
                            batchId,
                            featureVideo
                        });
                        const savedBatch = await newBatchDetails.save();
                        let link = `https://www.sdcampus.com?route=${`batchbyid`}&rootId=${savedBatch?._id}&childId=null`
                        let details = {
                            "link": link ?? "",
                            "utmSource": "web_app",
                            "utmMedium": "refer",
                            "utmCampaign": "batch_share",
                            "utmTerm": "",
                            "utmContent": "",
                            "socialTitle": batch_name ?? "",
                            "socialDescription": "",
                            "socialImageLink": savedBatch.banner[0]?.fileLoc ?? ""
                        }
                        let data1 = await genrateDeepLink(details);
                        await BatchesTable.findByIdAndUpdate(savedBatch?._id, { shareLink: { link: data1.shortLink, text: batch_name } })

                        // for (let i = 0; i < teacher.length; i++) {
                        // await sendNotificationTeacher(
                        //     Data.studentId,
                        //     teacher[i],
                        //     "Batch"
                        // );
                        // }
                        // if (is_active) {
                        //     const data = {
                        //         title: batch_name,
                        //         message: `New Batch ${batch_name} launched`,
                        //         fileUrl: fileLoc[0]?.fileLoc,
                        //         route: "batchbyid",
                        //         rootId: `${savedBatch?._id}`,
                        //         childId: ""
                        //     };
                        //     await sendCustomNotification('all', data);

                        // }

                        res.json({
                            status: true,
                            data: [newBatchDetails],
                            msg: "added Batches details successfully",
                        });
                    } else {
                        res.json({
                            status: false,
                            data: null,
                            msg: "not an admin",
                        });
                    }
                }
            })
        } catch (error) {
            return res.json({
                status: false,
                data: null,
                msg: error.message
            })
        }
    });

AdminPanel.post("/copyBatchDetails", ValidateToken, async (req, res) => {
    let { batchId, isCopyLecture, isCopyLectResources, isLectureActive, isLectureResActive } = req.body;
    if (!batchId || batchId === "") {
        return res.json({
            status: false,
            data: null,
            msg: "Required batchId"
        });
    }
    // console.log(req.body);
    try {
        const decodedToken = jwt.verify(req.token, process.env.ADMIN_SECRET_KEY);
        const adminDetails = await findAdminTeacherUsingUserId(decodedToken.studentId);
        const date = new Date(moment().add(5, "hours").add(30, "minutes"));
        const formatedDate = formatDate(date);
        // console.log(adminDetails)
        if ((adminDetails.Role !== "admin" || adminDetails.Role !== "subadmin")) {
            return res.json({
                status: false,
                data: null,
                msg: "Not an Admin"
            });
        }

        const isbatchExists = await BatchesTable.findOne({ _id: batchId }).limit(1);

        if (!isbatchExists) {
            return res.json({
                status: false,
                data: null,
                msg: "Batch Not Found"
            });
        }

        const {
            batch_name,
            subject,
            exam_type,
            starting_date,
            ending_date,
            materials,
            charges,
            discount,
            description,
            banner,
            language,
            teacher,
            demoVideo,
            remark,
            validity,
            course_review,
            mode,
            stream,
            created_at,
            isCoinApplicable,
            maxAllowedCoins
        } = isbatchExists;

        let slug = await generateSlug(batch_name + batchId) ?? "";
        let uniqueBatchId = await getLatestBatchId();

        const newBatchDetails = await new BatchesTable({
            user: adminDetails._id,
            batch_name: batch_name + batchId ?? "",
            slug,
            student: [],
            subject: subject ?? [],
            exam_type: exam_type ?? "",
            starting_date: starting_date ?? formatedDate,
            ending_date: ending_date ?? formatedDate,
            materials: materials ?? "",
            charges: charges ?? "",
            discount: discount ?? "",
            is_active: false,
            description: description ?? "",
            banner: banner ?? [],
            language: language ?? "en",
            teacher: teacher ?? [],
            demoVideo: demoVideo ?? [],
            remark: remark ?? "",
            validity: validity ?? "",
            course_review: course_review ?? "",
            mode: mode ?? "",
            stream: stream ?? "",
            created_at: created_at ?? formatedDate,
            isCoinApplicable: isCoinApplicable ?? false,
            maxAllowedCoins: maxAllowedCoins ?? "0",
            batchId: uniqueBatchId
        });

        const batchSaved = await newBatchDetails.save();


        if (!batchSaved) {
            return res.json({
                status: false,
                data: null,
                msg: "Error while copying the batch"
            });
        }
        let link = `https://www.sdcampus.com?route=${`batchbyid`}&rootId=${batchSaved?._id}&childId=null`
        let details = {
            "link": link ?? "",
            "utmSource": "sdcampus_app",
            "utmMedium": "refer",
            "utmCampaign": "share_course",
            "utmTerm": "",
            "utmContent": "",
            "socialTitle": batchSaved?.batch_name ?? "",
            "socialDescription": "",
            "socialImageLink": batchSaved?.banner[0]?.fileLoc ?? ""
        }
        let data1 = await genrateDeepLink(details);
        await BatchesTable.findByIdAndUpdate(batchSaved?._id, { shareLink: { link: data1.shortLink, text: batch_name } })
        const lectureResourceArr = [];
        // console.log(isLectureActive);
        const saveLectures = async () => {
            const lectureBatch = await LectureTable.find({ batch: isbatchExists._id });
            const lecturesPromises = lectureBatch.map(async (lecture) => {
                const LectureDetails = new LectureTable({
                    user_admin: adminDetails._id,
                    batch: batchSaved._id,
                    lecture_title: lecture.lecture_title + lecture._id ?? "",
                    description: lecture.description ?? "",
                    // is_active: lecture.is_active ?? true,
                    isActive: isLectureActive,
                    lecture_type: lecture.lecture_type ?? "",
                    starting_date: lecture.starting_date ?? formatedDate,
                    ending_date: lecture.ending_date ?? formatedDate,
                    material: lecture.material,
                    subject: lecture.subject,
                    link: lecture.link,
                    ytLiveChatId: lecture.ytLiveChatId ?? "",
                    language: lecture.language ?? "",
                    LiveOrRecorded: lecture.LiveOrRecorded ?? "",
                    created_at: lecture.formatedDate,
                    teacher: lecture?.teacher,
                });
                // return LectureDetails.save();

                const newLecture = await LectureDetails.save();
                // console.log( newLecture?._id);
                // console.log(isbatchExists?._id);
                // find all lecture resoure with associated with this lectureId
                const allLectRes = await LectureResourceTable.find({ batch: isbatchExists?._id, lecture: lecture?._id });
                for (let reso of allLectRes) {
                    let obj = {
                        user: adminDetails._id,
                        batch: batchSaved._id,
                        lecture: newLecture?._id,
                        // lecture: resource.lecture, // new lecture 
                        // title: reso.title + resource.lecture ?? "",
                        title: reso.title,
                        created_at: formatedDate,
                        language: reso.language ?? "en",
                        // is_active: reso.is_active ?? false,
                        // is_active: false,
                        is_active: isLectureResActive,
                        resourceType: reso?.resourceType,
                        is_Verified: reso?.is_Verified ?? true,
                        upload_file: reso?.upload_file

                    }
                    lectureResourceArr.push(obj);
                }

            });

            return Promise.all(lecturesPromises);
        };

        const saveLectureResources = async () => {
            const lectureIds = await LectureTable.find({ batch: isbatchExists._id });
            const lectArray = lectureIds.map(item => item._id);

            const lectResources = await LectureResourceTable.find({ lecture: { $in: lectArray } });
            const lectResourcePromises = lectResources.map(async (resource) => {
                const Lectureresource = new LectureResourceTable({
                    user: adminDetails._id,
                    batch: batchSaved._id,
                    lecture: resource.lecture, // new lecture 
                    title: resource.title + resource.lecture ?? "",
                    created_at: formatedDate,
                    language: resource.language ?? "en",
                    is_active: resource.is_active ?? false,
                    resourceType: resource.resourceType,
                    is_Verified: resource.is_Verified ?? true,
                    upload_file: resource.upload_file
                });
                return Lectureresource.save();
            });

            return Promise.all(lectResourcePromises);
        };

        if (isCopyLecture) {
            await saveLectures();
        }

        if (isCopyLectResources) {
            await LectureResourceTable.insertMany(lectureResourceArr);
            // await saveLectureResources();
        }

        // BatchCommunity
        // const saveBatchCommunity = async () => {
        //     const batchCommunities = await BatchCommunity.find({ batch: isbatchExists._id });
        //     const communityPromises = batchCommunities.map(async (item) => {
        //         const communityDetails = new ({
        //             user: item?.user,
        //             batch: batchSaved._id,
        //             desc : item?.user , 
        //             problemImage : item?.problemImage , 
        //             isActive : item?.isActive 
        //         });
        //         const newCommunity = await communityDetails.save();
        //     });

        //     return Promise.all(communityPromises);
        // }; 
        // await saveBatchCommunity();
        return res.json({
            status: true,
            data: [batchSaved],
            msg: "Batch details copied successfully",
        });
    } catch (error) {
        res.status(401).json({
            status: false,
            data: null,
            msg: error
        });
    }
});

AdminPanel.post("/batchCoins/:id", isAdmin, uploadMulter.none(), async (req, res) => {
    const { id } = req.params
    const { isCoinApplicable, maxAllowedCoins } = req.body
    if (!isCoinApplicable && maxAllowedCoins) {
        return res.json({
            status: false,
            data: null,
            msg: "Required! isCoinApplicable "
        })
    }
    jwt.verify(req.token, process.env.ADMIN_SECRET_KEY, async (err, Data) => {
        if (err) {
            res.status(401).json({
                status: false,
                data: null,
                msg: err,
            });
        } else {
            const admin = await findAdminTeacherUsingUserId(
                Data.studentId
            );
            if (!admin) {
                return res.json({
                    status: false,
                    data: null,
                    msg: "Invalid Access"
                })
            }
            const batch = await BatchesTable.findOne({ _id: id })
            if (!batch) {
                return res.json({
                    status: false,
                    data: null,
                    msg: "Batch Not Exists"
                })
            }
            await BatchesTable.findByIdAndUpdate({ _id: batch._id }, {
                isCoinApplicable,
                maxAllowedCoins: maxAllowedCoins ? maxAllowedCoins : "0"
            })
            return res.json({
                status: true,
                data: {
                    isCoinApplicable, maxAllowedCoins
                },
                msg: `${maxAllowedCoins} Coins allowed on ${batch.batch_name} Batch purchase`
            })

        }
    });
});

AdminPanel.post("/batchOrder/:id", isAdmin, async (req, res) => {
    const { id } = req.params
    const { batchOrder } = req.body;
    if (!id || !batchOrder) {
        return res.json({
            status: false,
            data: null,
            msg: "Required id & batchOrder!"
        })
    }
    jwt.verify(req.token, process.env.ADMIN_SECRET_KEY, async (err, Data) => {
        if (err) {
            res.status(401).json({
                status: false,
                data: null,
                msg: err,
            });
        } else {
            const admin = await findAdminTeacherUsingUserId(
                Data.studentId
            );
            if (!admin) {
                return res.json({
                    status: false,
                    data: null,
                    msg: "Invalid Access"
                })
            }
            const batch = await BatchesTable.findOne({ _id: id });
            if (!batch) {
                return res.json({
                    status: false,
                    data: null,
                    msg: "Batch Not Exists"
                })
            }

            const orderExist = await BatchesTable.findOne({ batchOrder: batchOrder });
            if (orderExist) {
                return res.json({
                    status: false,
                    data: null,
                    msg: ' this batch order already exist'
                })
            }
            const allBatches = await BatchesTable.find({});
            if (batchOrder > allBatches.length) {
                return res.json({
                    status: false,
                    data: null,
                    msg: "batchOrder greater than number of batches"
                })
            }
            await BatchesTable.findByIdAndUpdate({ _id: batch._id }, {
                batchOrder
            })
            return res.json({
                status: true,
                data: { batchOrder },
                msg: `${batch.batch_name} batch order chnaged ${batchOrder}.`
            })

        }
    });
})
//Deleting the Notes Details
AdminPanel.delete(
    "/DeleteBatchesDetails/:id",
    ValidateToken,
    async (req, res) => {
        jwt.verify(req.token, process.env.SECRET_KEY, async (err, Data) => {
            if (err) {
                res.status(401).json({
                    err: err,
                    status: false,
                    data: null,
                    msg: "not an admin",
                });
            } else {
                const adminDetails = await findAdminTeacherUsingUserId(Data.studentId);
                if (adminDetails) {
                    const id = req.params.id;
                    const isBatchExist = await BatchesTable.findOne({ _id: id })
                    if (!isBatchExist) {
                        return res.json({
                            status: false,
                            data: null,
                            msg: "Batch Not Exists"
                        })
                    }
                    if (isBatchExist.is_active) {
                        return res.json({
                            status: false,
                            data: null,
                            msg: "Please Inactive Batch before deletion"
                        })
                    }
                    const myBatches = await MybatchTable.findOne({ batch_id: id })
                    if (myBatches || isBatchExist?.student.length > 0) {
                        return res.json({
                            status: false,
                            data: null,
                            msg: "Deletion of this batch is not allowed as students are already enrolled. You can only set this batch to an inactive status."
                        })
                    }
                    await savePanelEventLogs(
                        adminDetails._id,
                        "deleteBatch",
                        "delete",
                        isBatchExist
                    )
                    // delete lectures
                    await LectureTable.deleteMany({ batch: isBatchExist._id })
                    // delete lecture resources
                    await LectureResourceTable.deleteMany({ batch: isBatchExist._id })
                    // delete batch details
                    await BatchesTable.findByIdAndDelete({ _id: id });

                    res.json({
                        status: true,
                        data: null,
                        msg: `${isBatchExist.batch_name} Batch deleted successfully`,
                    });
                } else {
                    res.json({
                        status: false,
                        data: null,
                        msg: "no authority to perform the specific task",
                    });
                }
            }
        });
    }
);

AdminPanel.put(
    "/addDemoVideo/:id",
    ValidateToken,
    upload.single("file"),
    async (req, res) => {
        jwt.verify(req.token, process.env.SECRET_KEY, async (err, Data) => {
            if (err) {
                res.status(401).json({
                    err: err,
                    status: false,
                    data: null,
                    msg: "not an admin",
                });
            } else {
                const { id } = req.params;
                const adminDetails = await findAdminTeacherUsingUserId(Data.studentId);
                if (adminDetails) {
                    const batchdetails = await BatchesTable.findOne({
                        _id: id,
                    });
                    if (batchdetails) {
                        let fileLoc;
                        let DemoVideoUploadLocation;
                        if (req.file) {
                            const helperString1 = Math.floor(Date.now() / 1000);
                            const filename1 = (req.file.originalname.split(".")[0]).replace(/\s+/g, '_').replace(/[^a-zA-Z0-9_]/g, '');
                            const extension1 = "." + req.file.originalname.split(".").pop();
                            DemoVideoUploadLocation = `Batches/${batchdetails.batch_name?.replace(/\s+/g, '_').replace(/[^a-zA-Z0-9_]/g, '')}/DemoVideos/${filename1}_${helperString1}${extension1}`;
                            let fileLocHelper1 = await uploadFile(
                                req.file.path,
                                DemoVideoUploadLocation
                            );
                            fileLoc = fileDetails(req.file, fileLocHelper1);
                        }
                        batchdetails.demoVideo.push(fileLoc);
                        batchdetails.save();
                        res.json({
                            status: true,
                            data: null,
                            msg: "added the DemoVideo",
                        });
                    } else {
                        res.json({
                            status: false,
                            data: null,
                            msg: "Batch Details not found",
                        });
                    }
                }
            }
        });
    }
);

//Updating the Notes Details
AdminPanel.put(
    "/updatedBatchesDetails/:id",
    ValidateToken,
    upload.fields([
        {
            name: "file",
            maxCount: 1,
        },
        {
            name: "demoVideo",
            maxCount: 3,
        },
        {
            name: 'file1',
            maxCount: 1,
        },
        {
            name: 'featureVideoFile',
            maxCount: 1,
        }
    ]),
    async (req, res) => {
        try {
            let {
                batch_name,
                exam_type,
                subject,
                starting_date,
                ending_date,
                mode,
                discount,
                charges,
                description,
                teacher,
                isPaid,
                metaTitle,
                metaDesc,
                language,
                is_active,
                stream,
                remark,
                materials,
                validity,
                demoVideoLink,
                course_review,
                bannerfileType,
                demoVideoType,
                demoVideoResentLinks,
                isEmi,
                emiOptions,
                category,
                subCategory,
                featureVideoType,
                featureVideoFile,
            } = req.body;
            if (discount && charges) {
                if (parseFloat(charges) < parseFloat(discount)) {
                    return res.json({
                        status: false,
                        data: null,
                        msg: `Discount Price must lower or equal to regular price`
                    })
                }
            } else {
                discount = charges
            }
            // let isPaid = true
            // if (parseFloat(discount) == parseFloat(charges)) {
            //   isPaid = false
            // }
            if (isEmi == 'true' && emiOptions?.length < 2) {
                return res.json({
                    status: false,
                    data: null,
                    msg: 'Emi Options should be more than one'
                })
            }
            const id = req.params.id;
            jwt.verify(req.token, process.env.ADMIN_SECRET_KEY, async (err, Data) => {
                if (err) {
                    res.status(401).json({
                        err: err,
                        status: false,
                        data: null,
                        msg: "not an admin",
                    });
                } else {
                    const date = new Date(moment().add(5, "hours").add(30, "minutes"));
                    const adminDetails = await findAdminTeacherUsingUserId(Data.studentId);
                    if (adminDetails) {
                        const BatchesDetails = await BatchesTable.findOne({ _id: id });

                        if (BatchesDetails) {
                            const ytCheck = /^(?:https?:\/\/)?(?:www\.)?(?:youtube\.com\/(?:watch\?v=|embed\/|v\/|shorts\/)|youtu\.be\/)([a-zA-Z0-9_-]{11})(?:\S+)?$/;
                            let featureVideo = {
                                videoType: "yt", // yt , upload
                                url: "https://www.youtube.com/watch?v=iWTDZdv9llw",
                            }
                            if (featureVideoType == 'yt') {
                                console.log
                                if (!ytCheck.test(featureVideoFile)) {
                                    return res.json({
                                        status: false,
                                        data: null,
                                        msg: `Provide Youtube url for feature video.`
                                    })
                                } else {
                                    featureVideo = {
                                        videoType: "yt", // yt , upload
                                        url: featureVideoFile,
                                    }
                                }

                            } else if (featureVideoType == 'upload') {
                                if (req.files.featureVideoFile) {
                                    const helperString = Math.floor(Date.now() / 1000);
                                    const filename = (req.files.featureVideoFile[0].originalname.split(".")[0]).replace(/\s+/g, '_').replace(/[^a-zA-Z0-9_]/g, '');
                                    const extension = "." + req.files.featureVideoFile[0].originalname.split(".").pop();
                                    let FileUploadLocation = `Batches/${batch_name?.replace(/\s+/g, '_').replace(/[^a-zA-Z0-9_]/g, '')}/${filename}_${helperString}${extension}`;;
                                    let fileLocHelper = await uploadFile(
                                        req.files.featureVideoFile[0].path,
                                        FileUploadLocation
                                    );
                                    featureVideo = {
                                        videoType: "upload", // yt , upload
                                        url: fileLocHelper,
                                    }
                                } else if (featureVideoFile?.includes("https://static.sdcampus.com")) {
                                    featureVideo = {
                                        videoType: "upload", // yt , upload
                                        url: featureVideoFile,
                                    }
                                } else {
                                    return res.json({
                                        status: false,
                                        data: null,
                                        msg: 'Please Upload feature video'
                                    })
                                }
                            } else {
                                featureVideo = {
                                    videoType: BatchesDetails?.featureVideo?.videoType, // yt , upload
                                    url: BatchesDetails?.featureVideo?.url,
                                }
                            }
                            let FileUploadLocation;
                            let fileLoc;
                            let DemoVideoUploadLocation;
                            let DemoVideoLoc = [];
                            let planner;
                            // if(demoVideoResentLinks){
                            for (let i = 0; i < demoVideoResentLinks?.length; i++) {
                                let helper = BatchesDetails.demoVideo.filter((video) => {
                                    return video.fileLoc == demoVideoResentLinks[i];
                                });
                                DemoVideoLoc.push(...helper);
                            }
                            // }
                            // console.log(DemoVideoLoc);
                            let checkHelper = false;
                            if (req.files) {
                                if (req.files.file) {
                                    let size = req.files.file[0].size / (1024);
                                    if (size > 100) {
                                        return res.json({
                                            status: false,
                                            data: null,
                                            msg: 'Maximum banner size 100KB allowed'
                                        })
                                    }
                                    const helperString = Math.floor(Date.now() / 1000);
                                    const filename = (req.files.file[0].originalname.split(".")[0]).replace(/\s+/g, '_').replace(/[^a-zA-Z0-9_]/g, '');
                                    const extension =
                                        "." + req.files.file[0].originalname.split(".").pop();
                                    FileUploadLocation = `Batches/${batch_name?.replace(/\s+/g, '_').replace(/[^a-zA-Z0-9_]/g, '')}/${filename}_${helperString}${extension}`;
                                    let fileLocHelper = await uploadFile(
                                        req.files.file[0].path,
                                        FileUploadLocation
                                    );
                                    checkHelper = true;
                                    fileLoc = {
                                        fileLoc: fileLocHelper,
                                        fileName: filename,
                                        fileSize: `${(req.files.file[0].size / 1000000).toFixed(
                                            2
                                        )} MB`,
                                        bannerfileType: bannerfileType,
                                    };
                                } else {
                                    fileLoc = BatchesDetails.banner;
                                }
                                if (req.files.file1) {
                                    const helperString = Math.floor(Date.now() / 1000);
                                    const filename = (req.files.file1[0].originalname.split(".")[0]).replace(/\s+/g, '_').replace(/[^a-zA-Z0-9_]/g, '');
                                    const extension = "." + req.files.file1[0].originalname.split(".").pop();
                                    FileUploadLocation = `Batches/${batch_name?.replace(/\s+/g, '_').replace(/[^a-zA-Z0-9_]/g, '')}/${filename}_${helperString}${extension}`;;
                                    let fileLocHelper = await uploadFile(
                                        req.files.file1[0].path,
                                        FileUploadLocation
                                    );
                                    planner = fileDetails(req.files.file1[0], fileLocHelper);
                                } else {
                                    planner = BatchesDetails?.planner;
                                }
                                if (req.files.demoVideo) {
                                    for (let j = 0; j < req.files.demoVideo.length; j++) {
                                        // console.log(req.files.demoVideo[j].originalname);
                                        const helperString1 = Math.floor(Date.now() / 1000);
                                        const filename1 =
                                            (req.files.demoVideo[j].originalname.split(".")[0]).replace(/\s+/g, '_').replace(/[^a-zA-Z0-9_]/g, '');
                                        const extension1 =
                                            "." + req.files.demoVideo[j].originalname.split(".").pop();
                                        DemoVideoUploadLocation = `Batches/${batch_name?.replace(/\s+/g, '_').replace(/[^a-zA-Z0-9_]/g, '')}/DemoVideos/${filename1}_${helperString1}${extension1}`;
                                        // console.log("Demo "+DemoVideoUploadLocation)
                                        let fileLocHelper1 = await uploadFile(
                                            req.files.demoVideo[j].path,
                                            DemoVideoUploadLocation
                                        );
                                        // console.log(fileLocHelper1)

                                        let helperDemoVideoLoc = {
                                            fileLoc: fileLocHelper1,
                                            fileName: filename1,
                                            fileSize: `${(
                                                req.files.demoVideo[j].size / 1000000
                                            ).toFixed(2)} MB`,
                                            DemoVideofileType: demoVideoType,
                                        };
                                        DemoVideoLoc.push(helperDemoVideoLoc);
                                    }
                                } else if (demoVideoLink) {
                                    for (let i = 0; i < demoVideoLink?.length; i++) {
                                        if (demoVideoLink[i] != "") {
                                            let helperDemoVideoLoc = {
                                                fileLoc: demoVideoLink[i],
                                                fileName: " ",
                                                fileSize: ` `,
                                                DemoVideofileType: demoVideoType,
                                            };
                                            DemoVideoLoc.push(helperDemoVideoLoc);
                                        }
                                    }
                                }
                            } else {
                                fileLoc = BatchesDetails.banner;
                            }
                            let slug = BatchesDetails?.slug;
                            let categoriesId = category?.filter((item) => item != "");
                            let subCategoriesId = subCategory?.filter((item) => item != "");
                            await BatchesTable.findByIdAndUpdate(
                                { _id: id },
                                {
                                    user: adminDetails._id,
                                    batch_name: batch_name,
                                    subject: subject,
                                    exam_type: exam_type,
                                    student: BatchesDetails.student,
                                    starting_date: starting_date,
                                    ending_date: ending_date,
                                    materials: materials,
                                    charges: charges,
                                    slug,
                                    isPaid,
                                    isEmi,
                                    emiOptions: isEmi == 'false' ? ['1'] : emiOptions,
                                    discount: discount,
                                    is_active: is_active,
                                    description: description,
                                    banner: checkHelper ? [fileLoc] : fileLoc,
                                    language: language,
                                    planner: planner,
                                    teacher: teacher,
                                    demoVideo: DemoVideoLoc,
                                    remark: remark,
                                    metaTitle,
                                    metaDesc,
                                    validity: validity,
                                    course_review: course_review,
                                    mode: mode,
                                    stream: stream,
                                    category: categoriesId,
                                    subCategory: subCategoriesId,
                                    featureVideo,
                                },
                                {
                                    runValidators: true,
                                }
                            );
                            res.json({
                                status: true,
                                data: id,
                                msg: "Updated the Batches details",
                            });
                        } else {
                            res.json({
                                status: false,
                                data: null,
                                msg: "Batches not found",
                            });
                        }
                    } else {
                        res.json({
                            status: false,
                            data: null,
                            msg: "Admin details not found in database",
                        });
                    }
                }
            });
        } catch (error) {
            return res.json({
                status: false,
                data: null,
                msg: error.message
            })
        }
    });

//delete a teacher from the batch
AdminPanel.delete("/deleteTeacherFromBatch/:id", isAdmin, async (req, res) => {
    const { id } = req.params;
    const { batch_id } = req.body;
    jwt.verify(req.token, process.env.ADMIN_SECRET_KEY, async (err, Data) => {
        if (err) {
            res.status(401).json({
                status: false,
                data: null,
                msg: err,
            });
        } else {
            const adminDetails = await findAdminTeacherUsingUserId(Data.studentId);
            if (adminDetails) {
                const BatchDetails = await BatchesTable.findOne({
                    _id: batch_id,
                });
                if (BatchDetails) {
                    const Helper = [];
                    const TeacherArray = BatchDetails.teacher;
                    for (let i = 0; i < TeacherArray.length; i++) {
                        if (TeacherArray[i] == id) {
                            continue;
                        } else {
                            Helper.push(TeacherArray[i]);
                        }
                    }
                    await BatchesTable.findByIdAndUpdate(
                        { _id: BatchDetails._id },
                        {
                            teacher: Helper,
                        }
                    );
                    const BatchDetailsafter = await BatchesTable.findOne({
                        _id: batch_id,
                    });
                    await savePanelEventLogs(
                        adminDetails._id,
                        "removeTeacherFromBatch",
                        "delete",
                        { BatchDetails, teacherId: id }
                    )
                    res.json({
                        status: true,
                        data: BatchDetailsafter,
                        msg: "deleted ",
                    });
                } else {
                    res.json({
                        status: false,
                        data: null,
                        msg: "Batch Not Found",
                    });
                }
            } else {
                res.json({
                    status: false,
                    data: null,
                    msg: "Not an Admin",
                });
            }
        }
    });
});

//Adding the teachers to the Batch
AdminPanel.put("/addTeacherToBatch", ValidateToken, async (req, res) => {
    // const { id } = req.params;
    const { batch_id, teacher } = req.body;
    jwt.verify(req.token, process.env.ADMIN_SECRET_KEY, async (err, Data) => {
        if (err) {
            res.status(401).json({
                status: false,
                data: null,
                msg: err,
            });
        } else {
            const adminDetails = await findAdminTeacherUsingUserId(Data.studentId);
            const date = new Date(moment().add(5, "hours").add(30, "minutes"));
            if (adminDetails) {
                const batchDetails = await BatchesTable.findOne({
                    _id: batch_id,
                });
                if (batchDetails) {
                    for (let i = 0; i < teacher.length; i++) {
                        if (batchDetails.teacher.includes(teacher[i])) {
                            continue;
                        } else {
                            await batchDetails.teacher.push(teacher[i]);
                            await batchDetails.save();
                            const helperNotification = new NotificationModel({
                                user: Data.studentId,
                                to: teacher[i],
                                title: "batch wellcome",
                                Avatar:
                                    "https://d1mbj426mo5twu.cloudfront.net/assets/Avtar.png",
                                type: "batch",
                                isUnRead: true,
                                notificationBody: `You were added to the batch ${batchDetails.batch_name} , SD Campus welcome You to ${batchDetails?.batch_name} `,
                            });
                            helperNotification.save();
                        }
                    }
                    res.json({
                        status: true,
                        data: batchDetails,
                        msg: "updated the batches details successfully",
                    });
                } else {
                    res.json({
                        status: false,
                        data: null,
                        msg: "Batch not found",
                    });
                }
            } else {
                res.json({
                    status: false,
                    data: null,
                    msg: "not an admin",
                });
            }
        }
    });
});

//Add the Student Details To The Batch
AdminPanel.put("/addStudentToBatch/:id", ValidateToken, async (req, res) => {
    const { id } = req.params;
    const { batch_id } = req.body;
    jwt.verify(req.token, process.env.ADMIN_SECRET_KEY, async (err, Data) => {
        if (err) {
            res.status(401).json({
                status: false,
                data: null,
                msg: err,
            });
        } else {
            const adminDetails = await findAdminTeacherUsingUserId(Data.studentId);
            if (adminDetails) {
                const StudentDetails = await UserTable.findOne({ _id: id });
                if (StudentDetails) {
                    const batchDetails = await BatchesTable.findOne({
                        _id: batch_id,
                    });
                    if (batchDetails.student.includes(StudentDetails._id)) {
                        res.json({
                            status: false,
                            data: null,
                            msg: "Student already exists",
                        });
                    } else {
                        if (batchDetails) {
                            batchDetails.student.push(StudentDetails);
                            batchDetails.save();
                            res.json({
                                status: true,
                                data: batchDetails,
                                msg: "updated the batches details successfully",
                            });
                        } else {
                            res.json({
                                status: false,
                                data: null,
                                msg: "Batch not found",
                            });
                        }
                    }
                } else {
                    res.json({
                        status: false,
                        data: null,
                        msg: "Student not found",
                    });
                }
            } else {
                res.json({
                    status: false,
                    data: null,
                    msg: "not an admin",
                });
            }
        }
    });
});

//Fetching the Assignments Details
AdminPanel.get("/getAssignmentsDetails", ValidateToken, async (req, res) => {
    const { language } = req.query;
    jwt.verify(req.token, process.env.SECRET_KEY, async (err, Data) => {
        if (err) {
            res.status(401).json({
                err: err,
                status: false,
                data: null,
                msg: "not an user",
            });
        } else {
            const AssignmentsDetails = await AssignmentTable.find({}).populate(
                "batch"
            );
            if (AssignmentsDetails.length != 0) {
                if (language) {
                    let AssignMentByLang = AssignmentsDetails.filter((Assignment) => {
                        return Assignment.language == language;
                    });
                    res.json({
                        status: true,
                        data: AssignMentByLang,
                        msg: "fetched all the Assignment details based on language ",
                    });
                } else {
                    res.json({
                        status: true,
                        data: AssignmentsDetails,
                        msg: "fetched all the Assignment details",
                    });
                }
            } else {
                res.json({
                    status: false,
                    data: null,
                    msg: "No data found ",
                });
            }
        }
    });
});

//Adding the Assignments Details
AdminPanel.post(
    "/addAssignmentDetails",
    ValidateToken,
    upload.single("file"),
    async (req, res) => {
        const { batch, link, language, is_active } = req.body;
        jwt.verify(req.token, process.env.ADMIN_SECRET_KEY, async (err, Data) => {
            if (err) {
                res.status(401).json({
                    status: false,
                    data: null,
                    msg: err,
                });
            } else {
                const adminDetails = await findAdminTeacherUsingUserId(Data.studentId);
                const date = new Date(moment().add(5, "hours").add(30, "minutes"));
                let formatedDate = formatDate(date);
                if (
                    adminDetails.Role == "admin" ||
                    adminDetails.Role == "subadmin" ||

                    adminDetails.accessToContent.includes("Assignment")
                ) {
                    const batchFind = await BatchesTable.findOne({
                        batch_name: batch,
                    });
                    let FileUploadLocation;
                    let fileLoc;
                    if (req.file) {
                        const helperString = Math.floor(Date.now() / 1000);
                        const filename = (req.file.originalname.split(".")[0]).replace(/\s+/g, '_').replace(/[^a-zA-Z0-9_]/g, '');
                        const extension = "." + req.file.originalname.split(".").pop();
                        FileUploadLocation = `assignments/${batch}/${filename}_${helperString}${extension}`;
                        let fileLocHelper = await uploadFile(
                            req.file.path,
                            FileUploadLocation
                        );
                        fileLoc = fileDetails(req.file, fileLocHelper);
                    }
                    const newAssignmentDetails = new AssignmentTable({
                        user: adminDetails._id,
                        file: fileLoc,
                        batch: batchFind._id,
                        link: link,
                        language: language,
                        is_active: is_active,
                        created_at: formatedDate,
                    });
                    await newAssignmentDetails.save();
                    res.json({
                        status: true,
                        data: [newAssignmentDetails, { fileUploadLoc: fileLoc }],
                        msg: "added Assignment  successfully",
                    });
                } else {
                    res.json({
                        status: false,
                        data: null,
                        msg: "not an admin",
                    });
                }
            }
        });
    }
);

//Deleting the Notes Details
AdminPanel.delete(
    "/DeleteAssignmentDetails/:id",
    ValidateToken,
    async (req, res) => {
        jwt.verify(req.token, process.env.SECRET_KEY, async (err, Data) => {
            if (err) {
                res.status(401).json({
                    err: err,
                    status: false,
                    data: null,
                    msg: "not an admin",
                });
            } else {
                const adminDetails = await findAdminTeacherUsingUserId(Data.studentId);
                if (
                    adminDetails.Role == "admin" ||
                    adminDetails.Role == "subadmin" ||

                    adminDetails.accessToContent.includes("Assignment")
                ) {
                    const id = req.params.id;
                    const findAssignmentDetails = await AssignmentTable.findOne({
                        _id: id,
                    });
                    if (findAssignmentDetails) {
                        await AssignmentTable.findByIdAndDelete({
                            _id: id,
                        });
                        await savePanelEventLogs(
                            adminDetails._id,
                            "deleteAssignment",
                            "delete",
                            findAssignmentDetails
                        )
                        res.json({
                            status: true,
                            data: null,
                            msg: "successfully deleted the Assignment",
                        });
                    } else {
                        res.json({
                            status: false,
                            data: null,
                            msg: "the Assignment details not found ",
                        });
                    }
                } else {
                    res.json({
                        status: false,
                        data: null,
                        msg: "no authority to perform the specific task",
                    });
                }
            }
        });
    }
);

//Updating the Notes Details
AdminPanel.put(
    "/updatedAssignmentDetails/:id",
    ValidateToken,
    upload.single("file"),
    async (req, res) => {
        const { batch, file, link, is_active, language } = req.body;
        const id = req.params.id;
        jwt.verify(req.token, process.env.ADMIN_SECRET_KEY, async (err, Data) => {
            if (err) {
                res.status(401).json({
                    err: err,
                    status: false,
                    data: null,
                    msg: "not an admin",
                });
            } else {
                const date = new Date(moment().add(5, "hours").add(30, "minutes"));
                const adminDetails = await findAdminTeacherUsingUserId(Data.studentId);
                if (
                    adminDetails.Role == "admin" ||
                    adminDetails.Role == "subadmin" ||

                    adminDetails.accessToContent.includes("Assignment")
                ) {
                    const AssignmentsDetails = await AssignmentTable.findOne({ _id: id });
                    if (AssignmentsDetails) {
                        let FileUploadLocation;
                        let fileLoc;
                        if (req.file) {
                            const helperString = Math.floor(Date.now() / 1000);
                            const filename = (req.file.originalname.split(".")[0]).replace(/\s+/g, '_').replace(/[^a-zA-Z0-9_]/g, '');
                            const extension = "." + req.file.originalname.split(".").pop();
                            FileUploadLocation = `assignments/${batch}/${filename}_${helperString}${extension}`;
                            let fileLocHelper = await uploadFile(
                                req.file.path,
                                FileUploadLocation
                            );
                            fileLoc = fileDetails(req.file, fileLocHelper);
                        }
                        await AssignmentTable.findByIdAndUpdate(
                            { _id: id },
                            {
                                file: fileLoc,
                                batch: batch,
                                link: link,
                                language: language,
                                is_active: is_active,
                            },
                            {
                                runValidators: true,
                            }
                        );
                        res.json({
                            status: true,
                            data: id,
                            msg: "Updated the Assignments details",
                        });
                    } else {
                        res.json({
                            status: false,
                            data: null,
                            msg: "Assignment not found",
                        });
                    }
                } else {
                    res.json({
                        status: false,
                        data: null,
                        msg: "Admin details not found in database",
                    });
                }
            }
        });
    }
);

//Fetching the Testimonial Details
AdminPanel.get("/getTestimonialDetails", ValidateToken, async (req, res) => {
    const { language } = req.query;
    jwt.verify(req.token, process.env.SECRET_KEY, async (err, Data) => {
        if (err) {
            res.status(401).json({
                err: err,
                status: false,
                data: null,
                msg: "not an user",
            });
        } else {
            const TestDetails = await TestimonialTable.find({});
            if (TestDetails.length != 0) {
                if (language) {
                    let TestByLang = TestDetails.filter((TEST) => {
                        return TEST.language == language;
                    });
                    res.json({
                        status: true,
                        data: TestByLang,
                        msg: "fetched all the TEST details based on language ",
                    });
                } else {
                    res.json({
                        status: true,
                        data: TestDetails,
                        msg: "fetched all the TEST details",
                    });
                }
            } else {
                res.json({
                    status: false,
                    data: null,
                    msg: "No data found ",
                });
            }
        }
    });
});

//Adding the Testimonial Details
AdminPanel.post(
    "/addTestimonialDetails",
    ValidateToken,
    upload.single("file"),
    async (req, res) => {
        const { student_name, rank, message, is_active, exam, year, language } =
            req.body;
        jwt.verify(req.token, process.env.ADMIN_SECRET_KEY, async (err, Data) => {
            if (err) {
                res.status(401).json({
                    status: false,
                    data: null,
                    msg: err,
                });
            } else {
                const adminDetails = await findAdminTeacherUsingUserId(Data.studentId);
                const date = new Date(moment().add(5, "hours").add(30, "minutes"));
                let formatedDate = formatDate(date);
                if (
                    adminDetails.Role == "admin" ||
                    adminDetails.Role == "subadmin" ||

                    adminDetails.accessToContent.includes("Testimonial")
                ) {
                    let FileUploadLocation;
                    let fileLoc;
                    if (req.file) {
                        const helperString = Math.floor(Date.now() / 1000);
                        const filename = (req.file.originalname.split(".")[0]).replace(/\s+/g, '_').replace(/[^a-zA-Z0-9_]/g, '');
                        const extension = "." + req.file.originalname.split(".").pop();
                        FileUploadLocation = `assignments/${language}/${filename}_${helperString}${extension}`;
                        let fileLocHelper = await uploadFile(
                            req.file.path,
                            FileUploadLocation
                        );
                        fileLoc = fileDetails(req.file, fileLocHelper);
                    }
                    const newTestimonialDetails = new TestimonialTable({
                        user: adminDetails._id,
                        student_name: student_name,
                        rank: rank,
                        language: language,
                        photo: fileLoc,
                        is_active: is_active,
                        message: message,
                        exam: exam,
                        year: year,
                        is_active: false,
                        created_at: formatedDate,
                    });
                    await newTestimonialDetails.save();
                    res.json({
                        status: true,
                        data: [newTestimonialDetails, { fileUploadLoc: fileLoc }],
                        msg: "added Test details successfully",
                    });
                } else {
                    res.json({
                        status: false,
                        data: null,
                        msg: "not an admin",
                    });
                }
            }
        });
    }
);

//Deleting the Notes Details
AdminPanel.delete(
    "/DeleteTestimonialDetails/:id",
    ValidateToken,
    async (req, res) => {
        jwt.verify(req.token, process.env.SECRET_KEY, async (err, Data) => {
            if (err) {
                res.status(401).json({
                    err: err,
                    status: false,
                    data: null,
                    msg: "not an admin",
                });
            } else {
                const adminDetails = await findAdminTeacherUsingUserId(Data.studentId);
                if (
                    adminDetails.Role == "admin" ||
                    adminDetails.Role == "subadmin" ||

                    adminDetails.accessToContent.includes("Testimonial")
                ) {
                    const id = req.params.id;
                    const findTestimonialDetails = await TestimonialTable.findOne({
                        _id: id,
                    });
                    if (findTestimonialDetails) {
                        await TestimonialTable.findByIdAndDelete({
                            _id: id,
                        });
                        await savePanelEventLogs(
                            adminDetails._id,
                            "deleteTestemonials",
                            "delete",
                            findTestimonialDetails
                        )
                        res.json({
                            status: true,
                            data: null,
                            msg: "successfully deleted the Testimonial details",
                        });
                    } else {
                        res.json({
                            status: false,
                            data: null,
                            msg: "the Testimonial details not found ",
                        });
                    }
                } else {
                    res.json({
                        status: false,
                        data: null,
                        msg: "no authority to perform the specific task",
                    });
                }
            }
        });
    }
);

//Updating the Notes Details
AdminPanel.put(
    "/updatedTestimonialDetails/:id",
    ValidateToken,
    upload.single("file"),
    async (req, res) => {
        const {
            student_name,
            rank,
            photo,
            message,
            exam,
            year,
            is_active,
            language,
        } = req.body;
        const id = req.params.id;
        jwt.verify(req.token, process.env.ADMIN_SECRET_KEY, async (err, Data) => {
            if (err) {
                res.status(401).json({
                    err: err,
                    status: false,
                    data: null,
                    msg: "not an admin",
                });
            } else {
                const adminDetails = await findAdminTeacherUsingUserId(Data.studentId);
                if (
                    adminDetails.Role == "admin" ||
                    adminDetails.Role == "subadmin" ||

                    adminDetails.accessToContent.includes("Testimonial")
                ) {
                    const TestimonialDetails = await TestimonialTable.findOne({
                        _id: id,
                    });
                    if (TestimonialDetails) {
                        let FileUploadLocation;
                        let fileLoc;
                        if (req.file) {
                            const helperString = Math.floor(Date.now() / 1000);
                            const filename = (req.file.originalname.split(".")[0]).replace(/\s+/g, '_').replace(/[^a-zA-Z0-9_]/g, '');
                            const extension = "." + req.file.originalname.split(".").pop();
                            FileUploadLocation = `assignments/${language}/${filename}_${helperString}${extension}`;
                            let fileLocHelper = await uploadFile(
                                req.file.path,
                                FileUploadLocation
                            );
                            fileLoc = fileDetails(req.file, fileLocHelper);
                        }
                        await TestimonialTable.findByIdAndUpdate(
                            { _id: id },
                            {
                                student_name: student_name,
                                rank: rank,
                                language: language,
                                photo: fileLoc,
                                message: message,
                                exam: exam,
                                year: year,
                                is_active: false,
                                is_active: is_active,
                            },
                            {
                                runValidators: true,
                            }
                        );
                        res.json({
                            status: true,
                            data: id,
                            msg: "Updated the Test details",
                        });
                    } else {
                        res.json({
                            status: false,
                            data: null,
                            msg: "Testimonail not found",
                        });
                    }
                } else {
                    res.json({
                        status: false,
                        data: null,
                        msg: "Admin details not found in database",
                    });
                }
            }
        });
    }
);

//fetch the category details
AdminPanel.get("/getCategory", ValidateToken, async (req, res) => {
    const { type } = req.query;
    jwt.verify(req.token, process.env.SECRET_KEY, async (err, Data) => {
        if (err) {
            res.status(401).json({
                err: err,
                status: false,
                data: null,
                msg: "not an admin",
            });
        } else {
            const user = await findUserByUserId(Data.studentId);
            if (user) {
                if (type) {
                    const CategorilDetails = await categoryTable.find({
                        type: type,
                        is_active: true
                    });
                    if (CategorilDetails.length == 0) {
                        res.json({
                            status: false,
                            data: null,
                            msg: "no data found",
                        });
                    } else {
                        let allData = await Promise.all(CategorilDetails?.map(async (item) => {
                            const subCategory = await subCategoryTable.find({ category: item?._id, is_active: true });
                            return {
                                ...item?._doc,
                                subCategories: subCategory?.map((item2) => {
                                    return {
                                        id: item2?._id,
                                        title: item2?.title ?? "",
                                        slug: item2?.slug ?? "",
                                    }
                                })

                            }
                        }))
                        res.json({
                            status: true,
                            data: CategorilDetails,
                            data1: allData,
                            msg: "Fetched all the category details",
                        });
                    }
                } else {
                    const allDetails = await categoryTable.find({ is_active: true });
                    res.json({
                        status: true,
                        data: allDetails,
                        msg: "fetched all the details",
                    });
                }
            } else {
                if (type) {
                    const CategorilDetails = await categoryTable.find({
                        type: type,
                    });
                    if (CategorilDetails.length == 0) {
                        res.json({
                            status: false,
                            data: null,
                            msg: "no data found",
                        });
                    } else {
                        res.json({
                            status: true,
                            data: CategorilDetails,
                            msg: "Fetched all the category details",
                        });
                    }
                } else {
                    const allDetails = await categoryTable.find({});
                    res.json({
                        status: true,
                        data: allDetails,
                        msg: "fetched all the details",
                    });
                }
            }


        }
    });
});

AdminPanel.get("/getCategoryListByAdmin", isAdmin, async (req, res) => {
    const { type } = req.query;
    try {
        const decoded = jwt.verify(req.token, process.env.ADMIN_SECRET_KEY);
        const admin = await findAdminTeacherUsingUserId(decoded?.studentId);
        if (!admin) {
            return res.json({
                status: false,
                data: null,
                msg: "Not an admin"
            })
        }
        let query = {};
        if (![null, undefined, ""].includes(query)) {
            query = { type: 'Stream' }
        }
        const categories = await categoryTable.find({ ...query }).populate("user", "FullName profilePhoto Role").sort({ _id: -1 });
        return res.json({
            status: true,
            data: categories.map((item, index) => {
                return {
                    ...item?._doc,
                    id: item?._id,
                    sNo: index + 1,
                    value: item?._id,
                    label: item?.title,
                    createdAt: moment(item?.createdAt).format("DD-MM-YYYY HH:mm:ss"),
                    admin: { FullName: item?.user?.FullName ?? "", profilePhoto: item?.user?.profilePhoto ?? "", Role: item?.user?.Role ?? "" }
                }
            }),
            msg: 'All Category fetched'
        })
    } catch (error) {
        return res.json({
            status: false,
            data: null,
            msg: error.message
        })
    }
})
//Adding the Category Details
AdminPanel.post("/addCategorialDetails", upload.single('file'), ValidateToken, async (req, res) => {
    const { title, metaTitle, metaDesc, tags, is_active, seoMetaTitle, seoMetaDesc, seoSlug, type } = req.body;
    jwt.verify(req.token, process.env.ADMIN_SECRET_KEY, async (err, Data) => {
        if (err) {
            res.status(401).json({
                status: false,
                data: null,
                msg: err,
            });
        } else {
            const adminDetails = await findAdminTeacherUsingUserId(Data.studentId);
            const date = new Date(moment().add(5, "hours").add(30, "minutes"));
            let formatedDate = formatDate(date);
            if (
                adminDetails.Role == "admin" ||
                adminDetails.Role == "subadmin" ||

                adminDetails.accessToContent.includes("Category")
            ) {
                const regex = /^[A-Za-z0-9\s\-]+$/;
                let isValid = regex.test(seoSlug);
                // console.log(slug);
                if (!isValid && seoSlug) {
                    return res.json({
                        status: false,
                        data: null,
                        msg: 'SEO Slug can contain only characters & number '
                    })
                }
                let fileLoc = [];
                if (req.file) {
                    let size = req.file.size / (1024);
                    if (size > 100) {
                        return res.json({
                            status: false,
                            data: null,
                            msg: 'Maximum category icon size 100KB allowed'
                        })
                    }
                    const helperString = Math.floor(Date.now() / 1000);
                    const filename = (req.file.originalname.split(".")[0]).replace(/\s+/g, '_').replace(/[^a-zA-Z0-9_]/g, '');
                    const extension = "." + req.file.originalname.split(".").pop();
                    FileUploadLocation = `category/${title?.replace(/\s+/g, '_').replace(/[^a-zA-Z0-9_]/g, '')}/${filename}_${helperString}${extension}`;
                    let helperfileLoc = await uploadFile(
                        req.file.path,
                        FileUploadLocation
                    );
                    fileLoc.push(helperfileLoc);
                }
                const slug = await generateSlug(title);
                const genSeoSlug = await generateSlug(seoSlug);
                const isCatExist = await categoryTable.findOne({ seoSlug: genSeoSlug });
                if (isCatExist) {
                    return res.json({
                        status: false,
                        data: null,
                        msg: `Category already exist with this Seo Slug`
                    })
                }
                const newCategorailData = new categoryTable({
                    user: adminDetails._id,
                    title: title,
                    slug,
                    tags,
                    icon: fileLoc[0],
                    type: type,
                    metaTitle,
                    metaDesc,
                    seoMetaDesc,
                    seoMetaTitle,
                    seoSlug: genSeoSlug,
                    is_active: is_active,
                    created_at: formatedDate,
                });

                const saveCategory = await newCategorailData.save();

                return res.json({
                    status: true,
                    data: saveCategory,
                    msg: "added Category details successfully",
                });
            } else {
                res.json({
                    status: false,
                    data: null,
                    msg: "not an admin",
                });
            }
        }
    });
});

//Deleting the Category Details
AdminPanel.delete(
    "/DeleteCategorailDetails/:id",
    ValidateToken,
    async (req, res) => {
        jwt.verify(req.token, process.env.SECRET_KEY, async (err, Data) => {
            if (err) {
                res.status(401).json({
                    err: err,
                    status: false,
                    data: null,
                    msg: "not an admin",
                });
            } else {
                const adminDetails = await findAdminTeacherUsingUserId(Data.studentId);
                if (adminDetails) {
                    const id = req.params.id;
                    const findcategorailDetail = await categoryTable.findOne({ _id: id });
                    const checkBatchCat = await BatchesTable.findOne({ stream: findcategorailDetail?.title });
                    if (checkBatchCat) {
                        return res.json({
                            msg: "Deletion of this batch is not allowed as this category associated with Batch. You can only set this category to an inactive status."
                        })
                    }

                    if (findcategorailDetail) {
                        await categoryTable.findByIdAndDelete({
                            _id: id,
                        });
                        await savePanelEventLogs(
                            adminDetails._id,
                            "deleteBatchCategory",
                            "delete",
                            findcategorailDetail
                        )
                        res.json({
                            status: true,
                            data: null,
                            msg: "successfully deleted the Category details",
                        });
                    } else {
                        res.json({
                            status: false,
                            data: null,
                            msg: "the category details not found ",
                        });
                    }
                } else {
                    res.json({
                        status: false,
                        data: null,
                        msg: "no authority to perform the specific task",
                    });
                }
            }
        });
    }
);

//Updating the Category Details
AdminPanel.put(
    "/updatedCategorialDetails/:id",
    upload.single('file'),
    ValidateToken,

    async (req, res) => {
        const { title, is_active, type, metaTitle, metaDesc, tags, slug, seoSlug, seoMetaDesc, seoMetaTitle } = req.body;
        const id = req.params.id;
        const regex = /^[A-Za-z0-9\s\-]+$/;
        let isValid = regex.test(slug);
        // console.log(slug);
        if (!isValid && slug) {
            return res.json({
                status: false,
                data: null,
                msg: 'Slug can contain only characters & number '
            })
        }
        if (!isValid && seoSlug) {
            return res.json({
                status: false,
                data: null,
                msg: 'Seo Slug can contain only characters & number '
            })
        }
        jwt.verify(req.token, process.env.ADMIN_SECRET_KEY, async (err, Data) => {
            if (err) {
                res.status(401).json({
                    err: err,
                    status: false,
                    data: null,
                    msg: "not an admin",
                });
            } else {
                const date = new Date(moment().add(5, "hours").add(30, "minutes"));
                const adminDetails = await findAdminTeacherUsingUserId(Data.studentId);
                if (adminDetails) {
                    const categoryDetails = await categoryTable.findOne({ _id: id });
                    if (!categoryDetails) {
                        return res.json({
                            status: false,
                            data: null,
                            msg: 'Category not exist'
                        })
                    }
                    let genSlug = await generateSlug(slug);
                    let genSeoSlug = await generateSlug(seoSlug);
                    const isSlugExist = await categoryTable.findOne({ _id: { $ne: categoryDetails?._id }, slug: genSlug });
                    if (isSlugExist) {
                        return res.json({
                            status: false,
                            data: null,
                            msg: "This slug already exist"
                        })
                    }
                    const isCatExist = await categoryTable.findOne({ _id: { $ne: categoryDetails?._id }, seoSlug: genSeoSlug });
                    if (isCatExist) {
                        return res.json({
                            status: false,
                            data: null,
                            msg: `Category already exist with this Seo Slug`
                        })
                    }

                    let fileUrl = "";
                    if (req.file) {
                        let size = req.file.size / (1024);
                        if (size > 100) {
                            return res.json({
                                status: false,
                                data: null,
                                msg: 'Maximum category icon size 100KB allowed'
                            })
                        }

                        const helperString = Math.floor(Date.now() / 1000);
                        const filename = (req.file.originalname.split(".")[0]).replace(/\s+/g, '_').replace(/[^a-zA-Z0-9_]/g, '');
                        const extension = "." + req.file.originalname.split(".").pop();
                        FileUploadLocation = `category/${title?.replace(/\s+/g, '_').replace(/[^a-zA-Z0-9_]/g, '')}/${filename}_${helperString}${extension}`;
                        let helperfileLoc = await uploadFile(
                            req.file.path,
                            FileUploadLocation
                        );
                        fileUrl = helperfileLoc;
                        // console.log(fileUrl)
                    } else {
                        fileUrl = categoryDetails?.icon
                    }
                    await categoryTable.findByIdAndUpdate(
                        { _id: id },
                        {
                            type: type,
                            title: title,
                            icon: fileUrl,
                            tags: tags,
                            metaTitle,
                            metaDesc,
                            slug: genSlug,
                            seoMetaDesc,
                            seoMetaTitle,
                            seoSlug: genSeoSlug,
                            is_active: is_active,
                        },
                        {
                            runValidators: true,
                        }
                    );
                    const findBatchs = await BatchesTable.find({ stream: categoryDetails.title });
                    if (findBatchs.length > 0) {
                        const batchIds = findBatchs.map((item) => item._id);
                        await BatchesTable.updateMany(
                            { _id: { $in: batchIds } },
                            { $set: { stream: title } }
                        );
                    }
                    return res.json({
                        status: true,
                        data: id,
                        msg: "Updated the category details",
                    });

                } else {
                    return res.json({
                        status: false,
                        data: null,
                        msg: "Admin details not found in database",
                    });
                }
            }
        });
    }
);

// make activeAnd inActive category
AdminPanel.put("/makeActiveAndInActiveCategory/:id", isAdmin, async (req, res) => {
    const { id } = req.params;
    if (!id) {
        return res.json({
            status: false,
            data: null,
            msg: 'Required Id'
        })
    }
    try {
        const decode = jwt.verify(req.token, process.env.ADMIN_SECRET_KEY);
        const admin = await findAdminTeacherUsingUserId(decode?.studentId);
        if (!admin) {
            return res.json({
                status: false,
                data: null,
                msg: "Not an Admin"
            })
        }
        const isCategory = await categoryTable.findOne({ _id: id });
        if (!isCategory) {
            return res.json({
                status: false,
                data: null,
                msg: `Category not found`
            })
        }
        let is_active = isCategory?.is_active == true ? false : true;
        const newCategory = await categoryTable.findByIdAndUpdate(isCategory?._id, { is_active: is_active }, { new: true, lean: true });
        return res.json({
            status: true,
            data: null,
            msg: `${newCategory?.title} status changed into ${newCategory?.is_active == true ? "Active" : "InActive"}`
        })

    } catch (error) {
        return res.json({
            status: false,
            data: null,
            msg: error.message
        })
    }
})

// get the category details
AdminPanel.get(
    "/getCategorailDetails",
    ValidateToken,
    async (req, res) => {
        jwt.verify(req.token, process.env.SECRET_KEY, async (err, Data) => {
            if (err) {
                res.status(401).json({
                    err: err,
                    status: false,
                    data: null,
                    msg: "not an admin",
                });
            } else {
                const adminDetails = await findAdminTeacherUsingUserId(Data.studentId);
                if (adminDetails && adminDetails.Role == "admin" || adminDetails.Role == "subadmin") {
                    const getCat = await categoryTable.find({
                        type: 'Stream'
                    });
                    if (getCat) {
                        res.json({
                            status: true,
                            data: getCat?.map((item) => { return { ...item?._doc, label: item?.title, value: item?._id } }),
                            msg: "successfully get the Category details",
                        });
                    } else {
                        res.json({
                            status: false,
                            data: null,
                            msg: "the category details not found ",
                        });
                    }
                } else {
                    res.json({
                        status: false,
                        data: null,
                        msg: "no authority to perform the specific task",
                    });
                }
            }
        });
    }
);

AdminPanel.get("/getCategoryById/:id", isAdmin, async (req, res) => {
    const { id } = req.params;
    if (!id) {
        return res.json({
            status: false,
            data: null,
            msg: "Required Id"
        })
    }
    try {
        const decode = jwt.verify(req.token, process.env.ADMIN_SECRET_KEY);
        const admin = await findAdminTeacherUsingUserId(decode?.studentId);
        if (!admin) {
            return res.json({
                status: false,
                data: null,
                msg: "Not an admin"
            })
        }
        const category = await categoryTable.findOne({ _id: id });
        return res.json({
            status: true,
            data: category,
            msg: "Category Details fetched"
        })
    } catch (error) {
        return res.json({
            status: false,
            data: null,
            msg: error.message
        })
    }
})

// add SubCategory 
AdminPanel.post("/addSubCategorialDetails", isAdmin, async (req, res) => {
    const { title, category, is_active } = req.body;
    jwt.verify(req.token, process.env.ADMIN_SECRET_KEY, async (err, Data) => {
        if (err) {
            res.status(401).json({
                status: false,
                data: null,
                msg: err,
            });
        } else {
            const adminDetails = await findAdminTeacherUsingUserId(Data.studentId);
            const date = new Date(moment().add(5, "hours").add(30, "minutes"));
            let formatedDate = formatDate(date);
            let slug = await generateSlug(title);
            const isSlugExist = await subCategoryTable.findOne({ slug: slug });
            if (isSlugExist) {
                return res.json({
                    status: false,
                    data: null,
                    msg: 'This Sub Category Slug Already Exist'
                })
            }
            if (adminDetails && (adminDetails.Role == "admin" || adminDetails.Role === 'subadmin')) {
                const newSubCategorailData = new subCategoryTable({
                    user: adminDetails._id,
                    title: title,
                    category: category,
                    slug,
                    is_active: is_active,
                    created_at: formatedDate,
                });
                const saveSubCat = await newSubCategorailData.save();
                res.json({
                    status: true,
                    data: saveSubCat,
                    msg: "New Sub Category added successfully",
                });
            } else {
                res.json({
                    status: false,
                    data: null,
                    msg: "Not an admin",
                });
            }
        }
    });

})

// delete sub Category
AdminPanel.delete(
    "/DeleteSubCategorailDetails/:id",
    isAdmin,
    async (req, res) => {
        jwt.verify(req.token, process.env.SECRET_KEY, async (err, Data) => {
            if (err) {
                res.status(401).json({
                    err: err,
                    status: false,
                    data: null,
                    msg: "not an admin",
                });
            } else {
                const adminDetails = await findAdminTeacherUsingUserId(Data.studentId);
                if (adminDetails && (adminDetails.Role == "admin" || adminDetails.Role == "subadmin")) {
                    const id = req.params.id;
                    const isSubCatExists = await subCategoryTable.findById(id);
                    if (isSubCatExists) {
                        await subCategoryTable.findByIdAndDelete(id);
                        await savePanelEventLogs(
                            adminDetails._id,
                            "deleteBatchSubCategory",
                            "delete",
                            isSubCatExists
                        )
                        res.json({
                            status: true,
                            data: null,
                            msg: `${isSubCatExists.title} deleted successfully`,
                        });
                    } else {
                        res.json({
                            status: false,
                            data: null,
                            msg: "Sub Category not found",
                        });
                    }
                } else {
                    res.json({
                        status: false,
                        data: null,
                        msg: "UnAuthorized",
                    });
                }
            }
        });
    }
);

//  update sub category
AdminPanel.put(
    "/updateSubCategorialDetails/:id",
    isAdmin,
    async (req, res) => {
        const { title, category, is_active, slug } = req.body;
        if (!title || !category || !slug || is_active === undefined || is_active === null || is_active === '' || slug == undefined) {
            return res.json({
                status: false,
                data: null,
                msg: "required! title, category, is_active slug ",
            });
        }
        const id = req.params.id;
        jwt.verify(req.token, process.env.ADMIN_SECRET_KEY, async (err, Data) => {
            if (err) {
                return res.status(401).json({
                    err: err,
                    status: false,
                    data: null,
                    msg: "not an admin",
                });
            } else {
                const adminDetails = await findAdminTeacherUsingUserId(Data.studentId);
                if (adminDetails && (adminDetails.Role == "admin" || adminDetails.Role == "subadmin")) {
                    const isSubCatExists = await subCategoryTable.findById(id);
                    if (!isSubCatExists) {
                        return res.json({
                            status: false,
                            data: null,
                            msg: "Category not found"
                        })
                    }
                    const regex = /^[A-Za-z0-9\s\-]+$/;
                    let isValid = regex.test(slug);
                    if (!isValid && slug) {
                        return res.json({
                            status: false,
                            data: null,
                            msg: 'Slug can contain only characters & number '
                        })
                    }
                    let genSlug = await generateSlug(slug);
                    const isExistSlug = await subCategoryTable.findOne({ _id: { $ne: id }, slug: genSlug });
                    if (isExistSlug) {
                        return res.json({
                            status: false,
                            data: null,
                            msg: "Sub Category  Slug already exist"
                        })
                    }
                    // let genSlug = await generateSlug(slug);
                    await subCategoryTable.findByIdAndUpdate(id, {
                        category, title, is_active, slug
                    }
                    );
                    return res.json({
                        status: true,
                        data: null,
                        msg: "Updated the Sub category details",
                    });
                } else {
                    return res.json({
                        status: false,
                        data: null,
                        msg: "UnAuthorized",
                    });
                }
            }
        });
    }
);

// get All sub Category
AdminPanel.get(
    "/getSubCategorialDetails",
    ValidateToken,
    async (req, res) => {
        jwt.verify(req.token, process.env.SECRET_KEY, async (err, Data) => {
            if (err) {
                res.status(401).json({
                    err: err,
                    status: false,
                    data: null,
                    msg: "not an admin",
                });
            } else {
                const adminDetails = await findAdminTeacherUsingUserId(Data.studentId);
                if (adminDetails && (adminDetails.Role == "admin" || adminDetails.Role == "subadmin")) {
                    const subCategory = await subCategoryTable.find({}).populate('user', '_id FullName Role').populate({ path: "category", select: "_id, title" }).sort({ createdAt: -1 });
                    if (subCategory) {
                        res.json({
                            status: true,
                            data: subCategory?.map((item, index) => {
                                return {
                                    sno: index + 1,
                                    id: item._id,
                                    category: { id: item?.category?._id ?? "", title: item?.category?.title ?? "NA" },
                                    title: item.title,
                                    admin: item?.user,
                                    is_active: item.is_active,
                                    created_at: item.created_at,
                                    createdAt: moment(item?.createdAt).format('DD-MM-YYYY'),
                                }
                            }),
                            msg: "Sub Categories",
                        });
                    } else {
                        res.json({
                            status: false,
                            data: null,
                            msg: "Not Sub-Category found",
                        });
                    }
                } else {
                    res.json({
                        status: false,
                        data: null,
                        msg: "no authority to perform the specific task",
                    });
                }
            }
        });
    }
);

// get SubCategory by category Id
AdminPanel.get(
    "/getSubCategorialDetailsByCategoryId/:categoryId",
    ValidateToken,
    async (req, res) => {
        jwt.verify(req.token, process.env.SECRET_KEY, async (err, Data) => {
            if (err) {
                res.status(401).json({
                    err: err,
                    status: false,
                    data: null,
                    msg: "not an admin",
                });
            } else {
                const adminDetails = await findAdminTeacherUsingUserId(Data.studentId);
                if (adminDetails && (adminDetails.Role == "admin" || adminDetails.Role == "subadmin")) {
                    const categoryId = req.params.categoryId;
                    const subCategoryDetails = await subCategoryTable.find({
                        category: categoryId
                    }).populate({ path: "category", select: "_id, title" });
                    if (subCategoryDetails) {
                        res.json({
                            status: true,
                            data: subCategoryDetails,
                            msg: "All sub Categories",
                        });
                    } else {
                        res.json({
                            status: false,
                            data: null,
                            msg: "the sub Category details not found ",
                        });
                    }
                } else {
                    res.json({
                        status: false,
                        data: null,
                        msg: "no authority to perform the specific task",
                    });
                }
            }
        });
    }
);


// api for previous year Paper
AdminPanel.post(
    "/addPreviousYearQuestionPapersDetails",
    ValidateToken,
    upload.single("file"),
    async (req, res) => {
        const { title, is_active, language, category, subCategory } = req.body;
        jwt.verify(req.token, process.env.ADMIN_SECRET_KEY, async (err, Data) => {
            if (err) {
                res.status(401).json({
                    status: false,
                    data: null,
                    msg: err,
                });
            } else {
                const adminDetails = await findAdminTeacherUsingUserId(Data.studentId);
                const date = new Date(moment().add(5, "hours").add(30, "minutes"));
                if (adminDetails && (adminDetails.Role == "admin" || adminDetails.Role == "subadmin")) {
                    let FileUploadLocation;
                    let fileLoc;
                    let formatedDate = formatDate(date);
                    if (req.file) {
                        const helperString = Math.floor(Date.now() / 1000);
                        const filename = (req.file.originalname.split(".")[0]).replace(/\s+/g, '_').replace(/[^a-zA-Z0-9_]/g, '');
                        const extension = "." + req.file.originalname.split(".").pop();
                        FileUploadLocation = `PYQ/${title?.replace(/\s+/g, '_').replace(/[^a-zA-Z0-9_]/g, '')}/${filename}_${helperString}${extension}`;
                        let fileLocHelper = await uploadFile(
                            req.file.path,
                            FileUploadLocation
                        );
                        fileLoc = fileDetails(req.file, fileLocHelper);
                    }
                    const newPYQ = new previousYearQuestionPapersTable({
                        user: adminDetails._id,
                        file_url: fileLoc,
                        is_active,
                        title,
                        category,
                        subCategory,
                        created_At: formatedDate,
                        language
                    });
                    const savePYQData = await newPYQ.save();
                    if (is_active) {
                        const data = {
                            title: title,
                            message: `${title} Previous Year Question Paper Added`,
                            fileUrl: "",
                            route: "pyqs",
                            rootId: "",
                            childId: ""
                        };
                        await sendCustomNotification('all', data);
                    }
                    res.json({
                        status: true,
                        data: savePYQData,
                        msg: "added Previous Year Question Paper details successfully",
                    });
                } else {
                    res.json({
                        status: false,
                        data: null,
                        msg: "not an admin",
                    });
                }
            }
        });
    }
);

//Deleting the previous year question paper Details
AdminPanel.delete(
    "/deletePreviousYearQuestionPapersDetails/:id",
    ValidateToken,
    async (req, res) => {
        jwt.verify(req.token, process.env.SECRET_KEY, async (err, Data) => {
            if (err) {
                res.status(401).json({
                    err: err,
                    status: false,
                    data: null,
                    msg: "not an admin",
                });
            } else {
                const adminDetails = await findAdminTeacherUsingUserId(Data.studentId);
                if (adminDetails && (adminDetails.Role == "admin" || adminDetails.Role == "subadmin")) {
                    const id = req.params.id;
                    const isExistPYQ = await previousYearQuestionPapersTable.findById(id);
                    if (isExistPYQ) {
                        await previousYearQuestionPapersTable.findByIdAndDelete(id);
                        await savePanelEventLogs(
                            adminDetails._id,
                            "deletePYQ",
                            "delete",
                            isExistPYQ
                        )
                        res.json({
                            status: true,
                            data: null,
                            msg: "PYQ Data deleted Successfully",
                        });
                    } else {
                        res.json({
                            status: false,
                            data: null,
                            msg: "PYQ data not Found ",
                        });
                    }
                } else {
                    res.json({
                        status: false,
                        data: null,
                        msg: "no authority to perform the specific task",
                    });
                }
            }
        });
    }
);

//Updating the previous year Question Paper Details
AdminPanel.put(
    "/updatePreviousYearQuestionPapersDetails/:id",
    ValidateToken,
    upload.single("file"),
    async (req, res) => {
        const { title, is_active, language, category, subCategory } = req.body;
        jwt.verify(req.token, process.env.ADMIN_SECRET_KEY, async (err, Data) => {
            if (err) {
                res.status(401).json({
                    err: err,
                    status: false,
                    data: null,
                    msg: "not an admin",
                });
            } else {
                const date = new Date(moment().add(5, "hours").add(30, "minutes"));
                const adminDetails = await findAdminTeacherUsingUserId(Data.studentId);
                if (adminDetails && (adminDetails.Role == "admin" || adminDetails.Role == "subadmin")) {
                    const id = req.params.id;
                    const isExistPYQ = await previousYearQuestionPapersTable.findById(id);
                    if (isExistPYQ) {
                        let FileUploadLocation;
                        let fileLoc;
                        if (req.file) {
                            const helperString = Math.floor(Date.now() / 1000);
                            const filename = (req.file.originalname.split(".")[0]).replace(/\s+/g, '_').replace(/[^a-zA-Z0-9_]/g, '');
                            const extension = "." + req.file.originalname.split(".").pop();
                            FileUploadLocation = `PYQ/${title?.replace(/\s+/g, '_').replace(/[^a-zA-Z0-9_]/g, '')}/${filename}_${helperString}${extension}`;
                            let fileLocHelper = await uploadFile(
                                req.file.path,
                                FileUploadLocation
                            );
                            fileLoc = fileDetails(req.file, fileLocHelper);
                        } else {
                            fileLoc = isExistPYQ?.file_url
                        }
                        await previousYearQuestionPapersTable.findByIdAndUpdate(id, {
                            file_url: fileLoc, is_active, title, category, subCategory, language,
                        }
                        );
                        res.json({
                            status: true,
                            data: id,
                            msg: "Updated the Previous Year Question Paper details",
                        });
                    } else {
                        res.json({
                            status: false,
                            data: null,
                            msg: "PYQ Not Found",
                        });
                    }
                } else {
                    res.json({
                        status: false,
                        data: null,
                        msg: "Admin details not found in database",
                    });
                }
            }
        });
    }
);

// get the all previos Year Question paper at Admin Side
AdminPanel.get(
    "/getPreviousYearQuestionPapersDetails",
    isAdmin,
    async (req, res) => {
        jwt.verify(req.token, process.env.SECRET_KEY, async (err, Data) => {
            if (err) {
                res.status(401).json({
                    err: err,
                    status: false,
                    data: null,
                    msg: "not an admin",
                });
            } else {
                const adminDetails = await findAdminTeacherUsingUserId(Data.studentId);
                if (adminDetails && (adminDetails.Role == "admin" || adminDetails.Role == "subadmin")) {
                    const pyqData = await previousYearQuestionPapersTable.find({}).populate({
                        path: "subCategory",
                        select: "_id title",
                    }).populate({
                        path: "category",
                        select: "_id title",
                    })
                    // }).populate("subategory");
                    if (pyqData) {
                        res.json({
                            status: true,
                            data: pyqData?.map((item) => {
                                return {
                                    id: item._id,
                                    category: item.category,
                                    subCategory: item.subCategory,
                                    title: item.title,
                                    file_url: item.file_url,
                                    is_active: item.is_active,
                                    language: item.language,
                                    created_At: item.created_At
                                }
                            }),
                            msg: "PYQ details",
                        });
                    } else {
                        res.json({
                            status: false,
                            data: null,
                            msg: "PYQ data not found ",
                        });
                    }
                } else {
                    res.json({
                        status: false,
                        data: null,
                        msg: "no authority to perform the specific task",
                    });
                }
            }
        });
    }
);

// PYQ Details for User
AdminPanel.get(
    "/getPYQ",
    ValidateToken,
    async (req, res) => {
        jwt.verify(req.token, process.env.SECRET_KEY, async (err, Data) => {
            if (err) {
                return res.json({
                    err: err,
                    status: false,
                    data: null,
                    msg: "not an admin",
                });
            } else {
                let filterQ = {
                    is_active: true,
                    // language: isUser?.language ?? "en"
                }
                const isUser = await findUserByUserId(Data.studentId);
                if (isUser) {
                    const { category } = req.query;

                    if (category) {
                        filterQ = {
                            is_active: true,
                            category: category,
                            // language: isUser?.language ?? "en"
                        }
                    }
                    const pyqData = await previousYearQuestionPapersTable.find(filterQ).sort({ createdAt: -1 })
                        .populate({
                            path: "subCategory",
                            select: "_id title",

                        }).populate({
                            path: "category",
                            select: "_id title",
                        })
                    if (pyqData) {
                        res.json({
                            status: true,
                            data: pyqData?.map((item) => {
                                return {
                                    id: item._id,
                                    category: item.category ?? { _id: "", title: "" },
                                    subCategory: item.subCategory,
                                    title: item.title,
                                    file_url: item.file_url,
                                    is_active: item.is_active,
                                    language: item.language,
                                    created_At: item.created_At
                                }
                            }),
                            msg: "PYQ details",
                        });
                    } else {
                        res.json({
                            status: false,
                            data: null,
                            msg: "No PYQ data found ",
                        });
                    }
                } else {
                    res.json({
                        status: false,
                        data: null,
                        msg: "User Not Found",
                    });
                }
            }
        });
    }
);


//addLecture Route
AdminPanel.post(
    "/addLecture",
    ValidateToken,
    // upload.single("file"),
    // upload.single("file2"),
    // upload.array(['file', 'file2'], 1),
    upload.fields([{
        name: 'file', maxCount: 1
    }, {
        name: 'file2', maxCount: 1
    },
    {
        name: 'file3', maxCount: 1
    }
    ]),
    async (req, res) => {
        const {
            lecture_type,
            lecture_title,
            batch_id,
            description,
            // is_active,
            starting_date,
            ending_date,
            subject_id,
            teacher,
            language,
            link,
            LiveOrRecorded,
            isActive,
            socketUrl
        } = req.body;
        jwt.verify(req.token, process.env.ADMIN_SECRET_KEY, async (err, Data) => {
            if (err) {
                res.status(401).json({
                    err: err,
                    status: false,
                    data: null,
                    msg: "not an admin",
                });
            } else {
                if (lecture_type == 'TWOWAY' && ['undefined', ''].includes(socketUrl)) {
                    return res.json({
                        status: false,
                        data: null,
                        msg: 'Required Socket Url'
                    })
                }
                let commonName = await generateSlugForCommonName(lecture_title + starting_date);
                let startingDate = moment(starting_date, 'DD-MM-YYYY HH:mm:ss').add(5, 'hours').add(30, 'minutes');
                let endingDate = moment(ending_date, 'DD-MM-YYYY HH:mm:ss').add(5, 'hours').add(30, 'minutes');
                const adminTeacher = await findAdminTeacherUsingUserId(Data.studentId);
                if (adminTeacher) {
                    const date = new Date(moment().add(5, "hours").add(30, "minutes"));
                    let formatedDate = formatDate(date);
                    const batchDetails = await BatchesTable.findOne({
                        _id: batch_id,
                    }).populate('features', '_id feature');
                    if (!batchDetails) {
                        return res.json({
                            status: false,
                            data: null,
                            msg: 'Batch not exist'
                        })
                    }
                    if (!batchDetails?.features?.find((item) => item?.feature == 'lecture')) {
                        return res.json({
                            status: false,
                            data: null,
                            msg: 'This feature not allowed on this batch'
                        })
                    }
                    const FindLecture = await LectureTable.findOne({
                        lecture_title: lecture_title,
                    });
                    if (FindLecture) {
                        res.json({
                            status: false,
                            data: null,
                            msg: "Please use different lecture name",
                        });
                    } else if (lecture_type == "YT" && LiveOrRecorded == "Live") {
                        const dbToken = await getYtToken(adminTeacher._id);
                        let chatId;
                        if (dbToken.status) {
                            chatId = await getChatIdFromUrl(link, dbToken.token.access_token);
                        }
                        let FileUploadLocation;
                        let fileLoc;
                        if (req?.files['file']) {
                            const helperString = Math.floor(Date.now() / 1000);
                            const filename = (req.files['file'][0].originalname.split(".")[0]).replace(/\s+/g, '_').replace(/[^a-zA-Z0-9_]/g, '');
                            const extension = "." + req.files['file'][0].originalname.split(".").pop();
                            FileUploadLocation = `Lecture/${lecture_title?.replace(/\s+/g, '_').replace(/[^a-zA-Z0-9_]/g, '')}/${filename}_${helperString}${extension}`;
                            let fileLocHelper = await uploadFile(
                                req.files['file'][0].path,
                                FileUploadLocation
                            );
                            fileLoc = fileDetails(req.files['file'][0], fileLocHelper);
                        }
                        let fileLoc2;
                        if (req?.files['file2']) {
                            const helperString = Math.floor(Date.now() / 1000);
                            const filename = (req.files['file2'][0].originalname.split(".")[0]).replace(/\s+/g, '_').replace(/[^a-zA-Z0-9_]/g, '');
                            const extension = "." + req.files['file2'][0].originalname.split(".").pop();
                            FileUploadLocation = `Lecture/${lecture_title?.replace(/\s+/g, '_').replace(/[^a-zA-Z0-9_]/g, '')}/${filename}_${helperString}${extension}`;
                            let fileLocHelper = await uploadFile(
                                req.files['file2'][0].path,
                                FileUploadLocation
                            );
                            fileLoc2 = fileDetails(req.files['file2'][0], fileLocHelper);
                        }
                        let lectureBanner = "";
                        if (req.files['file3']) {
                            let size = req.files['file3'].size / (1024);
                            if (size > 100) {
                                return res.json({
                                    status: false,
                                    data: null,
                                    msg: 'Maximum banner size 100KB allowed'
                                })
                            }
                            const helperString = Math.floor(Date.now() / 1000);
                            const filename = (req.files['file3'][0].originalname.split(".")[0]).replace(/\s+/g, '_').replace(/[^a-zA-Z0-9_]/g, '');
                            const extension = "." + req.files['file3'][0].originalname.split(".").pop();
                            FileUploadLocation = `lectureBanner/${lecture_title?.replace(/\s+/g, '_').replace(/[^a-zA-Z0-9_]/g, '')}/${filename}_${helperString}${extension}`;
                            let helperfileLoc = await uploadFile(req.files['file3'][0].path, FileUploadLocation);
                            lectureBanner = helperfileLoc;
                            //  fileLoc.push(helperfileLoc);
                        }
                        const findSubject = await SubjectTable.findOne({
                            _id: subject_id,
                        });
                        const findTeacher = await adminTeacherTable.findOne({
                            _id: teacher,
                        });
                        if (findSubject && findTeacher) {
                            const LectureDetails = new LectureTable({
                                user_admin: adminTeacher._id,
                                batch: batchDetails._id,
                                lecture_title: lecture_title,
                                description: description,
                                // is_active: is_active,
                                lecture_type: lecture_type,
                                starting_date: starting_date,
                                ending_date: ending_date,
                                startingDate,
                                endingDate,
                                material: fileLoc,
                                subject: findSubject._id,
                                link: link,
                                dpp: fileLoc2,
                                teacher: [findTeacher._id],
                                ytLiveChatId: chatId ? chatId : "",
                                language: language,
                                LiveOrRecorded: LiveOrRecorded,
                                created_at: formatedDate,
                                isActive,
                                socketUrl,
                                commonName,
                                banner: lectureBanner,
                            });
                            const lectureSaved = await LectureDetails.save();
                            if (isActive == 'true') {
                                // console.log('isActive is true')
                                const data = {
                                    title: `${batchDetails?.batch_name} Class.!!`,
                                    message: `Dear ${batchDetails?.batch_name} Students, ${lecture_title} class has been scheduled at ${moment(lectureSaved.starting_date).format("DD MMM HH:mm A")}`,
                                    fileUrl: lectureSaved?.banner != "" ? lectureSaved?.banner : "https://static.sdcampus.com/assets/lecture_default_1732539568.jpg",
                                    route: "lectureById",
                                    rootId: `${lectureSaved?._id}`,
                                    childId: ""
                                };
                                await sendCustomNotification(batchDetails?.student, data);
                            }
                            res.json({
                                status: true,
                                data: [LectureDetails, { fileUploadLoc: fileLoc, dppUploadFileLoc: fileLoc2 }],
                                msg: "added the Lecture details successfully",
                            });
                        } else {
                            res.json({
                                status: false,
                                data: null,
                                msg: "Subject not found",
                            });
                        }
                    } else {
                        let FileUploadLocation;
                        let fileLoc;
                        if (req?.files['file']) {
                            const helperString = Math.floor(Date.now() / 1000);
                            const filename = (req.files['file'][0].originalname.split(".")[0]).replace(/\s+/g, '_').replace(/[^a-zA-Z0-9_]/g, '');
                            const extension = "." + req.files['file'][0].originalname.split(".").pop();
                            FileUploadLocation = `Lecture/${lecture_title?.replace(/\s+/g, '_').replace(/[^a-zA-Z0-9_]/g, '')}/${filename}_${helperString}${extension}`;
                            let fileLocHelper = await uploadFile(
                                req.files['file'][0].path,
                                FileUploadLocation
                            );
                            fileLoc = fileDetails(req.files['file'][0], fileLocHelper);
                        }
                        let fileLoc2;
                        if (req?.files['file2']) {
                            const helperString = Math.floor(Date.now() / 1000);
                            const filename = (req.files['file2'][0].originalname.split(".")[0]).replace(/\s+/g, '_').replace(/[^a-zA-Z0-9_]/g, '');
                            const extension = "." + req.files['file2'][0].originalname.split(".").pop();
                            FileUploadLocation = `Lecture/${lecture_title?.replace(/\s+/g, '_').replace(/[^a-zA-Z0-9_]/g, '')}/${filename}_${helperString}${extension}`;
                            let fileLocHelper = await uploadFile(
                                req.files['file2'][0].path,
                                FileUploadLocation
                            );
                            fileLoc2 = fileDetails(req.files['file2'][0], fileLocHelper);
                        }
                        let lectureBanner = "";
                        if (req.files['file3']) {
                            let size = req.files['file3'].size / (1024);
                            if (size > 100) {
                                return res.json({
                                    status: false,
                                    data: null,
                                    msg: 'Maximum banner size 100KB allowed'
                                })
                            }
                            const helperString = Math.floor(Date.now() / 1000);
                            const filename = (req.files['file3'][0].originalname.split(".")[0]).replace(/\s+/g, '_').replace(/[^a-zA-Z0-9_]/g, '');
                            const extension = "." + req.files['file3'][0].originalname.split(".").pop();
                            FileUploadLocation = `lectureBanner/${lecture_title?.replace(/\s+/g, '_').replace(/[^a-zA-Z0-9_]/g, '')}/${filename}_${helperString}${extension}`;
                            let helperfileLoc = await uploadFile(req.files['file3'][0].path, FileUploadLocation);
                            lectureBanner = helperfileLoc;
                            //  fileLoc.push(helperfileLoc);
                        }
                        const findSubject = await SubjectTable.findOne({
                            _id: subject_id,
                        });
                        const findTeacher = await adminTeacherTable.findOne({
                            _id: teacher
                        })
                        if (findSubject && findTeacher) {
                            const LectureDetails = new LectureTable({
                                user_admin: adminTeacher._id,
                                batch: batchDetails._id,
                                lecture_title: lecture_title,
                                description: description,
                                // is_active: is_active,
                                lecture_type: lecture_type,
                                starting_date: starting_date,
                                ending_date: ending_date,
                                startingDate,
                                endingDate,
                                material: fileLoc,
                                dpp: fileLoc2,
                                subject: findSubject._id,
                                teacher: [findTeacher._id],
                                link: link,
                                ytLiveChatId: "",
                                language: language,
                                LiveOrRecorded: LiveOrRecorded,
                                created_at: formatedDate,
                                isActive,
                                socketUrl,
                                commonName,
                                banner: lectureBanner
                            });

                            const lectureSaved = await LectureDetails.save();
                            if (lecture_type == "TWOWAY") {
                                roomCreation(batchDetails._id, lectureSaved?._id, findTeacher?._id, 'new');
                            }
                            if (isActive == 'true') {
                                // console.log( 'isActive is true')
                                const data = {
                                    title: `${batchDetails?.batch_name} Class.!!`,
                                    message: `Dear ${batchDetails?.batch_name} Students, ${lecture_title} class has been scheduled at ${moment(lectureSaved.starting_date).format("DD MMM HH:mm A")}`,
                                    fileUrl: lectureSaved?.banner != "" ? lectureSaved?.banner : "https://static.sdcampus.com/assets/lecture_default_1732539568.jpg",
                                    route: "lectureById",
                                    rootId: `${lectureSaved?._id}`,
                                    childId: ""
                                };
                                await sendCustomNotification(batchDetails?.student, data);
                            }
                            res.json({
                                status: true,
                                data: [LectureDetails, { fileUploadLoc: fileLoc, dppUploadFileLoc: fileLoc2 }],
                                msg: "added the Lecture details successfully",
                            });
                        } else {
                            res.json({
                                status: false,
                                data: null,
                                msg: "Subject Or Teacher not found",
                            });
                        }
                    }
                } else {
                    res.json({
                        status: false,
                        data: null,
                        msg: "not an admin or teacher ",
                    });
                }
            }
        });
    }
);

AdminPanel.post(
    "/addCenterLecture",
    ValidateToken,
    upload.fields([{
        name: 'file', maxCount: 1
    }, {
        name: 'file1', maxCount: 1
    },
    {
        name: 'file3', maxCount: 1
    }

    ]),
    async (req, res) => {
        const {
            lecture_type,
            lecture_title,
            batches,
            description,
            // is_active,
            starting_date,
            ending_date,
            teacher,
            subject_id,
            language,
            link,
            LiveOrRecorded,
            isActive,
            socketUrl
        } = req.body;
        try {
            jwt.verify(req.token, process.env.ADMIN_SECRET_KEY, async (err, Data) => {
                if (err) {
                    res.status(401).json({
                        err: err,
                        status: false,
                        data: null,
                        msg: "not an admin",
                    });
                } else {
                    if (lecture_type == 'TWOWAY' && (['undefined', ''].includes(socketUrl) || LiveOrRecorded != "Live")) {
                        return res.json({
                            status: false,
                            data: null,
                            msg: 'Required Socket Url Or Lecture can not be recorded'
                        })
                    }
                    if (lecture_type != 'TWOWAY' && ['undefined', '']?.includes(link)) {
                        return res.json({
                            status: false,
                            data: null,
                            msg: 'Required Link'
                        })
                    }
                    let commonName = await generateSlugForCommonName(lecture_title + starting_date);
                    let startingDate = moment(starting_date, 'DD-MM-YYYY HH:mm:ss').add(5, 'hours').add(30, 'minutes');;
                    let endingDate = moment(ending_date, 'DD-MM-YYYY HH:mm:ss').add(5, 'hours').add(30, 'minutes');;
                    // console.log( startingDate , endingDate);
                    const adminTeacher = await findAdminTeacherUsingUserId(Data.studentId);
                    if (adminTeacher) {
                        let lectureBanner = '';
                        if (req.files['file3']) {
                            let size = req.files['file3'].size / (1024);
                            if (size > 100) {
                                return res.json({
                                    status: false,
                                    data: null,
                                    msg: 'Maximum banner size 100KB allowed'
                                })
                            }
                            const helperString = Math.floor(Date.now() / 1000);
                            const filename = (req.files['file3'][0].originalname.split(".")[0]).replace(/\s+/g, '_').replace(/[^a-zA-Z0-9_]/g, '');
                            const extension = "." + req.files['file3'][0].originalname.split(".").pop();
                            FileUploadLocation = `lectureBanner/${lecture_title?.replace(/\s+/g, '_').replace(/[^a-zA-Z0-9_]/g, '')}/${filename}_${helperString}${extension}`;
                            let helperfileLoc = await uploadFile(req.files['file3'][0].path, FileUploadLocation);
                            lectureBanner = helperfileLoc;
                            //  fileLoc.push(helperfileLoc);
                        }
                        const date = new Date(moment().add(5, "hours").add(30, "minutes"));
                        let formatedDate = formatDate(date);
                        const findSubject = await SubjectTable.findOne({
                            _id: subject_id,
                        });
                        const findTeacher = await adminTeacherTable.findOne({
                            _id: teacher
                        });
                        if (!findSubject || !findTeacher) {
                            return res.json({
                                status: false,
                                data: null,
                                msg: 'Subject Or Teacher not found'
                            })
                        }
                        let batchesId = batches.filter((item) => { return item != "" });
                        if (lecture_type == "YT" && LiveOrRecorded == 'Live') {
                            const dbToken = await getYtToken(adminTeacher._id);
                            let chatId;
                            if (dbToken.status) {
                                chatId = await getChatIdFromUrl(link, dbToken.token.access_token);
                            }

                            let FileUploadLocation;
                            let fileLoc;
                            if (req.files['file']) {
                                const helperString = Math.floor(Date.now() / 1000);
                                const filename = (req.files['file'][0].originalname.split(".")[0]).replace(/\s+/g, '_').replace(/[^a-zA-Z0-9_]/g, '');
                                const extension = "." + req.files['file'][0].originalname.split(".").pop();
                                FileUploadLocation = `Lecture/${lecture_title?.replace(/\s+/g, '_').replace(/[^a-zA-Z0-9_]/g, '')}/${filename}_${helperString}${extension}`;
                                let fileLocHelper = await uploadFile(
                                    req.files['file'][0].path,
                                    FileUploadLocation
                                );
                                fileLoc = fileDetails(req.files['file'][0], fileLocHelper);
                            }
                            let fileLoc1;
                            if (req.files['file1']) {
                                const helperString = Math.floor(Date.now() / 1000);
                                const filename = (req.files['file1'][0].originalname.split(".")[0]).replace(/\s+/g, '_').replace(/[^a-zA-Z0-9_]/g, '');
                                const extension = "." + req.files['file1'][0].originalname.split(".").pop();
                                FileUploadLocation = `Lecture/${lecture_title?.replace(/\s+/g, '_').replace(/[^a-zA-Z0-9_]/g, '')}/${filename}_${helperString}${extension}`;
                                let fileLocHelper = await uploadFile(
                                    req.files['file1'][0].path,
                                    FileUploadLocation
                                );
                                fileLoc1 = fileDetails(req.files['file1'][0], fileLocHelper);
                            }
                            for (let batch of batchesId) {
                                const isBatchExist = await BatchesTable.findOne({ _id: batch }).populate('features', '_id feature');
                                if (!isBatchExist) {
                                    return res.json({
                                        status: false,
                                        data: null,
                                        msg: 'Batch not found'
                                    })
                                }
                                // console.log(!isBatchExist?.features?.find((item) => item?.feature == 'lecture'))
                                if (!isBatchExist?.features?.find((item) => item?.feature == 'lecture')) {
                                    return res.json({
                                        status: false,
                                        data: null,
                                        msg: 'This feature not allowed on this batch'
                                    })
                                }



                                const LectureDetails = new LectureTable({
                                    user_admin: adminTeacher._id,
                                    // batch: batchDetails._id,
                                    batch: isBatchExist._id,
                                    lecture_title: lecture_title,
                                    description: description,
                                    // is_active: is_active,
                                    lecture_type: lecture_type,
                                    starting_date: starting_date,
                                    ending_date: ending_date,
                                    startingDate,
                                    endingDate,
                                    material: fileLoc,
                                    dpp: fileLoc1,
                                    teacher: [findTeacher?._id],
                                    subject: findSubject._id,
                                    link: link,
                                    ytLiveChatId: chatId ? chatId : "",
                                    language: language,
                                    LiveOrRecorded: LiveOrRecorded,
                                    created_at: formatedDate,
                                    isActive,
                                    commonName,
                                    socketUrl,
                                    banner: lectureBanner
                                });
                                const lectureSaved = await LectureDetails.save();
                                if (isActive == 'true') {
                                    const data = {
                                        title: `${isBatchExist?.batch_name} Class.!!`,
                                        message: `Dear ${isBatchExist?.batch_name} Students, ${lecture_title} class has been scheduled at ${moment(lectureSaved.starting_date).format("DD MMM HH:mm A")}`,
                                        fileUrl: lectureSaved?.banner != "" ? lectureSaved?.banner : "https://static.sdcampus.com/assets/lecture_default_1732539568.jpg",
                                        route: "lectureById",
                                        rootId: `${lectureSaved?._id}`,
                                        childId: ""
                                    };
                                    await sendCustomNotification(isBatchExist?.student, data);
                                }
                            }
                            return res.json({
                                status: true,
                                data: null,
                                msg: `Lectures is added for all given batches`
                            })
                        } else {
                            let FileUploadLocation;
                            let fileLoc;
                            if (req.files['file']) {
                                const helperString = Math.floor(Date.now() / 1000);
                                const filename = (req.files['file'][0].originalname.split(".")[0]).replace(/\s+/g, '_').replace(/[^a-zA-Z0-9_]/g, '');
                                const extension = "." + req.files['file'][0].originalname.split(".").pop();
                                FileUploadLocation = `Lecture/${lecture_title?.replace(/\s+/g, '_').replace(/[^a-zA-Z0-9_]/g, '')}/${filename}_${helperString}${extension}`;
                                let fileLocHelper = await uploadFile(
                                    req.files['file'][0].path,
                                    FileUploadLocation
                                );
                                fileLoc = fileDetails(req.files['file'][0], fileLocHelper);
                            }
                            let fileLoc1;
                            if (req.files['file1']) {
                                const helperString = Math.floor(Date.now() / 1000);
                                const filename = (req.files['file1'][0].originalname.split(".")[0]).replace(/\s+/g, '_').replace(/[^a-zA-Z0-9_]/g, '');
                                const extension = "." + req.files['file1'][0].originalname.split(".").pop();
                                FileUploadLocation = `Lecture/${lecture_title?.replace(/\s+/g, '_').replace(/[^a-zA-Z0-9_]/g, '')}/${filename}_${helperString}${extension}`;
                                let fileLocHelper = await uploadFile(
                                    req.files['file1'][0].path,
                                    FileUploadLocation
                                );
                                fileLoc1 = fileDetails(req.files['file1'][0], fileLocHelper);
                            }
                            for (let batch of batchesId) {
                                const isBatchExist = await BatchesTable.findOne({ _id: batch });
                                if (!isBatchExist) {
                                    return res.json({
                                        status: false,
                                        data: null,
                                        msg: 'Batch not found'
                                    })
                                }

                                const LectureDetails = new LectureTable({
                                    user_admin: adminTeacher._id,
                                    // batch: batchDetails._id,
                                    batch: isBatchExist._id,
                                    lecture_title: lecture_title,
                                    description: description,
                                    // is_active: is_active,
                                    lecture_type: lecture_type,
                                    starting_date: starting_date,
                                    ending_date: ending_date,
                                    startingDate,
                                    endingDate,
                                    material: fileLoc,
                                    dpp: fileLoc1,
                                    teacher: [findTeacher?._id],
                                    subject: findSubject._id,
                                    link: link,
                                    // ytLiveChatId: chatId ? chatId : "",
                                    ytLiveChatId: "",
                                    language: language,
                                    LiveOrRecorded: LiveOrRecorded,
                                    created_at: formatedDate,
                                    isActive,
                                    commonName,
                                    socketUrl,
                                    banner: lectureBanner
                                });
                                const lectureSaved = await LectureDetails.save();
                                if (lecture_type == "TWOWAY") {
                                    roomCreation(isBatchExist?._id, lectureSaved?._id, findTeacher?._id, 'new');
                                }
                                if (isActive == 'true') {
                                    // console.log('isAcctive true')
                                    const data = {
                                        title: `${isBatchExist?.batch_name} Class.!!`,
                                        message: `Dear ${isBatchExist?.batch_name} Students, ${lecture_title} class has been scheduled at ${moment(lectureSaved.starting_date).format("DD MMM HH:mm A")}`,
                                        fileUrl: lectureSaved?.banner != "" ? lectureSaved?.banner : "https://static.sdcampus.com/assets/lecture_default_1732539568.jpg",
                                        route: "lectureById",
                                        rootId: `${lectureSaved?._id}`,
                                        childId: ""
                                    };
                                    await sendCustomNotification(isBatchExist?.student, data);
                                }


                            }
                            return res.json({
                                status: true,
                                data: null,
                                msg: `Lectures is added for all given batches`
                            })

                        }
                    } else {
                        res.json({
                            status: false,
                            data: null,
                            msg: "not an admin or teacher ",
                        });
                    }
                }

            })
        } catch (error) {
            return res.json({
                status: false,
                data: null,
                msg: error.message
            })
        }
    }
);


AdminPanel.put(
    "/updateLectureDetails/:id",
    ValidateToken,
    // upload.single("file"),
    upload.fields([
        { name: 'file', maxCount: 1 },
        { name: 'file1', maxCount: 1 },
        { name: 'file3', maxCount: 1 },
    ]),
    async (req, res) => {
        const {
            lecture_type,
            lecture_title,
            batch_id,
            description,
            is_active,
            starting_date,
            ending_date,
            teacher,
            subject_id,
            link,
            language,
            LiveOrRecorded,
            isActive,
            socketUrl
        } = req.body;
        const { id } = req.params;
        if (!teacher || teacher == 'undefined') {
            return res.json({
                status: false,
                data: null,
                msg: 'Required Teacher'
            })
        }
        if (!['Live', 'Recorded']?.includes(LiveOrRecorded) || !["hi", "en", "enhi"].includes(language)) {
            return res.json({
                status: false,
                data: null,
                msg: 'Type Or language required'
            })
        }
        jwt.verify(req.token, process.env.ADMIN_SECRET_KEY, async (err, Data) => {
            if (err) {
                res.status(401).json({
                    err: err,
                    status: false,
                    data: null,
                    msg: "not an admin",
                });
            } else {

                if (lecture_type == 'TWOWAY' && (['undefined', ''].includes(socketUrl) || LiveOrRecorded != "Live")) {
                    return res.json({
                        status: false,
                        data: null,
                        msg: 'Required Socket Url Or Lecture can not be recorded'
                    })
                }
                if (lecture_type != 'TWOWAY' && ['undefined', '']?.includes(link)) {
                    return res.json({
                        status: false,
                        data: null,
                        msg: 'Required Link'
                    })
                }
                let startingDate = moment(starting_date, 'DD-MM-YYYY HH:mm:ss').add(5, 'hours').add(30, 'minutes');
                let endingDate = moment(ending_date, 'DD-MM-YYYY HH:mm:ss').add(5, 'hours').add(30, 'minutes');
                const adminTeacher = await findAdminTeacherUsingUserId(Data.studentId);
                if (adminTeacher) {
                    const date = new Date(moment().add(5, "hours").add(30, "minutes"));
                    let formatedDate = formatDate(date);
                    const batchDetails = await BatchesTable.findOne({
                        _id: batch_id,
                    });
                    // console.log(lecture_type)
                    const FindLecture = await LectureTable.findOne({
                        _id: id,
                    });
                    if (!FindLecture) {
                        res.json({
                            status: false,
                            data: null,
                            msg: "Lecture Details not found",
                        });
                    } else {
                        let FileUploadLocation;
                        let fileLoc;
                        if (req.files['file']) {
                            const helperString = Math.floor(Date.now() / 1000);
                            const filename = (req.files['file'][0].originalname.split(".")[0]).replace(/\s+/g, '_').replace(/[^a-zA-Z0-9_]/g, '');
                            const extension = "." + req.files['file'][0].originalname.split(".").pop();
                            FileUploadLocation = `Lecture/${lecture_title?.replace(/\s+/g, '_').replace(/[^a-zA-Z0-9_]/g, '')}/${filename}_${helperString}${extension}`;
                            let fileLocHelper = await uploadFile(
                                req.files['file'][0].path,
                                FileUploadLocation
                            );
                            fileLoc = fileDetails(req.files['file'][0], fileLocHelper);
                        }
                        let fileLoc1;
                        if (req?.files['file1']) {
                            const helperString = Math.floor(Date.now() / 1000);
                            const filename = (req.files['file1'][0].originalname.split(".")[0]).replace(/\s+/g, '_').replace(/[^a-zA-Z0-9_]/g, '');
                            const extension = "." + req.files['file1'][0].originalname.split(".").pop();
                            FileUploadLocation = `Lecture/${lecture_title?.replace(/\s+/g, '_').replace(/[^a-zA-Z0-9_]/g, '')}/${filename}_${helperString}${extension}`;
                            let fileLocHelper = await uploadFile(
                                req.files['file1'][0].path,
                                FileUploadLocation
                            );
                            fileLoc1 = fileDetails(req.files['file1'][0], fileLocHelper);
                        }
                        let lectureBanner = '';
                        if (req.files['file3']) {
                            let size = req.files['file3'].size / (1024);
                            if (size > 100) {
                                return res.json({
                                    status: false,
                                    data: null,
                                    msg: 'Maximum banner size 100KB allowed'
                                })
                            }
                            const helperString = Math.floor(Date.now() / 1000);
                            const filename = (req.files['file3'][0].originalname.split(".")[0]).replace(/\s+/g, '_').replace(/[^a-zA-Z0-9_]/g, '');
                            const extension = "." + req.files['file3'][0].originalname.split(".").pop();
                            FileUploadLocation = `lectureBanner/${lecture_title?.replace(/\s+/g, '_').replace(/[^a-zA-Z0-9_]/g, '')}/${filename}_${helperString}${extension}`;
                            let helperfileLoc = await uploadFile(req.files['file3'][0].path, FileUploadLocation);
                            lectureBanner = helperfileLoc;
                            //  fileLoc.push(helperfileLoc);
                        }
                        const findSubject = await SubjectTable.findOne({
                            _id: subject_id,
                        });
                        const findTeacher = await adminTeacherTable.findOne({
                            _id: teacher
                        })
                        if (findSubject && findTeacher) {
                            const newLecture = await LectureTable.findByIdAndUpdate(
                                { _id: id },
                                {
                                    user_admin: adminTeacher._id,
                                    batch: batchDetails._id,
                                    lecture_title: lecture_title,
                                    description: description,
                                    is_active: is_active,
                                    lecture_type: lecture_type,
                                    starting_date: starting_date,
                                    ending_date: ending_date,
                                    startingDate,
                                    endingDate,
                                    material: fileLoc,
                                    dpp: fileLoc1,
                                    teacher: [findTeacher?._id],
                                    subject: findSubject._id,
                                    link: lecture_type != "TWOWAY" ? link : "",
                                    language: language,
                                    LiveOrRecorded: LiveOrRecorded,
                                    isActive,
                                    socketUrl: socketUrl,
                                    banner: lectureBanner != '' ? lectureBanner : FindLecture?.banner,
                                    // created_at: formatedDate,
                                }, { new: true, lean: true }
                            );
                            if (lecture_type === 'TWOWAY') {
                                roomCreation(newLecture?.batch, newLecture?._id, newLecture?.teacher[0], "old")
                            }
                            res.json({
                                status: true,
                                // data: [LectureDetails, { fileUploadLoc: fileLoc }],
                                msg: "updated the lecture  successfully",
                            });
                        } else {
                            res.json({
                                status: false,
                                data: null,
                                msg: "Subject Or Tecaher not found",
                            });
                        }
                    }
                } else {
                    res.json({
                        status: false,
                        data: null,
                        msg: "not an admin or teacher ",
                    });
                }
            }
        });
    }
);

AdminPanel.put("/makeLectureActiveAndInActive/:id", isAdmin, async (req, res) => {
    const { id } = req.params;
    if (!id) {
        return res.json({
            status: false,
            data: null,
            msg: `Required id`
        })
    }
    try {
        const decoded = jwt.verify(req.token, process.env.ADMIN_SECRET_KEY);
        const admin = await findAdminTeacherUsingUserId(decoded?.studentId);
        if (!admin) {
            return res.json({
                status: false,
                data: null,
                msg: 'Not an admin'
            })
        }

        const isLecture = await LectureTable.findOne({ _id: id });
        if (!isLecture) {
            return res.json({
                status: false,
                data: null,
                msg: `Lecture not found`
            })
        }
        let isActive = isLecture.isActive == true ? false : true;
        const newLec = await LectureTable.findByIdAndUpdate(isLecture?._id, { isActive: isActive }, { new: true, lean: true });
        return res.json({
            status: true,
            data: null,
            msg: `${newLec.lecture_title} status change into ${isActive == true ? "Active" : "InActive"}`
        })

    } catch (error) {
        return res.json({
            status: false,
            data: null,
            msg: error.message
        })
    }
})

AdminPanel.get(
    "/getPerticularLectureDetails/:id",
    ValidateToken,
    async (req, res) => {
        const { id } = req.params;
        jwt.verify(req.token, process.env.ADMIN_SECRET_KEY, async (err, Data) => {
            if (err) {
                res.status(401).json({
                    err: err,
                    status: false,
                    data: null,
                    msg: "not an admin",
                });
            } else {
                const adminTeacher = await findAdminTeacherUsingUserId(Data.studentId);
                if (adminTeacher) {
                    const findLectureDetails = await LectureTable.findOne({
                        _id: id,
                    }).populate("subject", { title: 1 }).populate("teacher", { _id: 1, FullName: 1 });
                    if (findLectureDetails) {
                        res.json({
                            status: true,
                            data: findLectureDetails,
                            msg: "fetched the lecture details",
                        });
                    } else {
                        res.json({
                            status: false,
                            data: null,
                            msg: "Lecture details Not Found",
                        });
                    }
                }
            }
        });
    }
);

AdminPanel.delete(
    "/deleteLectureDetails/:id",
    ValidateToken,
    async (req, res) => {
        jwt.verify(req.token, process.env.ADMIN_SECRET_KEY, async (err, Data) => {
            if (err) {
                res.status(401).json({
                    err: err,
                    status: false,
                    data: null,
                    msg: "not an admin",
                });
            } else {
                const adminTeacher = await findAdminTeacherUsingUserId(Data.studentId);
                if (adminTeacher) {
                    const { id } = req.params;
                    const lectureDetails = await LectureTable.findOne({ _id: id });
                    if (lectureDetails) {
                        await LectureResourceTable.deleteMany({
                            lecture: lectureDetails.id,
                        });
                        await RecordedVideoModel.deleteMany({
                            lecture_id: lectureDetails.id,
                        });
                        await LectureTable.findByIdAndDelete({
                            _id: lectureDetails.id,
                        });
                        await savePanelEventLogs(
                            adminTeacher._id,
                            "deleteLecture",
                            "delete",
                            lectureDetails
                        )
                        res.json({
                            status: true,
                            data: null,
                            msg: "Deleted the Lecture Details successfully",
                        });
                    } else {
                        res.json({
                            status: false,
                            data: null,
                            msg: "Lecture Details not found",
                        });
                    }
                } else {
                    res.json({
                        status: false,
                        data: null,
                        msg: "Not authorized",
                    });
                }
            }
        });
    }
);

//adding the teacher to the Lecture
AdminPanel.post("/addTeacherToLecture/:id", ValidateToken, async (req, res) => {
    try {
        const { teacherEmail } = req.body;
        const { id } = req.params;
        const Data = jwt.verify(req.token, process.env.ADMIN_SECRET_KEY);

        const adminTeacher = await findAdminTeacherUsingUserId(Data.studentId);
        if (!adminTeacher) {
            return res.status(401).json({
                status: false,
                data: null,
                msg: "Not an admin",
            });
        }

        const addLectureDetails = await LectureTable.findById(id);
        if (!addLectureDetails) {
            return res.json({
                status: false,
                data: null,
                msg: "Lecture not found",
            });
        }

        const teacherDetails = await adminTeacherTable.findOne({
            email: teacherEmail,
        });
        if (!teacherDetails) {
            return res.json({
                status: false,
                data: null,
                msg: "Teacher not found",
            });
        }

        if (!addLectureDetails.teacher.includes(teacherDetails._id)) {
            addLectureDetails.teacher = teacherDetails._id;
        }

        await addLectureDetails.save();
        res.json({
            status: true,
            data: addLectureDetails,
            msg: "Added the teacher",
        });
    } catch (err) {
        res.status(401).json({
            status: false,
            data: null,
            msg: "Invalid token",
        });
    }
});

//Delete The teacher From Lecture
AdminPanel.delete(
    "/DeleteTheTeacherFromLecture/:id",
    isAdmin,
    async (req, res) => {
        const { id } = req.params;
        const { teacher_id } = req.body;
        jwt.verify(req.token, process.env.ADMIN_SECRET_KEY, async (err, Data) => {
            if (err) {
                res.status(401).json({
                    err: err,
                    status: false,
                    data: null,
                    msg: "not an admin",
                });
            } else {
                const adminTeacher = await findAdminTeacherUsingUserId(Data.studentId);
                if (adminTeacher) {
                    const Lecturedetails = await LectureTable.findOne({ _id: id });
                    if (Lecturedetails) {
                        let HelperArray = [];
                        let teacherArray = Lecturedetails.teacher;
                        for (let i = 0; i < teacherArray.length; i++) {
                            if (teacherArray[i] != teacher_id) {
                                HelperArray.push(teacherArray);
                            }
                        }
                        await LectureTable.findByIdAndUpdate(
                            { _id: id },
                            { teacher: HelperArray }
                        );
                        await savePanelEventLogs(
                            adminTeacher?._id,
                            "deleteTeacherFromLecture",
                            "delete",
                            Lecturedetails
                        )
                        res.json({
                            status: true,
                            data: null,
                            msg: "Removed the teacher form the Lecture",
                        });
                    } else {
                        res.json({
                            status: false,
                            data: null,
                            msg: "Lecture details Not Found",
                        });
                    }
                } else {
                    res.json({
                        status: false,
                        data: null,
                        msg: "not an admin",
                    });
                }
            }
        });


    }
);

//adding the student to the Lecture
AdminPanel.post("/addStudentToLecture/:id", ValidateToken, async (req, res) => {
    const { StudentEmail } = req.body;
    const { id } = req.params;
    jwt.verify(req.token, process.env.ADMIN_SECRET_KEY, async (err, Data) => {
        if (err) {
            res.status(401).json({
                err: err,
                status: false,
                data: null,
                msg: "not an admin",
            });
        } else {
            const adminTeacher = await findAdminTeacherUsingUserId(Data.studentId);
            if (adminTeacher) {
                const addLectureDetails = await LectureTable.findOne({
                    _id: id,
                });
                const StudentDetails = await findUserByEmail(StudentEmail);
                if (StudentDetails) {
                    if (addLectureDetails.student.includes(StudentDetails._id)) {
                        res.json({
                            status: false,
                            data: null,
                            msg: "student already exists",
                        });
                    } else {
                        addLectureDetails.student.push(StudentDetails._id);
                        addLectureDetails.save();
                        res.json({
                            status: true,
                            data: addLectureDetails,
                            msg: "added the Student ",
                        });
                    }
                } else {
                    res.json({
                        status: false,
                        data: null,
                        msg: "Student not found ",
                    });
                }
            } else {
                res.json({
                    status: false,
                    data: null,
                    msg: "not an admin",
                });
            }
        }
    });
});

//get the Lecture details
AdminPanel.get("/getLecturedetails", ValidateToken, async (req, res) => {
    const { BatchId, teacher_id } = req.query;
    jwt.verify(req.token, process.env.ADMIN_SECRET_KEY, async (err, Data) => {
        if (err) {
            res.status(401).json({
                err: err,
                status: false,
                data: null,
                msg: "not an admin",
            });
        } else {
            const adminDetails = await findAdminTeacherUsingUserId(Data.studentId);
            if (adminDetails) {
                const LectureDetails = await LectureTable.find(
                    { isActive: true },
                    { user_admin: 0, __v: 0 }
                )
                    .populate("subject")
                    .populate("teacher", {
                        FullName: 1,
                        _id: 1,
                        profilePhoto: 1,
                    });
                if (BatchId && !teacher_id) {
                    let FilterBatch = LectureDetails.filter((Lecture) => {
                        return Lecture.batch == BatchId;
                    });
                    res.json({
                        status: true,
                        data: FilterBatch,
                        msg: "Fetched the Lecture Details",
                    });
                } else if (teacher_id && !BatchId) {
                    let FilterBatch = LectureDetails.filter((Lecture) => {
                        let check = false;
                        for (let i = 0; i < Lecture.teacher.length; i++) {
                            if (Lecture.teacher[i]._id == teacher_id) {
                                check = true;
                                break;
                            }
                        }
                        return check == true;
                    });
                    res.json({
                        status: true,
                        data: FilterBatch,
                        msg: "Fetched the Lecture Details",
                    });
                } else if (teacher_id != undefined && BatchId != undefined) {
                    let FilterBatch = LectureDetails.filter((Lecture) => {
                        let check = false;
                        for (let i = 0; i < Lecture.teacher.length; i++) {
                            if (Lecture.teacher[i]._id == teacher_id) {
                                check = true;
                                break;
                            }
                        }
                        return Lecture.batch == BatchId && check == true;
                    });
                    res.json({
                        status: true,
                        data: FilterBatch,
                        msg: "fetched all the Lecture Details based on batch and teacher",
                    });
                } else {
                    res.json({
                        status: true,
                        data: LectureDetails,
                        msg: "fecthed all the Lecture details",
                    });
                }
            } else {
                res.json({
                    status: false,
                    data: null,
                    msg: "Not authority",
                });
            }
        }
    });
});

AdminPanel.get("/getLectures", isAdmin, async (req, res) => {
    const { BatchId, teacher_id } = req.query;
    jwt.verify(req.token, process.env.ADMIN_SECRET_KEY, async (err, Data) => {
        if (err) {
            res.status(401).json({
                err: err,
                status: false,
                data: null,
                msg: "not an admin",
            });
        } else {
            const adminDetails = await findAdminTeacherUsingUserId(Data.studentId);
            if (adminDetails) {
                const LectureDetails = await LectureTable.find(
                    {},
                    { __v: 0 }
                )
                    .populate("subject")
                    .populate("user_admin", "_id FullName Role")
                    .populate("teacher", {
                        FullName: 1,
                        _id: 1,
                        profilePhoto: 1,
                    }).sort({ _id: -1 });
                if (BatchId && !teacher_id) {
                    let FilterBatch = LectureDetails.filter((Lecture) => {
                        return Lecture.batch == BatchId;
                    });
                    res.json({
                        status: true,
                        data: await Promise.all(FilterBatch.map(async (item) => {
                            // get resouce of lecture
                            let resources = await LectureResourceTable.find({ lecture: item?._id });
                            let resoucesArr = resources?.map((item2) => {
                                return {
                                    id: item2?._id ?? "",
                                    title: item2?.title ?? "",
                                    resourceType: item2?.resourceType ?? "",
                                    link: item2?.upload_file ?? "",
                                    is_active: item2?.is_active ?? false,
                                }
                            })
                            return {
                                ...item._doc, id: item._id, value: item?._id, label: item?.lecture_title, resources: resoucesArr
                            }

                        })),
                        msg: "Fetched the Lecture Details",
                    });
                } else if (teacher_id && !BatchId) {
                    let FilterBatch = LectureDetails.filter((Lecture) => {
                        let check = false;
                        for (let i = 0; i < Lecture.teacher.length; i++) {
                            if (Lecture.teacher[i]._id == teacher_id) {
                                check = true;
                                break;
                            }
                        }
                        return check == true;
                    });
                    res.json({
                        status: true,
                        data: FilterBatch.map((item) => {
                            return {
                                ...item._doc, id: item._id
                            }
                        }),
                        msg: "Fetched the Lecture Details",
                    });
                } else if (teacher_id != undefined && BatchId != undefined) {
                    let FilterBatch = LectureDetails.filter((Lecture) => {
                        let check = false;
                        for (let i = 0; i < Lecture.teacher.length; i++) {
                            if (Lecture.teacher[i]._id == teacher_id) {
                                check = true;
                                break;
                            }
                        }
                        return Lecture.batch == BatchId && check == true;
                    });
                    res.json({
                        status: true,
                        data: FilterBatch.map((item) => {
                            return {
                                ...item._doc, id: item._id,
                            }
                        }),
                        msg: "fetched all the Lecture Details based on batch and teacher",
                    });
                } else {
                    res.json({
                        status: true,
                        data: LectureDetails.map((item) => {
                            return { ...item._doc, id: item._id }
                        }),
                        msg: "fecthed all the Lecture details",
                    });
                }
            } else {
                res.json({
                    status: false,
                    data: null,
                    msg: "Not authority",
                });
            }
        }
    });
});

AdminPanel.get("/getLecturedetails/:id", ValidateToken, async (req, res) => {
    const { id } = req.params;
    if (!id || id === "") {
        return res.json({
            status: false,
            data: null,
            msg: "Required lecture id"
        })
    }
    jwt.verify(req.token, process.env.ADMIN_SECRET_KEY, async (err, Data) => {
        if (err) {
            res.status(401).json({
                err: err,
                status: false,
                data: null,
                msg: "not an admin",
            });
        } else {
            const adminDetails = await findAdminTeacherUsingUserId(Data.studentId);
            if (adminDetails) {
                const LectureDetails = await LectureTable.findOne({ _id: id }).populate("subject").populate("teacher");
                let rooms = await lectureRoomTable.find({ lecture: LectureDetails?._id }).select('students title _id');

                let response = { ...LectureDetails, socketUrl: 'socketUrl', rooms: rooms.map((item) => { return { roomId: item?._id ?? "", students: item?.students ?? [], title: item?.title } }) };
                res.json({
                    status: true,
                    // data: LectureDetails,
                    data: response,
                    msg: "fecthed all the Lecture details",
                });
            } else {
                res.json({
                    status: false,
                    data: null,
                    msg: "Not authority",
                });
            }
        }
    });
});
//get the cart details
AdminPanel.get("/getCartDetails", ValidateToken, async (req, res) => {
    jwt.verify(req.token, process.env.ADMIN_SECRET_KEY, async (err, Data) => {
        if (err) {
            res.status(401).json({
                err: err,
                status: false,
                data: null,
                msg: "not an admin",
            });
        } else {
            const userDetails = await findUserByUserId(Data.studentId);
            if (userDetails) {
                const CartDetails = await CartTable.find({
                    user: userDetails._id,
                });
                const UserCartDetails = [];
                for (let i = 0; i < CartDetails.length; i++) {
                    let findBatch = await BatchesTable.findOne({
                        _id: CartDetails[i].batch_id,
                    });
                    let helperObj = {
                        cart_id: CartDetails[i]._id,
                        created_at: CartDetails[i].created_at,
                        Amount: CartDetails[i].Amount,
                        is_active: CartDetails[i].is_active,
                        batchDetails: findBatch,
                    };
                    UserCartDetails.push(helperObj);
                }
                if (CartDetails) {
                    res.json({
                        status: true,
                        data: UserCartDetails,
                        msg: "Fetched all the courses in the cart ",
                    });
                } else {
                    res.json({
                        status: false,
                        data: null,
                        msg: "The cart is Empty",
                    });
                }
            } else {
                res.json({
                    status: false,
                    data: null,
                    msg: "Not an user Please Login to access the cart s",
                });
            }
        }
    });
});

//Add the Course to the cart
AdminPanel.post("/addtocart", ValidateToken, async (req, res) => {
    const { batch_id } = req.body;
    jwt.verify(req.token, process.env.ADMIN_SECRET_KEY, async (err, Data) => {
        if (err) {
            res.status(401).json({
                err: err,
                status: false,
                data: null,
                msg: "not an user",
            });
        } else {
            const date = new Date(moment().add(5, "hours").add(30, "minutes"));
            //  let formatedDate=formatDate(date);
            const user = await findUserByUserId(Data.studentId);
            if (user) {
                const batch = await BatchesTable.findOne({ _id: batch_id });
                if (batch) {
                    const findCart = await CartTable.findOne({
                        user: user._id,
                        batch_id: batch._id,
                    });
                    const findMyBatchDetails = await MybatchTable.findOne({
                        batch_id: batch_id,
                        user: user._id,
                    });
                    if (findMyBatchDetails) {
                        res.json({
                            status: false,
                            data: null,
                            msg: "Course has been already taken by the user",
                        });
                    } else {
                        if (findCart && "" + findCart.batch_id == batch._id) {
                            res.json({
                                status: true,
                                data: null,
                                msg: "The Course exists in the cart ",
                            });
                        } else {
                            const addCart = new CartTable({
                                user: user._id,
                                batch_id: batch._id,
                                Amount: batch.charges,
                                created_at: date,
                                is_active: true,
                            });
                            addCart.save();
                            res.json({
                                status: true,
                                data: [{ cartDetails: addCart }, { batchDetails: batch }],
                                msg: "the Course added to the cart Successfully",
                            });
                        }
                    }
                } else {
                    res.json({
                        status: false,
                        data: null,
                        msg: "course details not found",
                    });
                }
            } else {
                res.json({
                    status: false,
                    data: null,
                    msg: "Not an User",
                });
            }
        }
    });
});

//Deleting Cart Details
AdminPanel.delete("/deleteCartDetails/:id", ValidateToken, async (req, res) => {
    const { id } = req.params;
    jwt.verify(req.token, process.env.ADMIN_SECRET_KEY, async (err, Data) => {
        if (err) {
            res.status(401).json({
                err: err,
                status: false,
                data: null,
                msg: "not an user",
            });
        } else {
            const findCart = await CartTable.findOne({ _id: id });
            if (findCart) {
                await CartTable.findByIdAndDelete({ _id: findCart._id });
                res.json({
                    status: true,
                    data: null,
                    msg: "deleted the cart Details successfully",
                });
            } else {
                res.json({
                    status: false,
                    data: null,
                    msg: "Cart not found",
                });
            }
        }
    });
});

// get my batch details
AdminPanel.get("/getmybatchdetails", ValidateToken, async (req, res) => {
    jwt.verify(req.token, process.env.ADMIN_SECRET_KEY, async (err, Data) => {
        if (err) {
            res.status(401).json({
                err: err,
                status: false,
                data: null,
                msg: "not an admin",
            });
        } else {
            const user = await findUserByUserId(Data.studentId);
            if (user) {
                const findMyBatchDetails = await MybatchTable.find({
                    user: user._id,
                }).sort({ createdAt: -1 });
                if (findMyBatchDetails) {
                    const UserMyBatchDetails = [];
                    for (let i = 0; i < findMyBatchDetails.length; i++) {
                        // console.log(findMyBatchDetails[i])
                        const diffdays = getDateDifference(
                            findMyBatchDetails[i].created_at
                        );
                        let findBatch = await BatchesTable.findOne(
                            {
                                _id: findMyBatchDetails[i].batch_id,
                                // is_active: true,
                            },
                            {
                                created_at: 0,
                                student: 0,
                                charges: 0,
                                discount: 0,
                                __v: 0,
                            }
                        )
                            .populate({
                                path: 'teacher',
                                select: "FullName profilePhoto",
                                populate: {
                                    path: 'subject',
                                    select: 'title'
                                }
                            })
                            .populate("subject", { title: 1 });
                        if (!findBatch) {
                            continue;
                        }
                        if (diffdays > findBatch.validity) {
                            await MybatchTable.findByIdAndUpdate(
                                { _id: findMyBatchDetails[i]._id },
                                { is_active: false }
                            );
                            continue;
                        }
                        const LectureDetails = await LectureTable.find(
                            {
                                batch: findBatch._id,
                                isActive: true
                            },
                            {
                                student: 0,
                                batch: 0,
                                user_admin: 0,
                                __v: 0,
                                created_at: 0,
                            }
                        )
                            .populate("subject")
                            .populate({
                                path: 'teacher',
                                select: "FullName profilePhoto",
                                populate: {
                                    path: 'subject',
                                    select: 'title'
                                }
                            });//.populate('teacher',{FullName:1,profilePhoto:1});

                        let lectureDetailsWithRoom = [];
                        // const userRoom = await lectureRoomTable.findOne({ lecture : lectureId , students : { $in : user?._id}}).select('_id title');
                        let response = await Promise.all(LectureDetails?.map(async (item) => {
                            let userRoom = await lectureRoomTable.findOne({ lecture: item?._id, students: { $in: user?._id } }).populate("mentor", "_id FullName Role").select('_id title mentor');
                            // console.log(userRoom)
                            return {
                                ...item?._doc,
                                socketUrl: "https://twoway-backend-prod.sdcampus.com/mediasoup",
                                roomDetails: { id: userRoom?._id ?? "", roomName: userRoom?.title ?? "", mentor: userRoom?.mentor?.map((item2) => { return { mentorId: item2?._id ?? "", mentorName: item2?.FullName ?? "" } }) ?? [] }
                            }
                        }))
                        // for (let i = 0; i < LectureDetails.length; i++) {
                        //     let rooms = await lectureRoomTable.find({ lecture: LectureDetails[i]?._id }).select('students title _id');
                        //     let obj = { ...LectureDetails[i]?._doc, socketUrl : "socketUrl" , rooms: rooms?.map((item) => { return { roomId: item?._id ?? "", students: item?.students ?? [], title: item?.title } }) }
                        //     lectureDetailsWithRoom.push(obj);
                        // }

                        let helperObj = {
                            MyBatch_id: findMyBatchDetails[i]._id,
                            // created_at: findMyBatchDetails[i].created_at,
                            // Amount: findMyBatchDetails[i].amount,
                            // is_paid: findMyBatchDetails[i].is_paid,
                            is_active: findMyBatchDetails[i].is_active,
                            // lectureDetails: LectureDetails,
                            // lectureDetails: lectureDetailsWithRoom,
                            lectureDetails: response,
                            batchDetails: findBatch,
                        };
                        UserMyBatchDetails.push(helperObj);
                    }
                    res.json({
                        status: true,
                        data: UserMyBatchDetails,
                        msg: "fetched the MyBatch details",
                    });
                } else {
                    res.json({
                        status: false,
                        data: null,
                        msg: "No Data Found",
                    });
                }
            } else {
                res.json({
                    status: false,
                    data: null,
                    msg: "Not an user",
                });
            }
        }
    });
});

// get new batches details
AdminPanel.get('/myBatchDetails', ValidateToken, async (req, res) => {
    try {
        const decode = jwt.verify(req.token, process.env.SECRET_KEY);
        const user = await findUserByUserId(decode?.studentId);
        if (!user) {
            return res.json({
                status: false,
                data: null,
                msg: 'Not an user'
            })
        }
        const myBatches = await MybatchTable.find({ user: user?._id, is_active: true }).populate('batch_id').sort({ createdAt: -1 });
        return res.json({
            status: true,
            data: myBatches?.filter((item) => ![null, undefined].includes(item?.batch_id?._id))?.map((item) => {
                return {
                    myBatchId: item?._id ?? "",
                    batchId: item?.batch_id?._id ?? "",
                    banner: item?.batch_id?.banner ?? [],
                    batchName: item?.batch_id?.batch_name ?? "",
                    stream: item?.batch_id?.stream ?? "",
                    shareLink: "",
                    shareUrl: { link: item?.batch_id?.shareLink?.link ?? "", text: item?.batch_id?.shareLink?.text ?? "" },
                    startingDate: item?.batch_id?.starting_date ?? "",
                    endingdate: item?.batch_id?.ending_date ?? "",
                    language: item?.batch_id?.language ?? "",
                    isPaid: item?.batch_id?.isPaid,
                    validity: item?.batch_id?.validity,
                    daysLeft: moment(item?.expireDate).diff(moment(), 'days') ?? 0,
                    expireDate: moment(item?.expireDate).format('DD-MM-YYYY') ?? "",
                }
            }),
            msg: 'My batches detail fetched'
        })
    } catch (error) {
        return res.json({
            status: false,
            data: null,
            msg: error.message
        })
    }
})

AdminPanel.get('/myBatchInfo', ValidateToken, async (req, res) => {
    const { batchId } = req.query;
    try {
        const decode = jwt.verify(req.token, process.env.SECRET_KEY);
        const user = await findUserByUserId(decode?.studentId);
        if (!user) {
            return res.json({
                status: false,
                data: null,
                msg: 'Not an user'
            })
        }
        const myBatch = await MybatchTable.findOne({ user: user?._id, batch_id: batchId }).populate('batch_id');
        if (!myBatch) {
            return res.json({
                status: false,
                data: null,
                msg: 'Not authorized to access'
            })
        }
        // let today = moment().startOf('day'); 
        // let expireDate = moment(myBatch?.expireDate).startOf('day');
        // if (expireDate.isBefore(today)) {
        //     return res.json({
        //         status: false,
        //         data: null,
        //         msg: 'Batch expired.'
        //     })
        // }
        const isBatch = await BatchesTable.findOne({ _id: batchId }).populate('features', '_id feature icon isActive order').populate("subject", "_id title icon");
        if (!isBatch) {
            return res.json({
                status: false,
                data: null,
                msg: 'Batch not found'
            })
        }
        let today = moment().startOf('day');
        let expireDate = moment(myBatch?.expireDate).startOf('day');
        if (expireDate.isBefore(today)) {
            return res.json({
                status: false,
                data: null,
                msg: 'Batch expired.'
            })
        }
        const lectures = await LectureTable.find({ batch: myBatch?.batch_id?._id, isActive: true })
            .populate({
                path: 'teacher',
                select: "FullName profilePhoto demoVideo category qualification",
                populate: {
                    path: 'subject',
                    // select: 'title'
                }
            }).populate('batch', '_id batch_name slug').populate('subject')
        let currentDate = moment(new Date()).format('DD-MM-YYYY');
        let todayLecture = lectures.filter((item) => {
            let startDate = moment(item?.starting_date, 'DD-MM-YYYY HH:mm:ss').format('DD-MM-YYYY');
            return moment(startDate, 'DD-MM-YYYY').isSame(moment(currentDate, 'DD-MM-YYYY'));
        });
        let upcomingLecture = lectures.filter((item) => {
            let startDate = moment(item?.starting_date, 'DD-MM-YYYY HH:mm:ss').format('DD-MM-YYYY');
            return moment(startDate, 'DD-MM-YYYY').isAfter(moment(currentDate, 'DD-MM-YYYY'));
        });
        todayLecture = await Promise.all(todayLecture?.map(async (item) => {
            let userRoom = await lectureRoomTable.findOne({ lecture: item?._id, students: { $in: user?._id } }).populate("mentor", "_id FullName Role").select('_id title mentor');
            // console.log(userRoom)
            return {
                ...item?._doc,
                batch: item?._doc?.batch?._id ?? "",
                // isPaid : item?.
                batchDetails: { id: item?._doc?.batch?._id, batchName: item?._doc?.batch?.batch_name, slug: item?._doc?.batch?.slug } ?? { id: "", batchName: "", slug: "" },
                commonName: item?._doc?.commonName ?? "",
                teacher: item?.teacher[0] ?? {},
                banner: item?.banner != "" ? item?.banner : "https://static.sdcampus.com/assets/lecture_default_1732539568.jpg",
                banner: item?.banner != "" ? item?.banner : "https://static.sdcampus.com/assets/lecture_default_1732539568.jpg",
                socketUrl: item?.socketUrl ?? "https://twoway-backend-prod.sdcampus.com/mediasoup",
                roomDetails: {
                    id: userRoom?._id ?? "", roomName: userRoom?.title ?? "", mentor: userRoom?.mentor?.map((item2) => { return { mentorId: item2?._id ?? "", mentorName: item2?.FullName ?? "" } }) ?? [],
                    batchName: myBatch?.batch_id?.batch_name ?? ""
                } ?? {},
            }
        }))
        upcomingLecture = await Promise.all(upcomingLecture?.map(async (item) => {
            let userRoom = await lectureRoomTable.findOne({ lecture: item?._id, students: { $in: user?._id } }).populate("mentor", "_id FullName Role").select('_id title mentor');
            // console.log(userRoom)
            return {
                ...item?._doc,
                batch: item?._doc?.batch?._id ?? "",
                batchDetails: { id: item?._doc?.batch?._id, batchName: item?._doc?.batch?.batch_name, slug: item?._doc?.batch?.slug } ?? { id: "", batchName: "", slug: "" },
                commonName: item?._doc?.commonName ?? "",
                teacher: item?.teacher[0] ?? {},
                banner: item?.banner != "" ? item?.banner : "https://static.sdcampus.com/assets/lecture_default_1732539568.jpg",
                socketUrl: item?.socketUrl ?? "https://twoway-backend-prod.sdcampus.com/mediasoup",
                roomDetails: {
                    id: userRoom?._id ?? "", roomName: userRoom?.title ?? "", mentor: userRoom?.mentor?.map((item2) => { return { mentorId: item2?._id ?? "", mentorName: item2?.FullName ?? "" } }) ?? [],
                    batchName: myBatch?.batch_id?.batch_name ?? ""
                } ?? {}
            }
        }))
        return res.json({
            status: true,
            data: {
                myBatchId: myBatch?._id ?? "",
                batchId: myBatch?.batch_id?._id ?? "",
                description: myBatch?.batch_id?.description ?? "",
                shareUrl: { link: myBatch?.batch_id?.shareLink?.link ?? "", text: myBatch?.batch_id?.shareLink?.text ?? "" },
                planner: myBatch?.batch_id?.planner ?? { fileName: "", fileLoc: "", fileSize: "" },
                banner: myBatch?.batch_id?.banner ?? [],
                batchName: myBatch?.batch_id?.batch_name ?? "",
                stream: myBatch?.batch_id?.stream ?? "",
                shareLink: "",
                todayLecture,
                upcomingLecture,
                batchFeatures: isBatch?.features?.filter((item) => item.isActive != false).sort((a, b) => a.order - b.order).map((item) => {
                    return {
                        featureId: item?._id ?? "",
                        icon: item?.icon ?? "",
                        feature: item?.feature ?? "",
                    }
                })

            },
            msg: 'My Batch info fetched'

        })
    } catch (error) {
        return res.json({
            status: false,
            data: null,
            msg: error.message
        })
    }
})

//Deleting the MyBatch Details
AdminPanel.delete("/deleteMyBatchByAdmin/:id", isAdmin, async (req, res) => {
    const { MyBatch_id } = req.params;
    const decoded = jwt.verify(req.token, process.env.ADMIN_SECRET_KEY);
    const adminDetails = await findAdminTeacherUsingUserId(decoded.studentId);
    if (!adminDetails) {
        return res.status(401).json({
            status: false,
            data: null,
            msg: "Not an admin",
        });
    }
    const findBatch = await MybatchTable.findOne({ _id: MyBatch_id });
    if (findBatch) {
        await MybatchTable.findByIdAndDelete({ _id: MyBatch_id });
        await savePanelEventLogs(
            adminDetails?._id,
            "deleteTeacherFromLecture",
            "delete",
            findBatch
        )
        res.status(401).json({
            status: true,
            data: null,
            msg: "the MyBatch Details Deleted successfully",
        });
    } else {
        res.json({
            status: false,
            data: null,
            msg: "MyBatch Not Found",
        });
    }
});

//Add the Course to the MyBatches List
AdminPanel.post("/addtomybatch", ValidateToken, async (req, res) => {
    const { batch_id, is_paid } = req.body;
    jwt.verify(req.token, process.env.ADMIN_SECRET_KEY, async (err, Data) => {
        if (err) {
            res.json({
                err: err,
                status: false,
                data: null,
                msg: "not an user",
            });
        } else {
            const user = await findUserByUserId(Data.studentId);
            if (user) {
                const batchDetails = await BatchesTable.findOne({
                    _id: batch_id,
                });
                if (batchDetails) {
                    const findMyBatch = await MybatchTable.findOne({
                        batch_id: batchDetails._id,
                        user: user._id,
                    });
                    if (findMyBatch) {
                        res.json({
                            status: false,
                            data: null,
                            msg: "The the course data exists ",
                        });
                    } else {
                        const date = new Date(moment().add(5, "hours").add(30, "minutes"));
                        let formatedDate = formatDate(date);
                        const newMyBatch = new MybatchTable({
                            user: user._id,
                            batch_id: batchDetails._id,
                            amount: batchDetails.charges,
                            is_active: true,
                            is_paid: is_paid,
                            created_at: formatedDate,
                        });
                        newMyBatch.save();
                        const findCart = await CartTable.findOne({
                            user: user._id,
                            batch: batchDetails._id,
                        });
                        await CartTable.findByIdAndDelete({
                            _id: findCart._id,
                        });
                        res.json({
                            status: true,
                            data: newMyBatch,
                            msg: "the course added successfully to the MyBatch details",
                        });
                    }
                } else {
                    res.json({
                        status: false,
                        data: null,
                        msg: "batch details not found ",
                    });
                }
            } else {
                res.json({
                    status: false,
                    data: null,
                    msg: "Not An user",
                });
            }
        }
    });
});

//add the Subject to the Subject Table
AdminPanel.post("/addSubject", upload.single('file'), isAdmin, async (req, res) => {
    const { title } = req.body;
    jwt.verify(req.token, process.env.ADMIN_SECRET_KEY, async (err, Data) => {
        if (err) {
            res.status(401).json({
                err: err,
                status: false,
                data: null,
                msg: "not an user",
            });
        } else {
            const adminDetails = await findAdminTeacherUsingUserId(Data.studentId);
            if (
                adminDetails.Role == "admin" ||
                adminDetails.Role == "subadmin" ||

                adminDetails.accessToContent.includes("Subject")
            ) {
                const findSubject = await SubjectTable.findOne({
                    title: title,
                });
                if (!findSubject) {
                    let fileLoc = [];
                    if (req.file) {
                        let size = req.file.size / (1024);
                        if (size > 100) {
                            return res.json({
                                status: false,
                                data: null,
                                msg: 'Maximum subject icon size 100KB allowed'
                            })
                        }
                        const helperString = Math.floor(Date.now() / 1000);
                        const filename = (req.file.originalname.split(".")[0]).replace(/\s+/g, '_').replace(/[^a-zA-Z0-9_]/g, '');
                        const extension = "." + req.file.originalname.split(".").pop();
                        FileUploadLocation = `subject/${title?.replace(/\s+/g, '_').replace(/[^a-zA-Z0-9_]/g, '')}/${filename}_${helperString}${extension}`;
                        let helperfileLoc = await uploadFile(req.file.path, FileUploadLocation);
                        fileLoc.push(helperfileLoc);
                    }
                    // console.log(fileLoc[0]);
                    const SubjectDetails = new SubjectTable({
                        title: title,
                        icon: fileLoc[0],
                        is_active: true,
                        user: adminDetails._id,
                    });
                    SubjectDetails.save();
                    res.json({
                        status: true,
                        data: SubjectDetails,
                        msg: "The Subject Details added successfully",
                    });
                } else {
                    res.json({
                        status: false,
                        data: null,
                        msg: "the Subject already exists",
                    });
                }
            } else {
                res.json({
                    status: false,
                    data: null,
                    msg: "not an admin",
                });
            }
        }
    });
});

//get all the Subject Details from the Subject table
AdminPanel.get("/getSubjectDetails", isAdmin, async (req, res) => {
    const SubjectDetails = await SubjectTable.find({is_active: true}).populate("user", "FullName Role").sort({ createdAt: -1 });
    if (SubjectDetails.length > 0) {
        res.json({
            status: true,
            data: SubjectDetails.map((item, index) => {
                return {
                    ...item?._doc, id: item?._id, sNo: index + 1, admin: { FullName: item?.user?.FullName ?? "", Role: item?.user?.Role ?? "" }
                    , createdAt: moment(item?.createdAt).format('DD-MM-YYYY HH:mm:ss')
                }
            }),
            msg: "fetched all the Subject details",
        });
    } else {
        res.json({
            status: false,
            data: null,
            msg: "No data found ",
        });
    }
});
AdminPanel.get("/getSubjectDetailsOfBatch/:batchId", isAdmin, async (req, res) => {
    const { batchId } = req.params;
    if (!batchId) {
        return res.json({
            status: false,
            data: null,
            msg: 'Required BatchId'
        })
    }
    const SubjectDetails = await BatchesTable.findOne({ _id: batchId }).populate("subject", '_id title');
    if (SubjectDetails) {
        res.json({
            status: true,
            data: SubjectDetails?.subject.map((item) => {
                return {
                    _id: item._id,
                    title: item?.title,
                }
            }),
            msg: "fetched all the Subject details",
        });
    } else {
        res.json({
            status: false,
            data: null,
            msg: "No data found ",
        });
    }
});
//delete the Subject details from the Subject table
AdminPanel.delete("/deleteSubject/:id", isAdmin, async (req, res) => {
    const { id } = req.params;

    jwt.verify(req.token, process.env.ADMIN_SECRET_KEY, async (err, Data) => {
        if (err) {
            res.status(401).json({
                err: err,
                status: false,
                data: null,
                msg: "not an user",
            });
        } else {
            const adminDetails = await findAdminTeacherUsingUserId(Data.studentId);
            if (adminDetails) {
                const findSubject = await SubjectTable.findOne({ _id: id });
                if (findSubject) {
                    await SubjectTable.findByIdAndDelete({ _id: findSubject._id });
                    await savePanelEventLogs(
                        adminDetails?._id,
                        "deleteSubject",
                        "delete",
                        findSubject
                    )
                    res.json({
                        status: true,
                        data: findSubject,
                        msg: "Subject delected successfully",
                    });
                } else {
                    res.json({
                        status: false,
                        data: null,
                        msg: "Subject doesn't exist",
                    });
                }
            } else {
                res.json({
                    status: false,
                    data: null,
                    msg: "Not an Admin",
                });
            }
        }
    });

});

//Update the Subject details
AdminPanel.put("/updateSubject/:id", upload.single('file'), isAdmin, async (req, res) => {
    const { title, is_active } = req.body;
    const { id } = req.params;

    jwt.verify(req.token, process.env.ADMIN_SECRET_KEY, async (err, Data) => {
        if (err) {
            res.status(401).json({
                err: err,
                status: false,
                data: null,
                msg: "not an user",
            });
        } else {
            const adminDetails = await findAdminTeacherUsingUserId(Data.studentId);
            const findSubject = await SubjectTable.findOne({ _id: id });
            if (findSubject) {
                let icon = "";
                if (req.file) {
                    let size = req.file.size / (1024);
                    if (size > 100) {
                        return res.json({
                            status: false,
                            data: null,
                            msg: 'Maximum subject icon size 100KB allowed'
                        })
                    }
                    const helperString = Math.floor(Date.now() / 1000);
                    const filename = (req.file.originalname.split(".")[0]).replace(/\s+/g, '_').replace(/[^a-zA-Z0-9_]/g, '');
                    const extension = "." + req.file.originalname.split(".").pop();
                    FileUploadLocation = `subject/${title?.replace(/\s+/g, '_').replace(/[^a-zA-Z0-9_]/g, '')}/${filename}_${helperString}${extension}`;
                    let helperfileLoc = await uploadFile(req.file.path, FileUploadLocation);
                    // fileLoc.push(helperfileLoc);
                    icon = helperfileLoc;
                }
                else {
                    icon = findSubject?.icon
                }
                await SubjectTable.findByIdAndUpdate(
                    { _id: findSubject._id },
                    {
                        title: title,
                        is_active: is_active,
                        icon,
                        user: adminDetails._id,
                    },
                    {
                        runValidators: true,
                    }
                );
                const adminDetailsafter = await SubjectTable.findOne({
                    _id: id,
                });
                res.json({
                    status: true,
                    data: null,
                    msg: "the Subject Updated successfully",
                });
            } else {
                res.json({
                    status: false,
                    data: null,
                    msg: "the Subject Not found",
                });
            }
        }
    });
});

// make Subject  active& inActive
AdminPanel.put("/makeActiveAndInActiveSubject/:id", isAdmin, async (req, res) => {
    const { id } = req.params;
    if (!id) {
        return res.json({
            status: false,
            data: null,
            msg: 'Required Id'
        })
    }
    try {
        const decode = jwt.verify(req.token, process.env.ADMIN_SECRET_KEY);
        const admin = await findAdminTeacherUsingUserId(decode?.studentId);
        if (!admin) {
            return res.json({
                status: false,
                data: null,
                msg: "Not an Admin"
            })
        }
        const isSubject = await SubjectTable.findOne({ _id: id });
        if (!isSubject) {
            return res.json({
                status: false,
                data: null,
                msg: `Subject not found`
            })
        }
        let is_active = isSubject?.is_active == 'true' ? 'false' : 'true';
        const newSubject = await SubjectTable.findByIdAndUpdate(isSubject?._id, { is_active: is_active }, { new: true, lean: true });
        return res.json({
            status: true,
            data: null,
            msg: `${newSubject?.title} status changed into ${newSubject?.is_active == 'true' ? "Active" : "InActive"}`
        })

    } catch (error) {
        return res.json({
            status: false,
            data: null,
            msg: error.message
        })
    }
})

AdminPanel.put("/makeActiveAndInActiveLectureResource/:id", isAdmin, async (req, res) => {
    const { id } = req.params;
    if (!id) {
        return res.json({
            status: false,
            data: null,
            msg: 'Required Id'
        })
    }
    try {
        const decode = jwt.verify(req.token, process.env.ADMIN_SECRET_KEY);
        const admin = await findAdminTeacherUsingUserId(decode?.studentId);
        if (!admin) {
            return res.json({
                status: false,
                data: null,
                msg: "Not an Admin"
            })
        }
        const isResource = await LectureResourceTable.findOne({ _id: id });
        if (!isResource) {
            return res.json({
                status: false,
                data: null,
                msg: `Resource not found`
            })
        }
        let is_active = isResource?.is_active == true ? false : true;
        const newResource = await LectureResourceTable.findByIdAndUpdate(isResource?._id, { is_active: is_active }, { new: true, lean: true });
        return res.json({
            status: true,
            data: null,
            msg: `${newResource?.title} status changed into ${newResource?.is_active == 'true' ? "Active" : "InActive"}`
        })

    } catch (error) {
        return res.json({
            status: false,
            data: null,
            msg: error.message
        })
    }
})

// get subject By id 
AdminPanel.get("/getSubjectById/:id", isAdmin, async (req, res) => {
    const { id } = req.params;
    if (!id) {
        return res.json({
            status: false,
            data: null,
            msg: "Required Id"
        })
    }
    try {
        const decode = jwt.verify(req.token, process.env.ADMIN_SECRET_KEY);
        const admin = await findAdminTeacherUsingUserId(decode?.studentId);
        if (!admin) {
            return res.json({
                status: false,
                data: null,
                msg: 'Not an admin'
            })
        }
        const subject = await SubjectTable.findOne({ _id: id });
        return res.json({
            status: true,
            data: subject,
            msg: 'Subject found'
        })

    } catch (error) {
        return res.json({
            status: false,
            data: null,
            msg: error.message
        })
    }
})

//Add the data to the Schedular Table
AdminPanel.post("/addSchedulardetails", ValidateToken, async (req, res) => {
    const { task, notify_at } = req.body;
    jwt.verify(req.token, process.env.ADMIN_SECRET_KEY, async (err, Data) => {
        if (err) {
            res.status(401).json({
                err: err,
                status: false,
                data: null,
                msg: "not an user",
            });
        } else {
            const user = await findUserByUserId(Data.studentId);
            if (user) {
                const date = new Date(moment().add(5, "hours").add(30, "minutes"));
                let formatedDate = formatDate(date);
                const Scheduledetails = new SchedularTable({
                    task: task,
                    created_at: formatedDate,
                    is_active: false,
                    notify_at: notify_at,
                    user: user._id,
                });
                Scheduledetails.save();
                res.json({
                    status: true,
                    data: Scheduledetails,
                    msg: "user Schedule details Added successfully",
                });
            } else {
                res.json({
                    status: false,
                    data: null,
                    msg: "User Not found",
                });
            }
        }
    });
});

//get the Schedule details of the user
AdminPanel.get(
    "/getScheduleDetails",
    ValidateToken,
    // isSameDevice,
    async (req, res) => {
        // AdminPanel.get("/getScheduleDetails", ValidateToken, async (req, res) => {
        jwt.verify(req.token, process.env.ADMIN_SECRET_KEY, async (err, Data) => {
            if (err) {
                res.status(401).json({
                    err: err,
                    status: false,
                    data: null,
                    msg: "not an user",
                });
            } else {
                const user = await findUserByUserId(Data.studentId);
                if (user) {
                    const userScheduleDetails = await SchedularTable.find({
                        user: user._id,
                    });
                    if (userScheduleDetails) {
                        res.json({
                            status: true,
                            data: userScheduleDetails,
                            msg: "user Schedule details fetched successfully",
                        });
                    } else {
                        res.json({
                            status: false,
                            data: null,
                            msg: "No data found",
                        });
                    }
                } else {
                    res.json({
                        status: false,
                        data: null,
                        msg: "Not an user",
                    });
                }
            }
        });
    }
);

AdminPanel.delete(
    "/deleteSchedularDetails/:id",
    ValidateToken,
    async (req, res) => {
        const { id } = req.params;
        jwt.verify(req.token, process.env.ADMIN_SECRET_KEY, async (err, Data) => {
            if (err) {
                res.status(401).json({
                    err: err,
                    status: false,
                    data: null,
                    msg: "not an user",
                });
            } else {
                const user = await findUserByUserId(Data.studentId);
                if (user) {
                    const userScheduleDetails = await SchedularTable.find({
                        _id: id,
                    });
                    if (userScheduleDetails) {
                        await SchedularTable.findByIdAndDelete({
                            _id: id,
                        });
                        res.json({
                            status: false,
                            data: null,
                            msg: "deleted the Schedule successfully",
                        });
                    } else {
                        res.json({
                            status: false,
                            data: null,
                            msg: "Schedule details not found",
                        });
                    }
                } else {
                    res.json({
                        status: false,
                        data: null,
                        msg: "Not an user",
                    });
                }
            }
        });
    }
);

//Add the data to the Schedular Table
AdminPanel.put(
    "/updateSchedulardetails/:id",
    ValidateToken,
    async (req, res) => {
        const { id } = req.params;
        const { task, notify_at, is_active } = req.body;
        jwt.verify(req.token, process.env.ADMIN_SECRET_KEY, async (err, Data) => {
            if (err) {
                res.status(401).json({
                    err: err,
                    status: false,
                    data: null,
                    msg: "not an user",
                });
            } else {
                const user = await findUserByUserId(Data.studentId);
                if (user) {
                    const Scheduledetails = await SchedularTable.findOne({ _id: id });
                    if (Scheduledetails) {
                        await SchedularTable.findByIdAndUpdate(
                            { _id: id },
                            {
                                task: task,
                                is_active: is_active,
                                notify_at: notify_at,
                            }
                        );
                        res.json({
                            status: true,
                            data: null,
                            msg: "updated the user Schedule",
                        });
                    } else {
                        res.json({
                            status: false,
                            data: null,
                            msg: "Schedule details not found",
                        });
                    }
                } else {
                    res.json({
                        status: false,
                        data: null,
                        msg: "User Not found",
                    });
                }
            }
        });
    }
);

//adding the LectureResource
AdminPanel.post(
    "/postLectureResource",
    upload.single("file"),
    ValidateToken,
    async (req, res) => {
        const {
            batch_id,
            lecture_id,
            title,
            is_active,
            resurce_type,
            language,
            link,
        } = req.body;
        jwt.verify(req.token, process.env.ADMIN_SECRET_KEY, async (err, Data) => {
            if (err) {
                res.status(401).json({
                    err: err,
                    status: false,
                    data: null,
                    msg: "not an user",
                });
            } else {
                const findTeacher = await findAdminTeacherUsingUserId(Data.studentId);
                if (findTeacher) {
                    let is_verified;
                    if (findTeacher.Role == "admin") {
                        is_verified = true;
                    } else {
                        is_verified = false;
                    }
                    const findBatch = await BatchesTable.findOne({
                        _id: batch_id,
                    });
                    let fileLoc;
                    if (resurce_type == "pdf" || resurce_type == "video" || resurce_type == "DPP") {
                        if (req.file) {
                            const helperString = Math.floor(Date.now() / 1000);
                            const filename = (req.file.originalname.split(".")[0]).replace(/\s+/g, '_').replace(/[^a-zA-Z0-9_]/g, '');
                            const extension = "." + req.file.originalname.split(".").pop();
                            FileUploadLocation = `lectureResource/${title?.replace(/\s+/g, '_').replace(/[^a-zA-Z0-9_]/g, '')}/${filename}_${helperString}${extension}`;
                            let fileLocHelper = await uploadFile(
                                req.file.path,
                                FileUploadLocation
                            );
                            fileLoc = fileDetails(req.file, fileLocHelper);
                        }
                    } else {
                        fileLoc = {
                            fileLoc: link,
                            fileName: "",
                            fileSize: "",
                        };
                    }
                    if (findBatch) {
                        const LectureDetails = await LectureTable.findOne({
                            _id: lecture_id,
                        });
                        if (LectureDetails) {
                            const date = new Date(
                                moment().add(5, "hours").add(30, "minutes")
                            );
                            let formatedDate = formatDate(date);
                            const Lectureresource = new LectureResourceTable({
                                user: findTeacher._id,
                                batch: findBatch._id,
                                lecture: LectureDetails._id,
                                title: title,
                                created_at: formatedDate,
                                language: language,
                                is_active: is_active,
                                resourceType: resurce_type,
                                is_Verified: is_verified,
                                upload_file: fileLoc,
                            });
                            const saveLectureRes = await Lectureresource.save();
                            if (is_active) {
                                let data;
                                if (resurce_type == "pdf") {
                                    data = {
                                        title: `${LectureDetails?.lecture_title} NOTES.!!`,
                                        message: `Dear ${findBatch?.batch_name} Students, ${LectureDetails?.lecture_title} Notes uploaded.`,
                                        fileUrl: LectureDetails?.banner ?? "",
                                        route: "mybatchNotesById",
                                        rootId: `${findBatch?._id}`,
                                        childId: ""
                                    };
                                } else if (resurce_type == "DPP") {
                                    data = {
                                        title: `${LectureDetails?.lecture_title} DPP.!!`,
                                        message: `Dear ${findBatch?.batch_name} Students, ${LectureDetails?.lecture_title} DPP uploaded.`,
                                        fileUrl: LectureDetails?.banner ?? "",
                                        route: "dppByBatchId",
                                        rootId: `${findBatch?._id}`,
                                        childId: ""
                                    };
                                }
                                else if (resurce_type == "video") {
                                    data = {
                                        title: `${LectureDetails?.lecture_title} Video.!!`,
                                        message: `Dear ${findBatch?.batch_name} Students, ${LectureDetails?.lecture_title} Video uploaded.`,
                                        fileUrl: LectureDetails?.banner ?? "",
                                        route: "mybatchVideoByid",
                                        rootId: `${findBatch?._id}`,
                                        childId: ""
                                    };
                                }
                                await sendCustomNotification(findBatch?.student, data);
                            }

                            res.json({
                                status: true,
                                data: [
                                    {
                                        lectureResourceDetails: Lectureresource,
                                        FileUploadedLocation: fileLoc,
                                    },
                                ],
                            });
                        } else {
                            res.json({
                                status: false,
                                data: null,
                                mag: "lecture details not Found",
                            });
                        }
                    } else {
                        res.json({
                            status: false,
                            data: null,
                            msg: "batch not found",
                        });
                    }
                } else {
                    res.json({
                        status: false,
                        data: null,
                        msg: "Not an Teacher or admin",
                    });
                }
            }
        });
    }
);

AdminPanel.post(
    "/postCenterLectureResource",
    upload.single("file"),
    ValidateToken,
    async (req, res) => {
        const {
            batch_id,
            lectures,
            title,
            is_active,
            resurce_type,
            language,
            link,
        } = req.body;
        jwt.verify(req.token, process.env.ADMIN_SECRET_KEY, async (err, Data) => {
            if (err) {
                res.status(401).json({
                    err: err,
                    status: false,
                    data: null,
                    msg: "not an user",
                });
            } else {
                let lecturesId = lectures.filter((item) => { return item != "" });
                const findTeacher = await findAdminTeacherUsingUserId(Data.studentId);
                if (findTeacher) {
                    let is_verified;
                    if (findTeacher.Role == "admin") {
                        is_verified = true;
                    } else {
                        is_verified = false;
                    }
                    const findBatch = await BatchesTable.findOne({
                        _id: batch_id,
                    });
                    const date = new Date(
                        moment().add(5, "hours").add(30, "minutes")
                    );
                    let fileLoc;
                    if (resurce_type == "pdf" || resurce_type == "video" || resurce_type == "DPP") {
                        if (req.file) {
                            const helperString = Math.floor(Date.now() / 1000);
                            const filename = (req.file.originalname.split(".")[0]).replace(/\s+/g, '_').replace(/[^a-zA-Z0-9_]/g, '');
                            const extension = "." + req.file.originalname.split(".").pop();
                            FileUploadLocation = `lectureResource/${title?.replace(/\s+/g, '_').replace(/[^a-zA-Z0-9_]/g, '')}/${filename}_${helperString}${extension}`;
                            let fileLocHelper = await uploadFile(
                                req.file.path,
                                FileUploadLocation
                            );
                            fileLoc = fileDetails(req.file, fileLocHelper);
                        }
                    } else {
                        fileLoc = {
                            fileLoc: link,
                            fileName: "",
                            fileSize: "",
                        };
                    }
                    if (findBatch) {
                        for (let lectureId of lecturesId) {
                            const LectureDetails = await LectureTable.findOne({
                                _id: lectureId,
                            });
                            if (LectureDetails) {
                                let formatedDate = formatDate(date);
                                const Lectureresource = new LectureResourceTable({
                                    user: findTeacher._id,
                                    batch: findBatch._id,
                                    lecture: LectureDetails._id,
                                    title: title,
                                    created_at: formatedDate,
                                    language: language,
                                    is_active: is_active,
                                    resourceType: resurce_type,
                                    is_Verified: is_verified,
                                    upload_file: fileLoc,
                                });
                                const saveResource = await Lectureresource.save();
                                if (saveResource?.is_active) {
                                    let data;
                                    if (resurce_type == "pdf") {
                                        data = {
                                            title: `${LectureDetails?.lecture_title} NOTES.!!`,
                                            message: `Dear ${findBatch?.batch_name} Students, ${LectureDetails?.lecture_title} Notes uploaded.`,
                                            fileUrl: LectureDetails?.banner ?? "",
                                            route: "mybatchNotesById",
                                            rootId: `${findBatch?._id}`,
                                            childId: ""
                                        };
                                    } else if (resurce_type == "DPP") {
                                        data = {
                                            title: `${LectureDetails?.lecture_title} DPP.!!`,
                                            message: `Dear ${findBatch?.batch_name} Students, ${LectureDetails?.lecture_title} DPP uploaded.`,
                                            fileUrl: LectureDetails?.banner ?? "",
                                            route: "dppByBatchId",
                                            rootId: `${findBatch?._id}`,
                                            childId: ""
                                        };
                                    }
                                    else if (resurce_type == "video") {
                                        data = {
                                            title: `${LectureDetails?.lecture_title} Video.!!`,
                                            message: `Dear ${findBatch?.batch_name} Students, ${LectureDetails?.lecture_title} Video uploaded.`,
                                            fileUrl: LectureDetails?.banner ?? "",
                                            route: "mybatchVideoByid",
                                            rootId: `${findBatch?._id}`,
                                            childId: ""
                                        };
                                    }
                                    await sendCustomNotification(findBatch?.student, data);
                                }


                            } else {
                                res.json({
                                    status: false,
                                    data: null,
                                    mag: "lecture details not Found",
                                });
                            }
                        }

                        return res.json({
                            status: true,
                            data: [],
                            msg: `Resources added in given lectures`
                        })
                        // console.log("After return")
                    } else {
                        res.json({
                            status: false,
                            data: null,
                            msg: "batch not found",
                        });
                    }
                } else {
                    res.json({
                        status: false,
                        data: null,
                        msg: "Not an Teacher or admin",
                    });
                }
            }
        });
    }
);

//Getting the Resource Details
AdminPanel.get(
    "/getLectureResourceDetails",
    ValidateToken,
    async (req, res) => {
        const { Lecture_id } = req.query;
        jwt.verify(req.token, process.env.ADMIN_SECRET_KEY, async (err, Data) => {
            if (err) {
                res.status(401).json({
                    err: err,
                    status: false,
                    data: null,
                    msg: "not an user",
                });
            } else {
                if (!Lecture_id) {
                    const AllLectureResourceDetails = await LectureResourceTable.find({})
                        .populate("batch")
                        .populate("lecture");
                    res.json({
                        status: false,
                        data: AllLectureResourceDetails,
                        msg: "fetched the Lecture Resource Details Testing",
                    });
                } else {
                    const FindLecture = await LectureTable.findOne(
                        { _id: Lecture_id },
                        { user: 0 }
                    );
                    if (FindLecture) {
                        const Lectureresource = await LectureResourceTable.find({
                            lecture: FindLecture._id,
                        });
                        // .populate("batch").populate("lecture");
                        if (Lectureresource) {
                            res.json({
                                status: true,
                                data: Lectureresource,
                                msg: "Fetched the lecture details ",
                            });
                        } else {
                            res.json({
                                status: false,
                                data: null,
                                msg: "No resource found",
                            });
                        }
                    } else {
                        res.json({
                            status: false,
                            data: null,
                            msg: "Lecture Details Not Found",
                        });
                    }
                }
            }
        });
    }
);

AdminPanel.get(
    "/getLectureResource",
    isAdmin,
    async (req, res) => {
        const { Lecture_id } = req.query;
        jwt.verify(req.token, process.env.ADMIN_SECRET_KEY, async (err, Data) => {
            if (err) {
                res.status(401).json({
                    err: err,
                    status: false,
                    data: null,
                    msg: "not an Admin",
                });
            } else {
                if (!Lecture_id) {
                    const AllLectureResourceDetails = await LectureResourceTable.find({})
                        .populate("batch")
                        .populate("lecture");
                    res.json({
                        status: false,
                        data: AllLectureResourceDetails,
                        msg: "fetched the Lecture Resource Details Testing",
                    });
                } else {
                    const FindLecture = await LectureTable.findOne(
                        { _id: Lecture_id },
                        { user: 0 }
                    );
                    if (FindLecture) {
                        const Lectureresource = await LectureResourceTable.find({
                            lecture: FindLecture._id,
                        });
                        // .populate("batch").populate("lecture");
                        if (Lectureresource) {
                            res.json({
                                status: true,
                                data: Lectureresource.map((item) => { return { ...item._doc, id: item._id } }),
                                msg: "Fetched the lecture details ",
                            });
                        } else {
                            res.json({
                                status: false,
                                data: null,
                                msg: "No resource found",
                            });
                        }
                    } else {
                        res.json({
                            status: false,
                            data: null,
                            msg: "Lecture Details Not Found",
                        });
                    }
                }
            }
        });
    }
);

AdminPanel.get("/getDppByBatchId/:id", ValidateToken, async (req, res) => {
    const { id } = req.params;
    const { subjectId } = req.query;
    if (!id) {
        return res.json({
            status: false,
            data: null,
            msg: `Required batch Id`
        })
    }
    try {
        const decoded = jwt.verify(req.token, process.env.SECRET_KEY);
        const user = await findUserByUserId(decoded.studentId);
        if (!user) {
            return res.json({
                status: false,
                data: null,
                msg: "Not an user"
            })
        }

        const isMyBatch = await MybatchTable.findOne({ user: user._id, batch_id: id });
        if (!isMyBatch) {
            return res.json({
                status: false,
                data: null,
                msg: "not authorized to access"
            })
        }

        const lectures = await LectureTable.find({ batch: id, subject: subjectId });
        let allDpp = [];
        for (let lec of lectures) {
            let notes = await LectureResourceTable.find({ lecture: lec._id, resourceType: { $eq: "DPP" }, is_active: true }).populate("lecture", "_id lecture_title");

            // allDpp = allDpp.concat(notes);
            // notes.map((item) => {
            //   allDpp.push(item);
            // })
            for (let item of notes) {
                // allDpp.push(dpp)
                let obj = {
                    id: item._id ?? "",
                    lecture_title: item.lecture.lecture_title ?? "",
                    file: item.upload_file ?? {
                        fileLoc: "",
                        fileName: "",
                        fileSize: "",
                    }
                }
                allDpp.push(obj);
            }

        }
        // let allDpp = await LectureResourceTable.find({ batch: id, resourceType: { $eq: "DPP" }, is_active: true }).populate("lecture", "_id lecture_title");

        return res.json({
            status: true,
            // data: allDpp.map((item) => {
            //   return {
            //     id: item._id ?? "",
            //     lecture_title: item.lecture.lecture_title ?? "",
            //     file: item.upload_file ?? {
            //       fileLoc: "",
            //       fileName: "",
            //       fileSize: "",
            //     },
            //   }
            // }) ?? [],
            data: allDpp,
            msg: `All Dpp fetch for batch Id`
        })
    } catch (error) {
        return res.json({
            status: false,
            data: null,
            msg: error.message
        })
    }
})

AdminPanel.get("/getAllDppByBatchId/:id", isAdmin, async (req, res) => {
    const { id } = req.params;
    if (!id) {
        return res.json({
            status: false,
            data: null,
            msg: `Required batch Id`
        })
    }
    try {
        const decoded = jwt.verify(req.token, process.env.ADMIN_SECRET_KEY);
        const adminDetails = await findAdminTeacherUsingUserId(decoded.studentId);
        if (!adminDetails) {
            return res.json({
                status: false,
                data: null,
                msg: 'not an admin'
            })
        }
        const allDpp = await LectureResourceTable.find({ resourceType: 'DPP', batch: id }).populate("lecture", "_id lecture_title");
        return res.json({
            status: true,
            data: allDpp.map((item) => {
                return {
                    id: item._id ?? "",
                    title: item.title ?? "",
                    language: item.language ?? "",
                    lecture_title: item.lecture.lecture_title ?? "",
                    file: item.upload_file ?? {
                        fileLoc: "",
                        fileName: "",
                        fileSize: "",
                    },
                    is_active: item?.is_active
                }
            }) ?? [],
            msg: `All Dpp fetch for batch Id`
        })
    } catch (error) {
        return res.json({
            status: false,
            data: null,
            msg: error.message
        })
    }
})

AdminPanel.get("/getAllNotesByBatchId/:id", isAdmin, async (req, res) => {
    const { id } = req.params;
    if (!id) {
        return res.json({
            status: false,
            data: null,
            msg: `Required batch Id`
        })
    }
    try {
        const decoded = jwt.verify(req.token, process.env.ADMIN_SECRET_KEY);
        const adminDetails = await findAdminTeacherUsingUserId(decoded.studentId);
        if (!adminDetails) {
            return res.json({
                status: false,
                data: null,
                msg: 'not an admin'
            })
        }
        const allDpp = await LectureResourceTable.find({ resourceType: 'pdf', batch: id }).populate("lecture", "_id lecture_title");
        return res.json({
            status: true,
            data: allDpp.map((item) => {
                return {
                    id: item._id ?? "",
                    title: item.title ?? "",
                    language: item.language ?? "",
                    lecture_title: item.lecture.lecture_title ?? "",
                    file: item.upload_file ?? {
                        fileLoc: "",
                        fileName: "",
                        fileSize: "",
                    },
                    is_active: item?.is_active ?? false
                }
            }) ?? [],
            msg: `All Dpp fetch for batch Id`
        })
    } catch (error) {
        return res.json({
            status: false,
            data: null,
            msg: error.message
        })
    }
})
AdminPanel.put(
    "/verifyLectureresourceByAdmin/:id",
    isAdmin,
    async (req, res) => {
        const { id } = req.params;
        const lectureResourceDetails = await LectureResourceTable.findOne({
            _id: id,
        });
        if (lectureResourceDetails) {
            await LectureResourceTable.findByIdAndUpdate(
                { _id: lectureResourceDetails._id },
                { is_Verified: true }
            );
            res.json({
                status: true,
                data: null,
                msg: "Lecture resource Verified",
            });
        } else {
            res.json({
                status: false,
                data: null,
                msg: "Lecture resource Not Found",
            });
        }
    }
);

//Updating the Lecture Resource Details
AdminPanel.get("/getLectureResourceById/:id", isAdmin, async (req, res) => {
    const { id } = req.params;
    if (!id) {
        return res.json({
            status: false,
            data: null,
            msg: "required Id"
        })
    }
    try {
        const lectResource = await LectureResourceTable.findOne({ _id: id });
        return res.json({
            status: true,
            data: lectResource,
            msg: 'Resource details fetched'
        })

    } catch (error) {
        return res.json({
            status: false,
            data: null,
            msg: error.message
        })
    }
})

AdminPanel.put(
    "/updateTheLectureResourceDetails/:id",
    ValidateToken,
    upload.single("file"),
    async (req, res) => {
        const {
            batch_id,
            lecture_id,
            title,
            is_active,
            resurce_type,
            language,
            link,
        } = req.body;
        const { id } = req.params;
        jwt.verify(req.token, process.env.ADMIN_SECRET_KEY, async (err, Data) => {
            if (err) {
                res.status(401).json({
                    err: err,
                    status: false,
                    data: null,
                    msg: "not an user",
                });
            } else {
                const LectureResourceDetailsFind = await LectureResourceTable.findOne({
                    _id: id,
                });
                if (LectureResourceDetailsFind) {
                    const findTeacher = await findAdminTeacherUsingUserId(Data.studentId);
                    if (findTeacher) {
                        let findBatch;
                        if (batch_id) {
                            findBatch = await BatchesTable.findOne({
                                _id: batch_id,
                            });
                        } else {
                            findBatch = await BatchesTable.findOne({
                                _id: LectureResourceDetailsFind.batch,
                            });
                        }
                        let fileLoc;
                        if (resurce_type) {
                            if (resurce_type == "file") {
                                if (req.file) {
                                    const helperString = Math.floor(Date.now() / 1000);
                                    const filename = (req.file.originalname.split(".")[0]).replace(/\s+/g, '_').replace(/[^a-zA-Z0-9_]/g, '');
                                    const extension =
                                        "." + req.file.originalname.split(".").pop();
                                    FileUploadLocation = `lectureResource/${title?.replace(/\s+/g, '_').replace(/[^a-zA-Z0-9_]/g, '')}/${filename}_${helperString}${extension}`;
                                    let fileLocHelper = await uploadFile(
                                        req.file.path,
                                        FileUploadLocation
                                    );
                                    fileLoc = fileDetails(req.file, fileLocHelper);
                                }
                            } else {
                                if (link != undefined) {
                                    fileLoc = {
                                        fileLoc: link,
                                    };
                                } else {
                                    fileLoc = {
                                        fileLoc: LectureResourceDetailsFind.upload_file,
                                    };
                                }

                            }
                        } else {
                            fileLoc = LectureResourceDetailsFind.upload_file;
                        }
                        if (findBatch) {
                            let LectureDetails;
                            if (lecture_id) {
                                LectureDetails = await LectureTable.findOne({
                                    _id: lecture_id,
                                });
                            } else {
                                LectureDetails = await LectureTable.findOne({
                                    _id: LectureResourceDetailsFind.lecture,
                                });
                            }
                            if (LectureDetails) {
                                const date = new Date(
                                    moment().add(5, "hours").add(30, "minutes")
                                );
                                await LectureResourceTable.findByIdAndUpdate(
                                    {
                                        _id: LectureResourceDetailsFind._id,
                                    },
                                    {
                                        user: findTeacher._id,
                                        batch: findBatch._id,
                                        lecture: LectureDetails._id,
                                        title: title,
                                        language: language,
                                        is_active: is_active,
                                        resourceType: resurce_type,
                                        upload_file: fileLoc,
                                    }
                                );
                                const findAfter = await LectureResourceTable.findOne({
                                    _id: LectureResourceDetailsFind._id,
                                });
                                res.json({
                                    status: true,
                                    data: [
                                        {
                                            lectureResourceDetails: findAfter,
                                            FileUploadedLocation: fileLoc,
                                        },
                                    ],
                                });
                            } else {
                                res.json({
                                    status: false,
                                    data: null,
                                    mag: "lecture details not Found",
                                });
                            }
                        } else {
                            res.json({
                                status: false,
                                data: null,
                                msg: "batch not found",
                            });
                        }
                    } else {
                        res.json({
                            status: false,
                            data: null,
                            msg: "Not an Teacher or admin",
                        });
                    }
                } else {
                    res.json({
                        status: false,
                        data: null,
                        msg: "Lecture Resource not found",
                    });
                }
            }
        });
    }
);

//Deleting the Lecture Resource Details
AdminPanel.delete(
    "/deleteLectureresourceDetails/:id",
    ValidateToken,
    async (req, res) => {
        const { id } = req.params;
        jwt.verify(req.token, process.env.ADMIN_SECRET_KEY, async (err, Data) => {
            if (err) {
                res.status(401).json({
                    err: err,
                    status: false,
                    data: null,
                    msg: "not an user",
                });
            } else {
                const findTeacher = await findAdminTeacherUsingUserId(Data.studentId);
                if (findTeacher) {
                    const FindLectureresource = await LectureResourceTable.findOne({
                        _id: id,
                    });
                    if (FindLectureresource) {
                        await LectureResourceTable.findByIdAndDelete({ _id: id });
                        await savePanelEventLogs(
                            findTeacher?._id,
                            "deleteLectureResourses",
                            "delete",
                            FindLectureresource
                        )
                        res.json({
                            status: true,
                            data: null,
                            mag: "Lecture Details deleted Successfully",
                        });
                    } else {
                        res.json({
                            status: null,
                            data: null,
                            msg: "Lecture Resource Not found",
                        });
                    }
                } else {
                    res.json({
                        status: false,
                        data: null,
                        msg: "Not an Admin or teacher",
                    });
                }
            }
        });
    }
);

//Adding the Files
AdminPanel.post("/addFiles", upload.single("file"), async (req, res) => {
    const { filePath } = req.body;
    FileUploadLocation = filePath;
    fileLoc = await uploadFile(req.file.path, FileUploadLocation);
    res.send({
        status: true,
        data: fileLoc,
        msg: "uploaded the file",
    });
});

// add bulk
AdminPanel.post("/logoutTheUserFromOtherDevices", isAdmin, async (req, res) => {
    try {
        const decoded = jwt.verify(req.token, process.env.ADMIN_SECRET_KEY);
        const adminDetails = await findAdminTeacherUsingUserId(decoded.studentId);
        if (!adminDetails) {
            return res.status(401).json({
                status: false,
                data: null,
                msg: "Not an admin",
            });
        }
        const { userIdArr } = req.body;
        if (userIdArr.length === 0) {
            // Corrected condition
            res.json({
                status: false,
                data: null,
                msg: "UserId Array Can't Be Empty",
            });
            return; // Added return to exit the function early
        }

        const userRemovePromises = userIdArr.map((userId) =>
            userRequestModel.deleteMany({ user: userId })
        );

        const userUpdatePromises = userIdArr.map((userId) =>
            UserTable.findByIdAndUpdate(userId, { deviceConfig: "", deviceName: "" })
        );

        await Promise.all([...userRemovePromises, ...userUpdatePromises]);
        await savePanelEventLogs(
            adminDetails?._id,
            "logoutUsersFromOtherDevices",
            "delete",
            { ...userIdArr }
        )

        res.json({
            status: true,
            data: null,
            msg: "Users Logged Out successfully",
        });
    } catch (error) {
        console.error("Error during user logout:", error);
        res.status(500).json({
            status: false,
            data: null,
            msg: "An error occurred during user logout",
        });
    }
});

AdminPanel.delete("/deletCourseFromMyBatch/:id", isAdmin, async (req, res) => {
    const { id } = req.params;
    const decoded = jwt.verify(req.token, process.env.ADMIN_SECRET_KEY);
    const adminDetails = await findAdminTeacherUsingUserId(decoded.studentId);
    if (!adminDetails) {
        return res.status(401).json({
            status: false,
            data: null,
            msg: "Not an admin",
        });
    }
    const findBatch = await MybatchTable.findOne({ _id: id });
    if (findBatch) {
        await MybatchTable.findByIdAndDelete({ _id: id });
        await savePanelEventLogs(
            adminDetails?._id,
            "deleteCourseFromMyBatch",
            "delete",
            findBatch
        )
        res.json({
            status: true,
            data: null,
            msg: "Deleted the Course from MyCourses",
        });
    } else {
        res.json({
            status: false,
            data: null,
            msg: "The course is not found in mycourses",
        });
    }
});

AdminPanel.post("/postRequestToLogoutUserByAdmin", async (req, res) => {
    const { email_phoneNumber, message } = req.body;
    if (!message) {
        return res.json({
            status: false,
            data: null,
            msg: "Please add a message",
        });
    }
    let phonenumber = /^\d{10}$/; //check if user has given mobile number or email
    let userExists;
    if (email_phoneNumber.match(phonenumber)) {
        userExists = await findUserByMobileNumber(email_phoneNumber);
    } else {
        userExists = await findUserByEmail(email_phoneNumber);
    }
    if (userExists) {
        const existRequest = await userRequestModel.find({ user: userExists._id });
        if (existRequest.length === 0) {
            const NewadminRequest = new userRequestModel({
                user: userExists._id,
                message: message,
                createdAt: new Date(moment().add(5, "hours").add(30, "minutes")),
            });
            const logoutr = await NewadminRequest.save();
            if (logoutr) {
                return res.json({
                    status: true,
                    data: logoutr.message,
                    msg: "Request Sent",
                });
            }
        } else {
            return res.json({
                status: true,
                data: existRequest[0]?.message,
                msg: "Already requested",
            });
        }
    } else {
        res.json({
            status: false,
            data: null,
            msg: "Invalid Request",
        });
    }
});

AdminPanel.get("/getAllLogoutRequests", isAdmin, async (req, res) => {
    try {
        const userRequests = await userRequestModel
            .find({})
            .populate("user")
            .lean();
        if (userRequests.length > 0) {
            const formattedRequests = userRequests.map(
                ({ user, message, createdAt }) => ({
                    user: {
                        userId: user._id,
                        name: user.FullName,
                        email: user.email,
                        mobileNumber: user?.mobileNumber,
                    },
                    message,
                    requestAt: moment(createdAt).fromNow(),
                })
            );

            res.json({
                status: true,
                data: formattedRequests,
                msg: "Fetched all the requests",
            });
        } else {
            res.json({
                status: false,
                data: null,
                msg: "No requests found",
            });
        }
    } catch (error) {
        res.json({
            status: false,
            data: null,
            msg: "An error occurred",
        });
    }
});

AdminPanel.post(
    "/pushNotificationToStudent",
    ValidateToken,
    async (req, res) => {
        const { batch_id, notification } = req.body;
        jwt.verify(req.token, process.env.ADMIN_SECRET_KEY, async (err, Data) => {
            if (err) {
                res.status(401).json({
                    err: err,
                    status: false,
                    data: null,
                    msg: "not an user",
                });
            } else {
                const batchDetails = await BatchesTable.findOne({
                    _id: batch_id,
                });
                if (batchDetails) {
                    const allUsers = batchDetails.student;
                    for (let i = 0; i < allUsers.length; i++) {
                        const helperNotification = new NotificationModel({
                            user: Data.studentId,
                            to: allUsers[i],
                            notificationBody: notification,
                        });
                        helperNotification.save();
                    }
                    res.json({
                        status: true,
                        Data: null,
                        msg: "all notifications sent",
                    });
                } else {
                    res.json({
                        status: false,
                        data: null,
                        msg: "batch not found",
                    });
                }
            }
        });
    }
);

AdminPanel.get(
    "/getAllNotificationsStudent",
    ValidateToken,
    async (req, res) => {
        // const {studentId}=req.body;
        jwt.verify(req.token, process.env.ADMIN_SECRET_KEY, async (err, Data) => {
            if (err) {
                res.status(401).json({
                    err: err,
                    status: false,
                    data: null,
                    msg: "not an user",
                });
            } else {
                const UserDetails = await findUserByUserId(Data.studentId);
                if (UserDetails) {
                    const getUsersNotification = await NotificationModel.find({
                        to: UserDetails._id,
                    });
                    res.json({
                        status: true,
                        data: getUsersNotification,
                        msg: "fetched all the notifications of the user",
                    });
                } else {
                    res.json({
                        status: false,
                        data: null,
                        msg: "Not an user",
                    });
                }
            }
        });
    }
);

AdminPanel.post(
    "/pushNotificationToTeacher",
    ValidateToken,
    async (req, res) => {
        const { batch_id, notification } = req.body;
        jwt.verify(req.token, process.env.ADMIN_SECRET_KEY, async (err, Data) => {
            if (err) {
                res.status(401).json({
                    err: err,
                    status: false,
                    data: null,
                    msg: "not an user",
                });
            } else {
                const batchDetails = await BatchesTable.findOne({
                    _id: batch_id,
                });
                if (batchDetails) {
                    const allUsers = batchDetails.teacher;
                    for (let i = 0; i < allUsers.length; i++) {
                        const helperNotification = new NotificationModel({
                            user: Data.studentId,
                            to: allUsers[i],
                            title: "batch reminder",
                            Avatar:
                                "https://d1mbj426mo5twu.cloudfront.net/assets/Avtar.png",
                            type: "batch",
                            isUnRead: true,
                            notificationBody: notification,
                        });
                        helperNotification.save();
                    }
                    res.json({
                        status: true,
                        Data: null,
                        msg: "all notifications sent",
                    });
                } else {
                    res.json({
                        status: false,
                        data: null,
                        msg: "batch not found",
                    });
                }
            }
        });
    }
);

AdminPanel.get(
    "/getAllNotificationsTeacher",
    ValidateToken,
    async (req, res) => {
        jwt.verify(req.token, process.env.ADMIN_SECRET_KEY, async (err, Data) => {
            if (err) {
                res.status(401).json({
                    err: err,
                    status: false,
                    data: null,
                    msg: "not an user",
                });
            } else {
                const UserDetails = await findAdminTeacherUsingUserId(Data.studentId);
                if (UserDetails) {
                    const getUsersNotification = await NotificationModel.find({
                        to: UserDetails._id,
                    });
                    res.json({
                        status: true,
                        data: getUsersNotification,
                        msg: "fetched all the notifications of the user",
                    });
                } else {
                    res.json({
                        status: false,
                        data: null,
                        msg: "Not an user",
                    });
                }
            }
        });
    }
);

AdminPanel.put(
    "/updateTeacherNotificationToRead/:id",
    ValidateToken,
    async (req, res) => {
        jwt.verify(req.token, process.env.ADMIN_SECRET_KEY, async (err, Data) => {
            if (err) {
                res.status(401).json({
                    err: err,
                    status: false,
                    data: null,
                    msg: "not an user",
                });
            } else {
                const adminTeacher = await findAdminTeacherUsingUserId(Data.studentId);
                const { id } = req.params;
                if (adminTeacher) {
                    await NotificationModel.findByIdAndUpdate(
                        { _id: id },
                        { isUnRead: false }
                    );
                    res.json({
                        status: true,
                        data: null,
                        msg: "Updated the notification to read",
                    });
                } else {
                    res.json({
                        status: false,
                        data: null,
                        msg: "not and admin or teacher",
                    });
                }
            }
        });
    }
);

//get My Schedular Route
AdminPanel.get("/getMySchedular", ValidateToken, async (req, res) => {
    try {
        jwt.verify(req.token, process.env.ADMIN_SECRET_KEY, async (err, Data) => {
            if (err) {
                res.status(401).json({
                    err: err,
                    status: false,
                    data: null,
                    msg: "not an user",
                });
            } else {
                const userDetails = await findUserByUserId(Data.studentId);
                // const MyCourses = await MybatchTable.find({
                //     user: userDetails._id,
                // });
                // //  if(MyCourses){
                // const helperArray = [];
                // for (let i = 0; i < MyCourses.length; i++) {
                //     const LectureDetails = await LectureTable.find({
                //         batch: MyCourses[i].batch_id,
                //         LiveOrRecorded: "Live",
                //     });
                //     helperArray.push(...LectureDetails);
                // }

                // new logic 
                const myBatches = await MybatchTable.find({ user: userDetails._id }).select('_id batch_id');
                let batchIds = myBatches?.map((item) => { return item?.batch_id });
                const lectures = await LectureTable.find({ batch: { $in: batchIds }, LiveOrRecorded: 'Live', isActive: true })
                    .populate('batch', '_id batch_name slug').sort({ startingDate: -1 });
                let response = await Promise.all(lectures?.map(async (item) => {
                    let userRoom = { _id: "", mentor: [], title: "" };
                    if (item?.lecture_type == 'TWOWAY' && item?.LiveOrRecorded == "Live") {
                        userRoom = await lectureRoomTable.findOne({ lecture: item?._id, students: { $in: userDetails?._id } }).populate("mentor", "_id FullName Role").select('_id title mentor');
                    }

                    return {
                        ...item?._doc,
                        teacher: item?.teacher ?? [],
                        banner: item?.banner != "" ? item?.banner : "https://static.sdcampus.com/assets/lecture_default_1732539568.jpg",
                        batch: item?._doc?.batch?._id ?? "",
                        batchDetails: { id: item?._doc?.batch?._id, batchName: item?._doc?.batch?.batch_name, slug: item?._doc?.batch?.slug } ?? { id: "", batchName: "", slug: "" },
                        commonName: item?._doc?.commonName ?? "",
                        // socketUrl : item?.socketUrl ?? "https://twoway-backend-prod.sdcampus.com/mediasoup",
                        roomDetails: {
                            id: userRoom?._id ?? "", roomName: userRoom?.title ?? "",
                            mentor: userRoom?.mentor?.map((item2) => { return { mentorId: item2?._id ?? "", mentorName: item2?.FullName ?? "" } }) ?? [],
                            batchName: item?.batch_id?.batch_name ?? "",
                        } ?? {}
                    }
                }))

                res.json({
                    status: true,
                    data: response,
                    msg: "fetched all the schedules",
                });
                // }
                // else{
                //   res.json({
                //     status:false,
                //     data:null,
                //     msg:"no courses taken "
                //   })
                // }
            }
        });
    } catch (err) {
        return res.json({
            status: false,
            data: null,
            msg: err.message
        })
    }
});

AdminPanel.post(
    "/addRecordedVideo",
    ValidateToken,
    upload.single("file"),
    async (req, res) => {
        const { title, batch_id, language, lecture_id, is_active } = req.body;
        jwt.verify(req.token, process.env.ADMIN_SECRET_KEY, async (err, Data) => {
            if (err) {
                res.status(401).json({
                    err: err,
                    status: false,
                    data: null,
                    msg: "not an user",
                });
            } else {
                const Teacher = await findAdminTeacherUsingUserId(Data.studentId);
                if (Teacher) {
                    const batchDetails = await BatchesTable.findOne({
                        _id: batch_id,
                    });
                    if (batchDetails) {
                        const date = new Date(moment().add(5, "hours").add(30, "minutes"));
                        const lectureDetails = await LectureTable.findOne({
                            _id: lecture_id,
                        });
                        if (lectureDetails) {
                            let fileLoc;
                            if (req.file) {
                                const helperString = Math.floor(Date.now() / 1000);
                                const filename = (req.file.originalname.split(".")[0]).replace(/\s+/g, '_').replace(/[^a-zA-Z0-9_]/g, '');
                                const extension = "." + req.file.originalname.split(".").pop();
                                FileUploadLocation = `RecordedVideo/${title?.replace(/\s+/g, '_').replace(/[^a-zA-Z0-9_]/g, '')}/${filename}_${helperString}${extension}`;
                                let fileLocHelper = await uploadFile(
                                    req.file.path,
                                    FileUploadLocation
                                );
                                fileLoc = fileDetails(req.file, fileLocHelper);
                            }
                            const addNewRecordedVideo = new RecordedVideoModel({
                                user: Teacher._id,
                                title: title,
                                batch_id: batchDetails._id,
                                lecture_id: lectureDetails._id,
                                language: language,
                                is_active: is_active,
                                file_url: fileLoc,
                                created_at: formatDate(date),
                            });
                            await addNewRecordedVideo.save();
                            res.json({
                                status: true,
                                data: addNewRecordedVideo,
                                msg: "added the video successfully",
                            });
                        } else {
                            res.json({
                                status: false,
                                data: null,
                                msg: "Lecture details not found",
                            });
                        }
                    } else {
                        res.json({
                            status: false,
                            data: null,
                            msg: "Batch details not found",
                        });
                    }
                } else {
                    res.json({
                        status: false,
                        data: null,
                        msg: "Not an teacher",
                    });
                }
            }
        });
    }
);

//get the recorded video
AdminPanel.get("/getRecordedVideo", ValidateToken, async (req, res) => {
    const { batchId, language, lectureId } = req.query;
    jwt.verify(req.token, process.env.ADMIN_SECRET_KEY, async (err, Data) => {
        if (err) {
            res.status(401).json({
                err: err,
                status: false,
                data: null,
                msg: "not an user",
            });
        } else {
            const UserDetails = await findUserByUserId(Data.studentId);
            const TeacherDetails = await findAdminTeacherUsingUserId(Data.studentId);

            if (UserDetails || TeacherDetails) {
                let RecordedVideos;
                if (UserDetails) {
                    RecordedVideos = await RecordedVideoModel.find({
                        is_active: true,
                    })
                        .populate("batch_id")
                        .populate("lecture_id");
                } else {
                    RecordedVideos = await RecordedVideoModel.find({})
                        .populate("batch_id")
                        .populate("lecture_id");
                }
                let helperArray;
                if (batchId && language && lectureId) {
                    helperArray = RecordedVideos.filter((RecordedVideo) => {
                        return (
                            RecordedVideo.batch_id._id == batchId &&
                            RecordedVideo.language == language &&
                            RecordedVideo.lecture_id._id == lectureId
                        );
                    });
                    res.json({
                        status: true,
                        data: helperArray,
                        msg: "fetched all the videos",
                    });
                } else if (batchId && !language && !lectureId) {
                    helperArray = RecordedVideos.filter((RecordedVideo) => {
                        return RecordedVideo.batch_id._id == batchId;
                    });
                    res.json({
                        status: true,
                        data: helperArray,
                        msg: "fetched all the videos",
                    });
                } else if (!batchId && language && !lectureId) {
                    helperArray = RecordedVideos.filter((RecordedVideo) => {
                        return RecordedVideo.language == language;
                    });
                    res.json({
                        status: true,
                        data: helperArray,
                        msg: "fetched all the videos",
                    });
                } else if (!batchId && !language && lectureId) {
                    helperArray = RecordedVideos.filter((RecordedVideo) => {
                        return RecordedVideo.lecture_id._id == lectureId;
                    });
                    res.json({
                        status: true,
                        data: helperArray,
                        msg: "fetched all the videos",
                    });
                } else if (batchId && language && !lectureId) {
                    helperArray = RecordedVideos.filter((RecordedVideo) => {
                        return (
                            RecordedVideo.batch_id._id == batchId &&
                            RecordedVideo.language == language
                        );
                    });
                    res.json({
                        status: true,
                        data: helperArray,
                        msg: "fetched all the videos",
                    });
                } else if (batchId && !language && lectureId) {
                    helperArray = RecordedVideos.filter((RecordedVideo) => {
                        return (
                            RecordedVideo.batch_id._id == batchId &&
                            RecordedVideo.lecture_id._id == lectureId
                        );
                    });
                    res.json({
                        status: true,
                        data: helperArray,
                        msg: "fetched all the videos",
                    });
                } else if (!batchId && language && lectureId) {
                    helperArray = RecordedVideos.filter((RecordedVideo) => {
                        return (
                            RecordedVideo.language == language &&
                            RecordedVideo.lecture_id._id == lectureId
                        );
                    });
                    res.json({
                        status: true,
                        data: helperArray,
                        msg: "fetched all the videos",
                    });
                } else {
                    res.json({
                        status: RecordedVideos.map((item) => {
                            return { ...item._doc, id: item._id }

                        }),
                        status: RecordedVideos.map((item) => {
                            return { ...item._doc, id: item._id }

                        }),
                        msg: "fetched all the videos",
                    });
                }
            } else {
                res.json({
                    status: false,
                    data: null,
                    msg: "Not an user",
                });
            }
        }
    });
});

AdminPanel.delete("/deleteRecordedVideo/:id", isAdmin, async (req, res) => {
    const { id } = req.params;
    const decoded = jwt.verify(req.token, process.env.ADMIN_SECRET_KEY);
    const adminDetails = await findAdminTeacherUsingUserId(decoded.studentId);
    if (!adminDetails) {
        return res.status(401).json({
            status: false,
            data: null,
            msg: "Not an admin",
        });
    }
    const RecordedVideo = await RecordedVideoModel.findOne({ _id: id });
    if (RecordedVideo) {
        await savePanelEventLogs(
            adminDetails?._id,
            "deleteRecordedVideo",
            "delete",
            RecordedVideo
        )
        await RecordedVideoModel.findByIdAndDelete({ _id: id });
        res.json({
            status: true,
            data: null,
            msg: "Deleted the video successfully",
        });
    } else {
        res.json({
            status: false,
            data: null,
            msg: "The Recorded video details not found",
        });
    }
});

//verify the video by the admin
AdminPanel.put("/verifyUploadedVideoByAdmin/:id", isAdmin, async (req, res) => {
    const { id } = req.params;
    const RecordedVideo = await RecordedVideoModel.findOne({ _id: id });
    if (RecordedVideo) {
        await RecordedVideoModel.findByIdAndUpdate(
            { _id: RecordedVideo._id },
            { is_verfied: true }
        );
        res.json({
            status: true,
            data: null,
            msg: "uploaded video Verified",
        });
    } else {
        res.json({
            status: false,
            data: null,
            msg: "Lecture resource Not Found",
        });
    }
});

//get the recorded video
AdminPanel.get(
    "/getRecordedVideoStudentSide",
    ValidateToken,
    async (req, res) => {
        const { batchId } = req.query;
        jwt.verify(req.token, process.env.ADMIN_SECRET_KEY, async (err, Data) => {
            if (err) {
                res.status(401).json({
                    err: err,
                    status: false,
                    data: null,
                    msg: "not an user",
                });
            } else {
                const UserDetails = await findUserByUserId(Data.studentId);
                const TeacherDetails = await findAdminTeacherUsingUserId(
                    Data.studentId
                );
                if (UserDetails || TeacherDetails) {
                    const RecordedVideos = await RecordedVideoModel.find(
                        {
                            is_active: true,
                            is_verfied: true,
                            batch_id: batchId,
                        },
                        { __v: 0, user: 0 }
                    ).populate("lecture_id", {
                        lecture_title: 1,
                    });
                    const myMap = new Map();
                    //  for(let i=0;i<RecordedVideos.length;i++){
                    //   myMap.add(RecordedVideos[i].lecture_id.lecture_title);
                    //  }

                    for (let i = 0; i < RecordedVideos.length; i++) {
                        if (myMap.has(RecordedVideos[i].lecture_id?.lecture_title)) {
                            let helper = myMap.get(
                                RecordedVideos[i].lecture_id?.lecture_title
                            );
                            helper.push(RecordedVideos[i]);
                            myMap.set(RecordedVideos[i].lecture_id?.lecture_title, helper);
                        } else {
                            myMap.set(RecordedVideos[i].lecture_id?.lecture_title, [
                                RecordedVideos[i],
                            ]);
                        }
                    }
                    //  let helper=Object.fromEntries(myMap)
                    //  let arr=[];
                    //  let help=myMap.forEach((value, key) =>{
                    //   let helperObj={[key]:value}
                    //   // Object.assign(helperObj, )
                    //   arr.push(helperObj)
                    // })

                    const helper = Array.from(myMap, ([LectureName, Listofvideos]) => ({
                        LectureName,
                        Listofvideos,
                    }));
                    //  array = Array.from(myMap,);
                    //  console.log(myMap)

                    res.json({
                        status: true,
                        data: helper,
                        // recordedVideo:RecordedVideos,
                        msg: "Fetched the videos",
                    });
                } else {
                    res.json({
                        status: false,
                        data: null,
                        msg: "Not an user",
                    });
                }
            }
        });
    }
);

AdminPanel.put(
    "/UpdateRecordedVideo/:id",
    ValidateToken,
    upload.single("file"),
    async (req, res) => {
        const { id } = req.params;
        const { title, batch_id, language, lecture_id, is_active } = req.body;
        jwt.verify(req.token, process.env.ADMIN_SECRET_KEY, async (err, Data) => {
            if (err) {
                res.status(401).json({
                    err: err,
                    status: false,
                    data: null,
                    msg: "not an user",
                });
            } else {
                const Teacher = await findAdminTeacherUsingUserId(Data.studentId);
                if (Teacher) {
                    const findRecordedVideo = await RecordedVideoModel.findOne({
                        _id: id,
                    });
                    if (findRecordedVideo) {
                        let fileLoc;
                        if (req.file) {
                            const helperString = Math.floor(Date.now() / 1000);
                            const filename = (req.file.originalname.split(".")[0]).replace(/\s+/g, '_').replace(/[^a-zA-Z0-9_]/g, '');
                            const extension = "." + req.file.originalname.split(".").pop();
                            FileUploadLocation = `RecordedVideo/${title?.replace(/\s+/g, '_').replace(/[^a-zA-Z0-9_]/g, '')}/${filename}_${helperString}${extension}`;
                            let fileLocHelper = await uploadFile(
                                req.file.path,
                                FileUploadLocation
                            );
                            fileLoc = fileDetails(req.file, fileLocHelper);
                        } else {
                            fileLoc = findRecordedVideo.file_url;
                        }
                        await RecordedVideoModel.findByIdAndUpdate(
                            { _id: id },
                            {
                                user: Teacher._id,
                                title: title,
                                batch_id: batch_id,
                                lecture_id: lecture_id,
                                language: language,
                                is_active: is_active,
                                file_url: fileLoc,
                            }
                        );
                        res.json({
                            status: true,
                            data: null,
                            msg: "updated the video successfully",
                        });
                    } else {
                        res.json({
                            status: false,
                            data: null,
                            msg: "Video not found",
                        });
                    }
                } else {
                    res.json({
                        status: false,
                        data: null,
                        msg: "Not an teacher",
                    });
                }
            }
        });
    }
);

//get the recorded video
AdminPanel.get(
    "/getRecordedVideoStudentSide",
    ValidateToken,
    async (req, res) => {
        const { batchId, language, lectureId } = req.query;
        jwt.verify(req.token, process.env.ADMIN_SECRET_KEY, async (err, Data) => {
            if (err) {
                res.status(401).json({
                    err: err,
                    status: false,
                    data: null,
                    msg: "not an user",
                });
            } else {
                const UserDetails = await findUserByUserId(Data.studentId);
                const TeacherDetails = await findAdminTeacherUsingUserId(
                    Data.studentId
                );
                if (UserDetails || TeacherDetails) {
                    const RecordedVideos = await RecordedVideoModel.find({
                        is_active: true,
                        is_verfied: true,
                    })
                        .populate("batch_id")
                        .populate("lecture_id", {
                            teacher: 0,
                            student: 0,
                        });
                    const recordedLectures = await RecordedVideos[0].lecture_id._id;
                    let helperArray;
                    if (batchId && language && lectureId) {
                        helperArray = RecordedVideos.filter((RecordedVideo) => {
                            return (
                                RecordedVideo.batch_id._id == batchId &&
                                RecordedVideo.language == language &&
                                RecordedVideo.lecture_id._id == lectureId
                            );
                        });
                        res.json({
                            status: true,
                            data: helperArray,
                            msg: "fetched all the videos",
                        });
                    } else if (batchId && !language && !lectureId) {
                        // const helperLecture=[]
                        helperArray = RecordedVideos.filter((RecordedVideo) => {
                            return RecordedVideo.batch_id._id == batchId;
                        });
                        res.json({
                            status: true,
                            data: helperArray,
                            msg: "fetched all the videos",
                        });
                    } else if (!batchId && language && !lectureId) {
                        helperArray = RecordedVideos.filter((RecordedVideo) => {
                            return RecordedVideo.language == language;
                        });
                        res.json({
                            status: true,
                            data: helperArray,
                            msg: "fetched all the videos",
                        });
                    } else if (!batchId && !language && lectureId) {
                        helperArray = RecordedVideos.filter((RecordedVideo) => {
                            return RecordedVideo.lecture_id._id == lectureId;
                        });
                        res.json({
                            status: true,
                            data: helperArray,
                            msg: "fetched all the videos",
                        });
                    } else if (batchId && language && !lectureId) {
                        helperArray = RecordedVideos.filter((RecordedVideo) => {
                            return (
                                RecordedVideo.batch_id._id == batchId &&
                                RecordedVideo.language == language
                            );
                        });
                        res.json({
                            status: true,
                            data: helperArray,
                            msg: "fetched all the videos",
                        });
                    } else if (batchId && !language && lectureId) {
                        helperArray = RecordedVideos.filter((RecordedVideo) => {
                            return (
                                RecordedVideo.batch_id._id == batchId &&
                                RecordedVideo.lecture_id._id == lectureId
                            );
                        });
                        res.json({
                            status: true,
                            data: helperArray,
                            msg: "fetched all the videos",
                        });
                    } else if (!batchId && language && lectureId) {
                        helperArray = RecordedVideos.filter((RecordedVideo) => {
                            return (
                                RecordedVideo.language == language &&
                                RecordedVideo.lecture_id._id == lectureId
                            );
                        });
                        res.json({
                            status: true,
                            data: helperArray,
                            msg: "fetched all the videos",
                        });
                    } else {
                        res.json({
                            status: RecordedVideos,
                            msg: "fetched all the videos",
                        });
                    }
                } else {
                    res.json({
                        status: false,
                        data: null,
                        msg: "Not an user",
                    });
                }
            }
        });
    }
);

AdminPanel.get(
    "/getNotesOfBatchStudentSide",
    ValidateToken,
    async (req, res) => {
        jwt.verify(req.token, process.env.ADMIN_SECRET_KEY, async (err, Data) => {
            if (err) {
                res.status(401).json({
                    err: err,
                    status: false,
                    data: null,
                    msg: "not an user",
                });
            } else {
                const user = await findUserByUserId(Data.studentId);
                if (!user) {
                    return res.json({
                        err: err,
                        status: false,
                        data: null,
                        msg: "not an user",
                    });
                }
                const { batchId } = req.query;
                const batch = await MybatchTable.findOne({
                    batch_id: batchId,
                    user: user._id,
                });
                if (!batch) {
                    return res.json({
                        status: false,
                        data: null,
                        msg: "Purchase before access the batch resources",
                    });
                }
                const lectures = await LectureTable.find({ batch: batchId });
                const lectureResoursceDetails = await LectureResourceTable.find({
                    batch: batchId,
                }).populate("lecture");
                let resourceData = [];
                for (let i = 0; i < lectures.length; i++) {
                    const lectureResoursceDetails = await LectureResourceTable.find({
                        lecture: lectures[i]._id,
                        is_active: true,
                    });
                    resourceData.push({
                        lectureId: lectures[i]._id,
                        lecture_type: lectures[i].lecture_type,
                        lecture_title: lectures[i].lecture_title,
                        language: lectures[i].language,
                        resurces: lectureResoursceDetails.map((item) => {
                            return {
                                title: item.title,
                                language: item.language,
                                resourceType: item.resourceType,
                                upload_file: item.upload_file,
                                is_active: item.is_active,
                                created_at: item.created_at,
                            };
                        }),
                    });
                }
                if (lectureResoursceDetails) {
                    res.json({
                        status: true,
                        data: resourceData,
                        msg: "Resources",
                    });
                } else {
                    res.json({
                        status: false,
                        data: null,
                        msg: "No data found",
                    });
                }
            }
        });
    }
);

AdminPanel.post(
    "/addTestSeries",
    upload.single("file"),
    ValidateToken,
    async (req, res) => {
        let {
            testseries_name,
            exam_type,
            teacher,
            starting_date,
            ending_date,
            charges,
            discount,
            language,
            stream,
            remark,
            no_of_test,
            validity,
            link,
            is_active,
            description,
            isCoinApplicable,
            maxAllowedCoins
        } = req.body;
        if (discount && charges) {
            if (parseFloat(charges) < parseFloat(discount)) {
                return res.json({
                    status: false,
                    data: null,
                    msg: `Discount Price must lower or equal to regular price`
                })
            }
        } else {
            discount = charges
        }
        jwt.verify(req.token, process.env.ADMIN_SECRET_KEY, async (err, Data) => {
            if (err) {
                res.status(401).json({
                    status: false,
                    data: null,
                    msg: err,
                });
            } else {
                const AdminTeacherDetails = await findAdminTeacherUsingUserId(
                    Data.studentId
                );
                if (AdminTeacherDetails) {
                    const date = new Date(moment().add(5, "hours").add(30, "minutes"));
                    let fileLoc;
                    if (req.file) {
                        const helperString = Math.floor(Date.now() / 1000);
                        const filename = (req.file.originalname.split(".")[0]).replace(/\s+/g, '_').replace(/[^a-zA-Z0-9_]/g, '');
                        const extension = "." + req.file.originalname.split(".").pop();
                        FileUploadLocation = `TestSeries/${testseries_name?.replace(/\s+/g, '_').replace(/[^a-zA-Z0-9_]/g, '')}/${filename}_${helperString}${extension}`;
                        let helperfileLoc = await uploadFile(
                            req.file.path,
                            FileUploadLocation
                        );
                        fileLoc = fileDetails(req.file, helperfileLoc);
                    }
                    let slug = await generateSlug(testseries_name);
                    const TestSeriesDetails = await new TestSeriesTable({
                        user: AdminTeacherDetails._id,
                        testseries_name: testseries_name,
                        slug: slug,
                        exam_type: exam_type,
                        teacher: teacher,
                        starting_date: starting_date,
                        ending_date: ending_date,
                        charges: charges,
                        discount: discount,
                        banner: fileLoc,
                        description: description,
                        language: language,
                        stream: stream,
                        remark: remark,
                        link,
                        no_of_test: no_of_test,
                        validity: validity,
                        is_active: is_active,
                        isCoinApplicable,
                        maxAllowedCoins,
                        created_at: formatDate(date),
                    });
                    const savedTestseriues = await TestSeriesDetails.save();
                    if (is_active) {
                        const data = {
                            title: testseries_name,
                            message: `${testseries_name} just launched`,
                            fileUrl: savedTestseriues?.banner[0]?.fileLoc,
                            route: "testseriesbyid",
                            rootId: `${savedTestseriues?._id}`,
                            childId: ""
                        };
                        await sendCustomNotification('all', data);
                    }
                    res.json({
                        status: true,
                        data: TestSeriesDetails,
                        msg: "Added the TestSeries SuccessFully",
                    });
                } else {
                    res.json({
                        status: false,
                        data: null,
                        msg: "Not Authorized",
                    });
                }
            }
        });
    }
);

AdminPanel.get("/getTestSeriesdetails", ValidateToken, async (req, res) => {
    jwt.verify(req.token, process.env.ADMIN_SECRET_KEY, async (err, Data) => {
        if (err) {
            res.status(401).json({
                status: false,
                data: null,
                msg: err,
            });
        } else {
            let TestSeriesDetails;
            const userDetails = await findUserByUserId(Data.studentId);
            const TeacherDetails = await findAdminTeacherUsingUserId(Data.studentId);
            if (userDetails) {
                let checkArray = [];
                let MyTestSeriesDetails = await MyTestSeriesTable.find({
                    user: userDetails._id,
                });
                for (let i = 0; i < MyTestSeriesDetails.length; i++) {
                    checkArray.push(MyTestSeriesDetails[i].testseries_id);
                }
                TestSeriesDetails = await TestSeriesTable.find({
                    _id: { $nin: checkArray },
                    is_active: true,
                });
            } else {
                TestSeriesDetails = await TestSeriesTable.find({
                    is_active: true,
                });
            }
            if (TestSeriesDetails) {
                res.json({
                    status: true,
                    data: TestSeriesDetails,
                    msg: "Fetched all the testSeries details",
                });
            } else {
                res.json({
                    status: false,
                    data: null,
                    msg: "No Data found",
                });
            }
        }
    });
});

AdminPanel.get("/getallTestSeriesdetails", isAdmin, async (req, res) => {
    jwt.verify(req.token, process.env.ADMIN_SECRET_KEY, async (err, Data) => {
        if (err) {
            res.status(401).json({
                status: false,
                data: null,
                msg: err,
            });
        } else {
            let TestSeriesDetails;
            const userDetails = await findUserByUserId(Data.studentId);
            const TeacherDetails = await findAdminTeacherUsingUserId(Data.studentId);
            if (userDetails) {
                let checkArray = [];
                let MyTestSeriesDetails = await MyTestSeriesTable.find({
                    user: userDetails._id,
                });
                for (let i = 0; i < MyTestSeriesDetails.length; i++) {
                    checkArray.push(MyTestSeriesDetails[i].testseries_id);
                }
                TestSeriesDetails = await TestSeriesTable.find({
                    _id: { $nin: checkArray },
                });
            } else {
                TestSeriesDetails = await TestSeriesTable.find({});
            }
            if (TestSeriesDetails) {
                res.json({
                    status: true,
                    data: TestSeriesDetails.map((item) => { return { ...item._doc, id: item._id, value: item?._id, label: item?.testseries_name } }),
                    msg: "Fetched all the testSeries details",
                });
            } else {
                res.json({
                    status: false,
                    data: null,
                    msg: "No Data found",
                });
            }
        }
    });
});

AdminPanel.post("/testSeriesCoins/:id", isAdmin, uploadMulter.none(), async (req, res) => {
    const { id } = req.params
    const { isCoinApplicable, maxAllowedCoins } = req.body
    if (!isCoinApplicable && !maxAllowedCoins) {
        return res.json({
            status: false,
            data: null,
            msg: "Required! isCoinApplicable & maxAllowedCoins"
        })
    }
    jwt.verify(req.token, process.env.ADMIN_SECRET_KEY, async (err, Data) => {
        if (err) {
            res.status(401).json({
                status: false,
                data: null,
                msg: err,
            });
        } else {
            const admin = await findAdminTeacherUsingUserId(
                Data.studentId
            );
            if (!admin) {
                return res.json({
                    status: false,
                    data: null,
                    msg: "Invalid Access"
                })
            }
            const testSeris = await TestSeriesTable.findOne({ _id: id })
            if (!testSeris) {
                return res.json({
                    status: false,
                    data: null,
                    msg: "Test Sries Not Exists"
                })
            }
            await TestSeriesTable.findByIdAndUpdate({ _id: testSeris._id }, {
                isCoinApplicable,
                maxAllowedCoins: maxAllowedCoins ? maxAllowedCoins : "0"
            })
            return res.json({
                status: true,
                data: {
                    isCoinApplicable, maxAllowedCoins
                },
                msg: `${maxAllowedCoins} Coins allowed on ${testSeris.testseries_name} Test Series purchase`
            })

        }
    });
});

// this is for teacher
AdminPanel.get("/getTestSeriesdetails/:id", ValidateToken, async (req, res) => {
    jwt.verify(req.token, process.env.ADMIN_SECRET_KEY, async (err, Data) => {
        if (err) {
            res.status(401).json({
                status: false,
                data: null,
                msg: err,
            });
        } else {
            const { id } = req.params;
            const TestSeriesDetails = await TestSeriesTable.findOne({
                _id: id,
            }).populate("teacher", { FullName: 1, profilePhoto: 1 });
            if (TestSeriesDetails) {
                res.json({
                    status: true,
                    data: TestSeriesDetails,
                    msg: "Fetched the testSeries details",
                });
            } else {
                res.json({
                    status: false,
                    data: null,
                    msg: "No Data found",
                });
            }
        }
    });
});

AdminPanel.put(
    "/UpdateTestSeries/:id",
    upload.single("file"),
    ValidateToken,
    async (req, res) => {
        let {
            testseries_name,
            exam_type,
            teacher,
            starting_date,
            ending_date,
            charges,
            discount,
            language,
            stream,
            link,
            remark,
            no_of_test,
            validity,
            description,
            is_active,
        } = req.body;
        if (discount && charges) {
            if (parseFloat(charges) < parseFloat(discount)) {
                return res.json({
                    status: false,
                    data: null,
                    msg: `Discount Price must lower or equal to regular price`
                })
            }
        } else {
            discount = charges
        }
        let isPaid = true
        if (discount === 0) {
            isPaid = false
        }
        jwt.verify(req.token, process.env.ADMIN_SECRET_KEY, async (err, Data) => {
            if (err) {
                res.status(401).json({
                    status: false,
                    data: null,
                    msg: err,
                });
            } else {
                const { id } = req.params;
                const AdminTeacherDetails = await findAdminTeacherUsingUserId(
                    Data.studentId
                );
                if (AdminTeacherDetails) {
                    const testSeriesDetails = await TestSeriesTable.findOne({ _id: id });
                    const date = new Date(moment().add(5, "hours").add(30, "minutes"));
                    let fileLoc;

                    if (req.file) {
                        const helperString = Math.floor(Date.now() / 1000);
                        const filename = (req.file.originalname.split(".")[0]).replace(/\s+/g, '_').replace(/[^a-zA-Z0-9_]/g, '');
                        const extension = "." + req.file.originalname.split(".").pop();
                        FileUploadLocation = `TestSeries/${testseries_name?.replace(/\s+/g, '_').replace(/[^a-zA-Z0-9_]/g, '')}/${filename}_${helperString}${extension}`;
                        let helperfileLoc = await uploadFile(
                            req.file.path,
                            FileUploadLocation
                        );
                        fileLoc = fileDetails(req.file, helperfileLoc);
                    } else {
                        fileLoc = testSeriesDetails.banner;
                    }
                    let slug = await generateSlug(testseries_name);
                    await TestSeriesTable.findByIdAndUpdate(
                        { _id: id },
                        {
                            user: AdminTeacherDetails._id,
                            testseries_name: testseries_name,
                            slug,
                            exam_type: exam_type,
                            teacher: teacher,
                            starting_date: starting_date,
                            ending_date: ending_date,
                            charges: charges,
                            discount: discount,
                            banner: fileLoc,
                            language: language,
                            stream: stream,
                            description: description,
                            remark: remark,
                            link,
                            no_of_test: no_of_test,
                            validity: validity,
                            isPaid,
                            is_active: is_active,
                        }
                    );
                    res.json({
                        status: true,
                        data: null,
                        msg: "updated  the TestSeries SuccessFully",
                    });
                } else {
                    res.json({
                        status: false,
                        data: null,
                        msg: "Not Authorized",
                    });
                }
            }
        });
    }
);

AdminPanel.delete("/DeleteTestSeries/:id", ValidateToken, async (req, res) => {
    jwt.verify(req.token, process.env.ADMIN_SECRET_KEY, async (err, Data) => {
        if (err) {
            res.status(401).json({
                status: false,
                data: null,
                msg: err,
            });
        } else {
            const AdminTeacherDetails = await findAdminTeacherUsingUserId(
                Data.studentId
            );
            if (AdminTeacherDetails) {
                const { id } = req.params;
                const TestSeriesDetails = await TestSeriesTable.findOne({
                    _id: id,
                });
                if (TestSeriesDetails) {
                    await TestSeriesTable.findByIdAndDelete({ _id: id });
                    await savePanelEventLogs(
                        AdminTeacherDetails?._id,
                        "deleteTestSeries",
                        "delete",
                        TestSeriesDetails
                    )
                    res.json({
                        status: false,
                        data: null,
                        msg: "TestSeries deleted successfully",
                    });
                } else {
                    res.json({
                        status: false,
                        data: null,
                        msg: "TestSeries Details Not found",
                    });
                }
            } else {
                res.json({
                    status: false,
                    data: null,
                    msg: "Not Authorized",
                });
            }
        }
    });
});

AdminPanel.post(
    "/addTestForTestSeries",
    ValidateToken,
    upload.fields([
        {
            name: "questionPaper",
            maxCount: 1,
        },
        {
            name: "answerTemplate",
            maxCount: 1,
        },
    ]),
    async (req, res) => {
        const {
            TestSeriesId,
            Test_title,
            Test_code,
            instructions,
            starting_date,
            No_of_question,
            question_paper_type,
            duration,
            negativemarking,
            totalmarks,
            negativeMarks,
        } = req.body;
        jwt.verify(req.token, process.env.ADMIN_SECRET_KEY, async (err, Data) => {
            if (err) {
                res.status(401).json({
                    status: false,
                    data: null,
                    msg: err,
                });
            } else {
                const AdminTeacherDetails = await findAdminTeacherUsingUserId(
                    Data.studentId
                );
                if (AdminTeacherDetails) {
                    let DemoVideoLoc;
                    let fileLoc;
                    if (req.files) {
                        if (req.files.questionPaper) {
                            const helperString = Math.floor(Date.now() / 1000);
                            const filename =
                                (req.files.questionPaper[0].originalname.split(".")[0]).replace(/\s+/g, '_').replace(/[^a-zA-Z0-9_]/g, '');
                            const extension =
                                "." + req.files.questionPaper[0].originalname.split(".").pop();
                            FileUploadLocation = `TestForTestSeries/${TestSeriesId}/${Test_title}/${filename}_${helperString}${extension}`;
                            let fileLocHelper = await uploadFile(
                                req.files.questionPaper[0].path,
                                FileUploadLocation
                            );

                            fileLoc = {
                                fileLoc: fileLocHelper,
                                fileName: filename,
                                fileSize: `${(
                                    req.files.questionPaper[0].size / 1000000
                                ).toFixed(2)} MB`,
                            };
                        }
                        if (req.files.answerTemplate) {
                            // for (let j = 0; j < req.files.answerTemplate.length; j++) {
                            // console.log(req.files.demoVideo[j].originalname);
                            const helperString1 = Math.floor(Date.now() / 1000);
                            const filename1 =
                                (req.files.answerTemplate[0].originalname.split(".")[0]).replace(/\s+/g, '_').replace(/[^a-zA-Z0-9_]/g, '');
                            const extension1 =
                                "." + req.files.answerTemplate[0].originalname.split(".").pop();
                            DemoVideoUploadLocation = `TestSeries/${TestSeriesId}/${Test_title}/${filename1}_${helperString1}${extension1}`;
                            // console.log("Demo "+DemoVideoUploadLocation)
                            let fileLocHelper1 = await uploadFile(
                                req.files.answerTemplate[0].path,
                                DemoVideoUploadLocation
                            );
                            // console.log(fileLocHelper1)

                            let helperDemoVideoLoc = {
                                fileLoc: fileLocHelper1,
                                fileName: filename1,
                                fileSize: `${(
                                    req.files.answerTemplate[0].size / 1000000
                                ).toFixed(2)} MB`,
                            };
                            DemoVideoLoc = helperDemoVideoLoc;
                            // }
                        }
                    }
                    const testSeriesDetailsHelper = await TestSeriesTable.findOne({
                        _id: TestSeriesId,
                    });
                    let no_of_test = testSeriesDetailsHelper.no_of_test + 1;
                    await TestSeriesTable.findByIdAndUpdate(
                        { _id: TestSeriesId },
                        { no_of_test: no_of_test }
                    );
                    const date = new Date(moment().add(5, "hours").add(30, "minutes"));
                    const TestForTestSeriesDetails = await new TestSeriesTestTable({
                        user_admin: AdminTeacherDetails._id,
                        TestSeries: TestSeriesId,
                        Test_title: Test_title,
                        Test_code: Test_code,
                        instructions: instructions,
                        starting_date: starting_date,
                        created_at: formatDate(date),
                        No_of_questions: No_of_question,
                        question_paper: fileLoc,
                        answer_template: DemoVideoLoc,
                        negativemarking: negativemarking,
                        totalMarks: totalmarks,
                        question_paper_type: question_paper_type,
                        duration: duration,
                        negativeMarks: negativeMarks,
                    });
                    const savedTest = await TestForTestSeriesDetails.save();

                    const data = {
                        title: Test_title,
                        message: `${Test_title} Test added into ${testSeriesDetailsHelper?.testseries_name}`,
                        fileUrl: testSeriesDetailsHelper?.banner[0]?.fileLoc,
                        route: "mytestseriesTestid",
                        rootId: `${testSeriesDetailsHelper?._id}`,
                        childId: `${savedTest?._id}`
                    };
                    await sendCustomNotification(testSeriesDetailsHelper?.student, data);

                    res.json({
                        status: true,
                        data: TestForTestSeriesDetails,
                        msg: "Added the Test for TestSeries",
                    });
                } else {
                    res.json({
                        status: false,
                        data: null,
                        msg: "Not authorized",
                    });
                }
            }
        });
    }
);

AdminPanel.put(
    "/updateTheTestForTestSeries/:id",
    ValidateToken,
    upload.fields([
        {
            name: "questionPaper",
            maxCount: 1,
        },
        {
            name: "answerTemplate",
            maxCount: 1,
        },
    ]),
    async (req, res) => {
        const {
            TestSeriesId,
            Test_title,
            Test_code,
            instructions,
            starting_date,
            No_of_question,
            question_paper_type,
            duration,
            negativemarking,
            totalmarks,
        } = req.body;
        jwt.verify(req.token, process.env.ADMIN_SECRET_KEY, async (err, Data) => {
            if (err) {
                res.status(401).json({
                    status: false,
                    data: null,
                    msg: err,
                });
            } else {
                const AdminTeacherDetails = await findAdminTeacherUsingUserId(
                    Data.studentId
                );
                if (AdminTeacherDetails) {
                    const { id } = req.params;
                    const findTest = await TestSeriesTestTable.findOne({
                        _id: id,
                    });
                    if (findTest) {
                        let DemoVideoLoc;
                        let fileLoc;
                        if (req.files) {
                            if (req.files.questionPaper) {
                                const helperString = Math.floor(Date.now() / 1000);
                                const filename =
                                    (req.files.questionPaper[0].originalname.split(".")[0]).replace(/\s+/g, '_').replace(/[^a-zA-Z0-9_]/g, '');
                                const extension =
                                    "." +
                                    req.files.questionPaper[0].originalname.split(".").pop();
                                FileUploadLocation = `TestForTestSeries/${TestSeriesId}/${Test_title}/${filename}_${helperString}${extension}`;
                                let fileLocHelper = await uploadFile(
                                    req.files.questionPaper[0].path,
                                    FileUploadLocation
                                );

                                fileLoc = {
                                    fileLoc: fileLocHelper,
                                    fileName: filename,
                                    fileSize: `${(
                                        req.files.questionPaper[0].size / 1000000
                                    ).toFixed(2)} MB`,
                                };
                            } else {
                                fileLoc = findTest.question_paper;
                            }
                            if (req.files.answerTemplate) {
                                // for (let j = 0; j < req.files.answerTemplate.length; j++) {
                                // console.log(req.files.demoVideo[j].originalname);
                                const helperString1 = Math.floor(Date.now() / 1000);
                                const filename1 =
                                    (req.files.answerTemplate[0].originalname.split(".")[0]).replace(/\s+/g, '_').replace(/[^a-zA-Z0-9_]/g, '');
                                const extension1 =
                                    "." +
                                    req.files.answerTemplate[0].originalname.split(".").pop();
                                DemoVideoUploadLocation = `TestSeries/${TestSeriesId}/${Test_title}/${filename1}_${helperString1}${extension1}`;
                                // console.log("Demo "+DemoVideoUploadLocation)
                                let fileLocHelper1 = await uploadFile(
                                    req.files.answerTemplate[0].path,
                                    DemoVideoUploadLocation
                                );
                                // console.log(fileLocHelper1)

                                let helperDemoVideoLoc = {
                                    fileLoc: fileLocHelper1,
                                    fileName: filename1,
                                    fileSize: `${(
                                        req.files.answerTemplate[0].size / 1000000
                                    ).toFixed(2)} MB`,
                                };
                                DemoVideoLoc = helperDemoVideoLoc;
                                // }
                            } else {
                                DemoVideoLoc = findTest.answer_template;
                            }
                        }
                        const date = new Date(moment().add(5, "hours").add(30, "minutes"));
                        await TestSeriesTestTable.findByIdAndUpdate(
                            { _id: id },
                            {
                                user_admin: AdminTeacherDetails._id,
                                TestSeries: TestSeriesId,
                                Test_title: Test_title,
                                Test_code: Test_code,
                                instructions: instructions,
                                starting_date: starting_date,
                                No_of_questions: No_of_question,
                                question_paper: fileLoc,
                                updated_at: formatDate(date),
                                answer_template: DemoVideoLoc,
                                negativemarking: negativemarking,
                                totalMarks: totalmarks,
                                question_paper_type: question_paper_type,
                                duration: duration,
                            }
                        );
                        res.json({
                            status: true,
                            data: null,
                            msg: "updated  the Test for TestSeries",
                        });
                    } else {
                        res.json({
                            status: false,
                            data: null,
                            msg: "Test details not found",
                        });
                    }
                } else {
                    res.json({
                        status: false,
                        data: null,
                        msg: "Not authorized",
                    });
                }
            }
        });
    }
);

AdminPanel.delete(
    "/deleteTheTestFromTestSeries/:id",
    ValidateToken,
    async (req, res) => {
        try {
            const decodedToken = jwt.verify(req.token, process.env.ADMIN_SECRET_KEY);
            const adminTeacherDetails = await findAdminTeacherUsingUserId(
                decodedToken.studentId
            );

            if (!adminTeacherDetails) {
                return res.json({
                    status: false,
                    data: null,
                    msg: "Not authorized",
                });
            }

            const { id } = req.params;
            const findTest = await TestSeriesTestTable.findById(id);

            if (!findTest) {
                return res.json({
                    status: false,
                    data: null,
                    msg: "Test Details Not found",
                });
            }
            await savePanelEventLogs(
                adminTeacherDetails?._id,
                "deleteTestFromTestSeries",
                "delete",
                findTest
            )
            await TestSeriesTestTable.findByIdAndDelete(id);
            const testSeriesId = findTest.TestSeries;
            const countTests = await TestSeriesTestTable.countDocuments({
                TestSeries: testSeriesId,
            });

            await TestSeriesTable.findByIdAndUpdate(testSeriesId, {
                no_of_test: countTests,
            });

            res.json({
                status: true,
                data: null,
                msg: "Deleted the Test from testSeries",
            });
        } catch (err) {
            res.status(401).json({
                status: false,
                data: null,
                msg: err.message,
            });
        }
    }
);

AdminPanel.get(
    "/getTestForTestSeriesDetails",
    ValidateToken,
    async (req, res) => {
        const { TestSeries_id } = req.query;
        jwt.verify(req.token, process.env.ADMIN_SECRET_KEY, async (err, Data) => {
            if (err) {
                res.status(401).json({
                    status: false,
                    data: null,
                    msg: err,
                });
            } else {
                const userDetails = await findUserByUserId(Data.studentId);
                if (userDetails) {
                    if (TestSeries_id) {
                        const TestSeriesPerticular = await TestSeriesTestTable.find({
                            TestSeries: TestSeries_id,
                            No_of_questions: { $ne: 0 },
                        });
                        const mtTestId = mongoose.Types.ObjectId(TestSeries_id);
                        const MyAttemptedTest = await MyAttemptedTestTable.find({
                            user: userDetails._id,
                            testSeries_id: TestSeries_id,
                        }).populate("test_id");
                        let MapHelper = new Map();
                        for (let i = 0; i < MyAttemptedTest.length; i++) {
                            let help = MyAttemptedTest[i].test_id._id.toHexString();
                            const emptyObj = {
                                fileLoc: "",
                                fileName: "",
                                fileSize: "",
                            };
                            let obj = {
                                Score: MyAttemptedTest[i].Score,
                                answer_sheet: MyAttemptedTest[i].answer_sheet,
                                checked_answer_sheet: MyAttemptedTest[i].checked_answer_sheet
                                    ? MyAttemptedTest[i].checked_answer_sheet
                                    : emptyObj,
                                is_livetest: false,
                            };
                            MapHelper.set(help, obj);
                        }

                        let helperArray = [];
                        console.log("test" + TestSeriesPerticular);
                        for (let i = 0; i < TestSeriesPerticular.length; i++) {
                            if (MapHelper.has(TestSeriesPerticular[i]._id.toHexString())) {
                                let helperObj = TestSeriesPerticular[i].toObject();
                                helperObj.attempted = await MapHelper.get(
                                    TestSeriesPerticular[i]._id.toHexString()
                                );
                                helperObj.is_attempted = true;
                                helperArray.push(helperObj);
                                // console.log(helperObj);
                            } else {
                                let helperObj = TestSeriesPerticular[i].toObject();
                                helperObj.attempted = {
                                    answer_sheet: {
                                        fileLoc: "",
                                        fileName: "",
                                        fileSize: "",
                                    },
                                    checked_answer_sheet: {
                                        fileLoc: "",
                                        fileName: "",
                                        fileSize: "",
                                    },
                                    Score: "NA",
                                    is_livetest: false,
                                };
                                helperObj.is_attempted = false;
                                helperArray.push(helperObj);
                            }
                        }
                        if (TestSeriesPerticular) {
                            res.json({
                                Status: true,
                                data: helperArray,
                                msg: "Fetched all the Students Tests details ",
                            });
                        } else {
                            res.json({
                                status: false,
                                data: null,
                                msg: "No Data Found",
                            });
                        }
                    } else {
                        const TestSeriesDetails = await TestSeriesTestTable.find({
                            No_of_questions: { $ne: 0 },
                        });
                        if (TestSeriesDetails) {
                            res.json({
                                Status: true,
                                data: TestSeriesDetails,
                                msg: "Fetched all the Tests details ",
                            });
                        } else {
                            res.json({
                                status: false,
                                data: null,
                                msg: "No data found",
                            });
                        }
                    }
                } else {
                    const TestSeriesPerticular = await TestSeriesTestTable.find({
                        TestSeries: TestSeries_id,
                    });
                    if (TestSeriesPerticular) {
                        res.json({
                            status: true,
                            data: TestSeriesPerticular,
                            msg: "Fetched all the Details",
                        });
                    } else {
                        res.json({
                            status: false,
                            data: null,
                            msg: "NO data Found",
                        });
                    }
                }
            }
        });
    }
);

AdminPanel.get("/getMyTestByTestseriesId", ValidateToken, async (req, res) => {
    const { testSeriesId } = req.query;
    jwt.verify(req.token, process.env.ADMIN_SECRET_KEY, async (err, Data) => {
        if (err) {
            res.status(401).json({
                status: false,
                data: null,
                msg: err,
            });
        } else {
            const userDetails = await findUserByUserId(Data.studentId);
            if (!testSeriesId) {
                return res.json({
                    status: false,
                    data: null,
                    msg: "Provide TestSeries Id",
                });
            }
            if (userDetails) {
                const testSeries = await TestSeriesTable.findById(testSeriesId);
                if (!testSeries) {
                    return res.json({
                        status: false,
                        data: null,
                        msg: "Invalid TestSeries Id",
                    });
                }
                const myTestSeries = await MyTestSeriesTable.findOne({
                    testseries_id: testSeriesId,
                    user: userDetails._id,
                });
                if (!myTestSeries) {
                    return res.json({
                        status: false,
                        data: null,
                        msg: `You don't have access  ${testSeries.testseries_name} Test Series. Please purchase before access`,
                    });
                }
                let allTests = [];
                let ObjTypeTestId = [];
                let SubTypeTestId = [];
                let subAttempt = [];
                let objAttmpOnline = [];
                let objAttemptOffline = [];
                let finalRes = [];

                // all test Id's associated to testSeriesId
                const testSeriesTests = await TestSeriesTestTable.find({
                    TestSeries: testSeriesId,
                });
                if (testSeriesTests) {
                    testSeriesTests?.map((item) => {
                        allTests.push(item._id.toString());
                    });
                }
                // all objective test Id's associated to testSeriesId
                const objTypeTests = await TestSeriesTestTable.find({
                    TestSeries: testSeriesId,
                    question_paper_type: "objective",
                });
                if (objTypeTests) {
                    objTypeTests?.map((item) => {
                        ObjTypeTestId.push(item._id.toString());
                    });
                }

                // all objective Online attempted test Id's associated to objectiveTypeTestId
                if (ObjTypeTestId.length !== 0) {
                    const res = await QuizResponseTable.find({
                        quiz_id: { $in: ObjTypeTestId },
                        user_id: userDetails._id,
                    });
                    const itemIds = res.map((item) => item.quiz_id); // Use "item.item_id" instead of "item_id"
                    objAttmpOnline.push(...itemIds); // Use spread operator to push individual item ids into the array
                }

                // all objective Offline attempted test Id's associated to objectiveTypeTestId
                if (ObjTypeTestId.length !== 0) {
                    const res = await MyAttemptedTestTable.find({
                        test_id: { $in: ObjTypeTestId },
                        user: userDetails._id,
                    });
                    //  console.log(res)
                    const itemIds = res.map((item) => item.test_id); // Use "item.item_id" instead of "item_id"
                    objAttemptOffline.push(...itemIds); // Use spread operator to push individual item ids into the array
                }
                // all subjactive test Id's associated to testSeriesId
                const subTypeTests = await TestSeriesTestTable.find({
                    TestSeries: testSeriesId,
                    question_paper_type: "subjective",
                });
                if (subTypeTests) {
                    subTypeTests?.map((item) => {
                        SubTypeTestId.push(item._id.toString());
                    });
                }

                // all subjective Offline attempted test Id's associated to subjectiveTypeTestId
                if (subTypeTests.length !== 0) {
                    const res = await MyAttemptedTestTable.find({
                        test_id: { $in: SubTypeTestId },
                        user: userDetails._id,
                    });
                    //  console.log(res)
                    const itemIds = res.map((item) => item.test_id); // Use "item.item_id" instead of "item_id"
                    subAttempt.push(...itemIds); // Use spread operator to push individual item ids into the array
                }
                const newAtmpObjOnline = objAttmpOnline.map((id) => id.toString());
                const newobjAttemptOffline = objAttemptOffline.map((id) =>
                    id.toString()
                );
                const newsubAttempt = subAttempt.map((id) => id.toString());
                // console.log(SubTypeTestId, newsubAttempt)
                // console.log(allTests.filter(id => ObjTypeTestId.includes(id)))
                if (allTests.filter((id) => ObjTypeTestId.includes(id))) {
                    console.log("Objective Type Test");
                    if (
                        ObjTypeTestId.every((id) => newAtmpObjOnline.includes(id)) &&
                        ObjTypeTestId.every((id) => newobjAttemptOffline.includes(id))
                    ) {
                        console.log("Objective -> online & offline", ObjTypeTestId);
                        const submitRes = await MyAttemptedTestTable.findOne({
                            test_id: ObjTypeTestId,
                        });
                        // console.log("Su", submitRes)
                        const testRes = await TestSeriesTestTable.findById(ObjTypeTestId);
                        finalRes.push({
                            testSeriesId: testSeriesId,
                            testId: submitRes.test_id,
                            testTitle: testRes.Test_title,
                            testCode: testRes.Test_code,
                            instructions: testRes.instructions,
                            startDate: testRes.starting_date,
                            noOfQuestions: testRes.No_of_questions,
                            questionPaper: testRes.question_paper,
                            answerTemplate: testRes.answer_template,
                            totalMarkes: testRes.totalMarks,
                            questionsPaperType: testRes.question_paper_type,
                            isNegativeMarking: testRes.negativemarking,
                            duration: testRes.duration,
                            createdAt: testRes.created_at,
                            updatedAt: testRes.updated_at,
                            score: submitRes.Score ?? "Under Review",
                            checkedAnswerSheet: submitRes?.checked_answer_sheet ?? {
                                fileLoc: "",
                                fileName: "",
                                fileSize: "",
                            },
                            answerSheet: submitRes.answer_sheet
                                ? submitRes.answer_sheet
                                : {
                                    fileLoc: "",
                                    fileName: "",
                                    fileSize: "",
                                },
                            is_online: true,
                            test_mode: "both",
                            is_attempted: true,
                        });
                    }
                    if (
                        ObjTypeTestId.every((id) => newAtmpObjOnline.includes(id)) &&
                        !ObjTypeTestId.every((id) => newobjAttemptOffline.includes(id))
                    ) {
                        console.log("Objective Online attempted");
                        const submitRes = await MyAttemptedTestTable.findOne({
                            test_id: ObjTypeTestId,
                        });
                        const testRes = await TestSeriesTestTable.findById(ObjTypeTestId);
                        finalRes.push({
                            testSeriesId: testSeriesId,
                            testId: submitRes.test_id,
                            testTitle: testRes.Test_title,
                            testCode: testRes.Test_code,
                            instructions: testRes.instructions,
                            startDate: testRes.starting_date,
                            noOfQuestions: testRes.No_of_questions,
                            questionPaper: testRes.question_paper,
                            answerTemplate: testRes.answer_template,
                            totalMarkes: testRes.totalMarks,
                            questionsPaperType: testRes.question_paper_type,
                            isNegativeMarking: testRes.negativemarking,
                            duration: testRes.duration,
                            createdAt: testRes.created_at,
                            updatedAt: testRes.updated_at,
                            score: submitRes.Score ?? "Under Review",
                            checkedAnswerSheet: {
                                fileLoc: "",
                                fileName: "",
                                fileSize: "",
                            },
                            answerSheet: {
                                fileLoc: "",
                                fileName: "",
                                fileSize: "",
                            },
                            is_online: true,
                            test_mode: "online",
                            is_attempted: true,
                        });
                    }
                    if (
                        ObjTypeTestId.every((id) => newobjAttemptOffline.includes(id)) &&
                        !ObjTypeTestId.every((id) => newAtmpObjOnline.includes(id))
                    ) {
                        console.log("Objective Offline attempted");
                        const submitRes = await MyAttemptedTestTable.findOne({
                            test_id: ObjTypeTestId,
                        });
                        const testRes = await TestSeriesTestTable.findById(ObjTypeTestId);
                        finalRes.push({
                            testSeriesId: testSeriesId,
                            testId: submitRes.test_id,
                            testTitle: testRes.Test_title,
                            testCode: testRes.Test_code,
                            instructions: testRes.instructions,
                            startDate: testRes.starting_date,
                            noOfQuestions: testRes.No_of_questions,
                            questionPaper: testRes.question_paper,
                            answerTemplate: testRes.answer_template,
                            totalMarkes: testRes.totalMarks,
                            questionsPaperType: testRes.question_paper_type,
                            isNegativeMarking: testRes.negativemarking,
                            duration: testRes.duration,
                            createdAt: testRes.created_at,
                            updatedAt: testRes.updated_at,
                            score: submitRes.Score ?? "Under Review",
                            checkedAnswerSheet: submitRes.checked_answer_sheet
                                ? submitRes.checked_answer_sheet
                                : {
                                    fileLoc: "",
                                    fileName: "",
                                    fileSize: "",
                                },
                            answerSheet: submitRes.answer_sheet
                                ? submitRes.answer_sheet
                                : {
                                    fileLoc: "",
                                    fileName: "",
                                    fileSize: "",
                                },
                            is_online: false,
                            test_mode: "offline",
                            is_attempted: true,
                        });
                    }
                    if (
                        !ObjTypeTestId.every((id) => newobjAttemptOffline.includes(id)) &&
                        !ObjTypeTestId.every((id) => newAtmpObjOnline.includes(id))
                    ) {
                        for (let i = 0; i < ObjTypeTestId.length; i++) {
                            const testRes = await TestSeriesTestTable.findById(
                                ObjTypeTestId[i]
                            );
                            finalRes.push({
                                testSeriesId: testSeriesId,
                                testId: testRes._id,
                                testTitle: testRes.Test_title,
                                testCode: testRes.Test_code,
                                instructions: testRes.instructions,
                                startDate: testRes.starting_date,
                                noOfQuestions: testRes.No_of_questions,
                                questionPaper: testRes.question_paper,
                                answerTemplate: testRes.answer_template,
                                totalMarkes: testRes.totalMarks,
                                questionsPaperType: testRes.question_paper_type,
                                isNegativeMarking: testRes.negativemarking,
                                duration: testRes.duration,
                                createdAt: testRes.created_at,
                                updatedAt: testRes.updated_at,
                                score: "NA",
                                checkedAnswerSheet: {
                                    fileLoc: "",
                                    fileName: "",
                                    fileSize: "",
                                },
                                answerSheet: {
                                    fileLoc: "",
                                    fileName: "",
                                    fileSize: "",
                                },
                                is_online: true,
                                test_mode: "online",
                                is_attempted: false,
                            });
                        }
                    }
                }

                if (allTests.filter((id) => SubTypeTestId.includes(id))) {
                    console.log("Subjective Type");
                    if (allTests.every((id) => newsubAttempt.includes(id))) {
                        const submitRes = await MyAttemptedTestTable.findOne({
                            test_id: allTests,
                        });
                        const testRes = await TestSeriesTestTable.findById(allTests);
                        finalRes.push({
                            testSeriesId: testSeriesId,
                            testId: submitRes.test_id,
                            testTitle: testRes.Test_title,
                            testCode: testRes.Test_code,
                            instructions: testRes.instructions,
                            startDate: testRes.starting_date,
                            noOfQuestions: testRes.No_of_questions,
                            questionPaper: testRes.question_paper,
                            answerTemplate: testRes.answer_template,
                            totalMarkes: testRes.totalMarks,
                            questionsPaperType: testRes.question_paper_type,
                            isNegativeMarking: testRes.negativemarking,
                            duration: testRes.duration,
                            createdAt: testRes.created_at,
                            updatedAt: testRes.updated_at,
                            score: submitRes.Score ?? "Under Review",
                            checkedAnswerSheet: submitRes.checked_answer_sheet
                                ? submitRes.checked_answer_sheet
                                : {
                                    fileLoc: "",
                                    fileName: "",
                                    fileSize: "",
                                },
                            answerSheet: submitRes.answer_sheet
                                ? submitRes.answer_sheet
                                : {
                                    fileLoc: "",
                                    fileName: "",
                                    fileSize: "",
                                },
                            is_online: false,
                            test_mode: "offline",
                            is_attempted: true,
                        });
                    } else if (allTests.filter((id) => SubTypeTestId.includes(id))) {
                        for (let i = 0; i < SubTypeTestId.length; i++) {
                            const testRes = await TestSeriesTestTable.findById(
                                SubTypeTestId[i]
                            );
                            finalRes.push({
                                testSeriesId: testSeriesId,
                                testId: testRes._id,
                                testTitle: testRes.Test_title,
                                testCode: testRes.Test_code,
                                instructions: testRes.instructions,
                                startDate: testRes.starting_date,
                                noOfQuestions: testRes.No_of_questions,
                                questionPaper: testRes.question_paper,
                                answerTemplate: testRes.answer_template,
                                totalMarkes: testRes.totalMarks,
                                questionsPaperType: testRes.question_paper_type,
                                isNegativeMarking: testRes.negativemarking,
                                duration: testRes.duration,
                                createdAt: testRes.created_at,
                                updatedAt: testRes.updated_at,
                                score: "NA",
                                checkedAnswerSheet: {
                                    fileLoc: "",
                                    fileName: "",
                                    fileSize: "",
                                },
                                answerSheet: {
                                    fileLoc: "",
                                    fileName: "",
                                    fileSize: "",
                                },
                                is_online: false,
                                test_mode: "offline",
                                is_attempted: false,
                            });
                        }
                    }
                }
                return res.json({
                    status: true,
                    // data: { allTests, objAttmpOnline, objAttemptOffline, subAttempt },
                    data: finalRes,
                    msg: `${testSeries.testseries_name} Tests`,
                });
            } else {
                res.json({
                    status: false,
                    data: null,
                    msg: "User Not Found !",
                });
            }
        }
    });
});

AdminPanel.get(
    "/getAttemptedTestSeriesTestResults/:testSeriesId",
    ValidateToken,
    async (req, res) => {
        const { testSeriesId } = req.params;
        jwt.verify(req.token, process.env.ADMIN_SECRET_KEY, async (err, Data) => {
            if (err) {
                res.status(401).json({
                    status: false,
                    data: null,
                    msg: err,
                });
            } else {
                if (!testSeriesId) {
                    return res.json({
                        status: false,
                        data: null,
                        msg: "Provide TestSeries Id",
                    });
                }
                const user = await findUserByUserId(Data.studentId);
                if (!user) {
                    return res.json({
                        status: false,
                        data: null,
                        msg: "User Not Found",
                    });
                }
                const myTestSeries = await MyTestSeriesTable.find({
                    testseries_id: testSeriesId,
                    user: user._id,
                });
                if (!myTestSeries) {
                    return res.json({
                        status: false,
                        data: null,
                        msg: "Purchase the TestSeries before access",
                    });
                }
                const testSeriesTests = await TestSeriesTestTable.find({
                    TestSeries: myTestSeries[0].testseries_id,
                });
                let objtiveType = [];
                let subtiveType = [];
                let objOblineAttd = [];
                let objOfflineAttd = [];
                let subAttempted = [];
                testSeriesTests.map((item) => {
                    if (item.question_paper_type === "objective") {
                        objtiveType.push(item);
                    } else subtiveType.push(item);
                });

                if (objtiveType.length !== 0) {
                    for (let i = 0; i < objtiveType.length; i++) {
                        const res = await QuizResponseTable.find({
                            quizId: objtiveType[i]._id,
                            user_id: user._id,
                        });

                        res?.forEach((item) => {
                            // Changed .map() to .forEach() for side-effect usage
                            objOblineAttd.push({
                                id: item._id,
                                testSeriesId: objtiveType[i].TestSeries,
                                testId: objtiveType[i]._id,
                                Test_title: objtiveType[i].Test_title,
                                Test_code: objtiveType[i].Test_code,
                                attemptedAt: item.created_at,
                                attemptedtype: "submit",
                                totalMarks: objtiveType[i].totalMarks,
                                totalDucation: objtiveType[i].duration,
                                timeSpent: item.timeSpent,
                                isResultPublished: item.is_active,
                            });
                        });
                    }
                }

                if (objtiveType.length !== 0) {
                    for (let i = 0; i < objtiveType.length; i++) {
                        const res = await MyAttemptedTestTable.find({
                            test_id: objtiveType[i]._id,
                            user: user._id,
                        });
                        res?.forEach((item) => {
                            objOfflineAttd.push({
                                id: item._id,
                                testSeriesId: objtiveType[i].TestSeries,
                                testId: objtiveType[i]._id,
                                Test_title: objtiveType[i].Test_title,
                                Test_code: objtiveType[i].Test_code,
                                attemptedAt: item.created_at,
                                attemptedtype: "submit",
                                totalMarks: objtiveType[i].totalMarks,
                                totalDucation: objtiveType[i].duration,
                                timeSpent: item.timeSpent,
                                checked_answer_sheet: item.checked_answer_sheet,
                                answer_sheet: item.answer_sheet,
                                Score: item.Score,
                                isResultPublished: item.Score === "Under Review" ? false : true,
                            });
                        });
                    }
                }

                if (subtiveType.length !== 0) {
                    for (let i = 0; i < subtiveType.length; i++) {
                        const res = await MyAttemptedTestTable.find({
                            test_id: subtiveType[i]._id,
                            user: user._id,
                        });
                        res?.forEach((item) => {
                            subAttempted.push({
                                id: item._id,
                                testSeriesId: subtiveType[i].TestSeries,
                                testId: subtiveType[i]._id,
                                Test_title: subtiveType[i].Test_title,
                                Test_code: subtiveType[i].Test_code,
                                attemptedAt: item.created_at,
                                attemptedtype: "submit",
                                timeSpent: item.timeSpent,
                                totalMarks: subtiveType[i].totalMarks,
                                totalDucation: subtiveType[i].duration,
                                checked_answer_sheet: item.checked_answer_sheet,
                                answer_sheet: item.answer_sheet,
                                Score: item.Score,
                                isResultPublished: item.Score === "Under Review" ? false : true,
                            });
                        });
                    }
                }

                return res.json({
                    status: true,
                    data: {
                        objective: {
                            online: objOblineAttd,
                            offline: objOfflineAttd,
                        },
                        subjective: {
                            offline: subAttempted,
                        },
                    },
                    msg: "Results",
                });
                // const onlineAttempted = await QuizResponseTable.find({ quizId: my })
            }
        });
    }
);

AdminPanel.post(
    "/addAttemptedTest",
    ValidateToken,
    upload.single("file"),
    async (req, res) => {
        jwt.verify(req.token, process.env.ADMIN_SECRET_KEY, async (err, Data) => {
            if (err) {
                res.status(401).json({
                    status: false,
                    data: null,
                    msg: err,
                });
            } else {
                const { test_id, timeSpent } = req.body;
                const userDetails = await findUserByUserId(Data.studentId);
                const alreadyAttempted = await MyAttemptedTestTable.findOne({
                    test_id: test_id,
                    user: userDetails._id,
                });
                // if (alreadyAttempted) {
                //   return res.json({
                //     status: false,
                //     data: null,
                //     msg: "You have already attempted the test.",
                //   });
                // }
                if (userDetails) {
                    let fileLoc;
                    if (req.file) {
                        const helperString = Math.floor(Date.now() / 1000);
                        const filename = (req.file.originalname.split(".")[0]).replace(/\s+/g, '_').replace(/[^a-zA-Z0-9_]/g, '');
                        const extension = "." + req.file.originalname.split(".").pop();
                        FileUploadLocation = `Attempted/${test_id}/${userDetails._id}/${filename}_${helperString}${extension}`;
                        let helperfileLoc = await uploadFile(
                            req.file.path,
                            FileUploadLocation
                        );
                        fileLoc = fileDetails(req.file, helperfileLoc);
                    }
                    const TestDetails = await TestDetailsByTestId(test_id);
                    // console.log(TestDetails);
                    const Attempteddetails = await new MyAttemptedTestTable({
                        user: userDetails._id,
                        test_id: test_id,
                        testSeries_id: TestDetails.TestSeries,
                        Score: "Under Review",
                        answer_sheet: fileLoc,
                        is_active: true,
                        is_livetest: false,
                        timeSpent,
                        created_at: formatDate(
                            new Date(moment().add(5, "hours").add(30, "minutes"))
                        ),
                    });
                    const res1 = await Attempteddetails.save();
                    let data;
                    if (userDetails.language === "hi") {
                        data = {
                            title: TestDetails.Test_title,
                            message: ` ${TestDetails.Test_title}      `,
                            route: "attempttest",
                        };
                    } else {
                        data = {
                            title: TestDetails.Test_title,
                            message: `You attempted ${TestDetails.Test_title}  successfully`,
                            route: "attempttest",
                        };
                    }
                    const myNotifi = new myNotificationModel({
                        user: userDetails._id,
                        title: data.title,
                        message: data.message,
                        route: data.route,
                    });
                    await myNotifi.save();
                    await sendPushNotification(userDetails.fcmToken, data);
                    if (res1) {
                        res.json({
                            status: true,
                            data: Attempteddetails,
                            msg: "Test Attempted Successfully",
                        });
                    } else {
                        res.json({
                            status: true,
                            data: null,
                            msg: "Error",
                        });
                    }
                } else {
                    res.json({
                        status: false,
                        data: null,
                        msg: "Not an user",
                    });
                }
            }
        });
    }
);

AdminPanel.post("/submitesttanswers", ValidateToken, async (req, res) => {
    jwt.verify(req.token, process.env.ADMIN_SECRET_KEY, async (err, Data) => {
        if (err) {
            res.status(401).json({
                status: false,
                data: null,
                msg: err,
            });
        } else {
            const { test_id, answer_arr } = req.body;
            const userDetails = await findUserByUserId(Data.studentId);
            const alreadyAttempted = await attemptTest.findOne({
                test_id: test_id,
                user: userDetails._id,
            });
            if (alreadyAttempted) {
                return res.json({
                    status: false,
                    data: null,
                    msg: "User has Already attempted the test",
                });
            }
            if (userDetails) {
                const Attempteddetails = await new attemptTest({
                    user: userDetails._id,
                    test_id: test_id,
                    answer_arr: answer_arr,
                    is_livetest: false,
                    score: "Under Review",
                    created_at: formatDate(
                        new Date(moment().add(5, "hours").add(30, "minutes"))
                    ),
                });
                await Attempteddetails.save();
                res.json({
                    status: true,
                    data: Attempteddetails,
                    msg: "response submitted",
                });
            } else {
                res.json({
                    status: false,
                    data: null,
                    msg: "Not an user",
                });
            }
        }
    });
});

AdminPanel.get(
    "/getAttemptedTest",
    ValidateToken,
    upload.single("file"),
    async (req, res) => {
        jwt.verify(req.token, process.env.ADMIN_SECRET_KEY, async (err, Data) => {
            if (err) {
                res.status(401).json({
                    status: false,
                    data: null,
                    msg: err,
                });
            } else {
                const { testSeriesId } = req.query;
                const userDetails = await findUserByUserId(Data.studentId);
                if (userDetails) {
                    if (testSeriesId) {
                        const AttemptedDetails = await MyAttemptedTestTable.find({
                            user: userDetails._id,
                            testSeries_id: testSeriesId,
                        });
                        if (AttemptedDetails) {
                            res.json({
                                status: true,
                                data: AttemptedDetails,
                                msg: "Fetched all the attempted tests",
                            });
                        } else {
                            res.json({
                                status: false,
                                data: null,
                                msg: "no data found",
                            });
                        }
                    } else {
                        const AttemptedDetails = await MyAttemptedTestTable.find({
                            user: userDetails._id,
                        });
                        if (AttemptedDetails) {
                            res.json({
                                status: true,
                                data: AttemptedDetails,
                                msg: "Fetched all the attempted tests",
                            });
                        } else {
                            res.json({
                                status: false,
                                data: null,
                                msg: "no data found",
                            });
                        }
                    }
                } else {
                    res.json({
                        status: false,
                        data: null,
                        msg: "Not an user",
                    });
                }
            }
        });
    }
);

AdminPanel.get(
    "/getAttemptedTestAdminPanelSide",
    ValidateToken,
    upload.single("file"),
    async (req, res) => {
        jwt.verify(req.token, process.env.ADMIN_SECRET_KEY, async (err, Data) => {
            if (err) {
                res.status(401).json({
                    status: false,
                    data: null,
                    msg: err,
                });
            } else {
                const { testId, userId } = req.query;
                const userDetails = await findAdminTeacherUsingUserId(Data.studentId);
                // const admintDetails=await find
                if (userDetails) {
                    if (testId && userId) {
                        const AttemptedDetails = await MyAttemptedTestTable.find({
                            user: userId,
                            test_id: testId,
                        })
                            .populate("user")
                            .populate("test_id", {
                                Test_title: 1,
                                Test_code: 1,
                            })
                            .populate("testSeries_id", {
                                testseries_name: 1,
                            });
                        if (AttemptedDetails) {
                            res.json({
                                status: true,
                                data: AttemptedDetails,
                                msg: "Fetched all the attempted tests",
                            });
                        } else {
                            res.json({
                                status: false,
                                data: null,
                                msg: "no data found",
                            });
                        }
                    } else if (testId && !userId) {
                        const AttemptedDetails = await MyAttemptedTestTable.find({
                            test_id: testId,
                        })
                            .populate("user")
                            .populate("test_id", {
                                Test_title: 1,
                                Test_code: 1,
                            })
                            .populate("testSeries_id", {
                                testseries_name: 1,
                            });
                        if (AttemptedDetails) {
                            res.json({
                                status: true,
                                data: AttemptedDetails,
                                msg: "Fetched all the attempted tests",
                            });
                        } else {
                            res.json({
                                status: false,
                                data: null,
                                msg: "no data found",
                            });
                        }
                    } else if (!testId && userId) {
                        const AttemptedDetails = await MyAttemptedTestTable.find({
                            user: userId,
                        })
                            .populate("user")
                            .populate("test_id", {
                                Test_title: 1,
                                Test_code: 1,
                            })
                            .populate("testSeries_id", {
                                testseries_name: 1,
                            });
                        if (AttemptedDetails) {
                            res.json({
                                status: true,
                                data: AttemptedDetails,
                                msg: "Fetched all the attempted tests",
                            });
                        } else {
                            res.json({
                                status: false,
                                data: null,
                                msg: "no data found",
                            });
                        }
                    } else {
                        const AttemptedDetails = await MyAttemptedTestTable.find({})
                            .populate("user")
                            .populate("test_id", {
                                Test_title: 1,
                                Test_code: 1,
                            })
                            .populate("testSeries_id", {
                                testseries_name: 1,
                            });
                        if (AttemptedDetails) {
                            res.json({
                                status: true,
                                data: AttemptedDetails,
                                msg: "Fetched all the attempted tests",
                            });
                        } else {
                            res.json({
                                status: false,
                                data: null,
                                msg: "no data found",
                            });
                        }
                    }
                } else {
                    res.json({
                        status: false,
                        data: null,
                        msg: "Not an user",
                    });
                }
            }
        });
    }
);

AdminPanel.get(
    "/getStudentsOfTestSeries/:id",
    ValidateToken,
    upload.single("file"),
    async (req, res) => {
        jwt.verify(req.token, process.env.ADMIN_SECRET_KEY, async (err, Data) => {
            if (err) {
                res.status(401).json({
                    status: false,
                    data: null,
                    msg: err,
                });
            } else {
                const adminDetails = await findAdminTeacherUsingUserId(Data.studentId);
                const { id } = req.params;
                if (adminDetails) {
                    const Students = await MyTestSeriesTable.find({
                        testseries_id: id,
                    }).populate("user");
                    if (Students) {
                        res.json({
                            status: true,
                            data: Students,
                            msg: "Fetched all the students who have purchased",
                        });
                    } else {
                        res.json({
                            status: false,
                            data: null,
                            msg: "No data found",
                        });
                    }
                } else {
                    res.json({
                        status: false,
                        data: null,
                        msg: "Not an admin",
                    });
                }
            }
        });
    }
);

AdminPanel.put(
    "/updateAttemptedTestSeries/:id",
    upload.single("file"),
    ValidateToken,
    async (req, res) => {
        jwt.verify(req.token, process.env.ADMIN_SECRET_KEY, async (err, Data) => {
            if (err) {
                res.status(401).json({
                    status: false,
                    data: null,
                    msg: err,
                });
            } else {
                const { Score } = req.body;
                const { id } = req.params;
                const AdminTeacherDetails = await findAdminTeacherUsingUserId(
                    Data.studentId
                );
                if (AdminTeacherDetails) {
                    const findTest = await MyAttemptedTestTable.findOne({
                        _id: id,
                    });
                    if (findTest) {
                        let fileLoc;
                        if (req.file) {
                            const helperString = Math.floor(Date.now() / 1000);
                            const filename = (req.file.originalname.split(".")[0]).replace(/\s+/g, '_').replace(/[^a-zA-Z0-9_]/g, '');
                            const extension = "." + req.file.originalname.split(".").pop();
                            FileUploadLocation = `Attempted/${findTest.test_id}/${findTest.user}/${filename}_${helperString}${extension}`;
                            let helperfileLoc = await uploadFile(
                                req.file.path,
                                FileUploadLocation
                            );
                            fileLoc = fileDetails(req.file, helperfileLoc);
                        } else {
                            fileLoc = findTest.checked_answer_sheet;
                        }
                        await MyAttemptedTestTable.findByIdAndUpdate(
                            { _id: id },
                            {
                                Score: Score,
                                checked_answer_sheet: fileLoc,
                            }
                        );
                        const test = await TestSeriesTestTable.findById(findTest.test_id);
                        const student = await UserTable.findById(findTest.user);
                        let data;
                        if (student.language === "hi") {
                            data = {
                                title: test.Test_title,
                                message: `${test.Test_title}          `,
                                route: "testresult",
                            };
                        } else {
                            data = {
                                title: test.Test_title,
                                message: `${test.Test_title} result have been published. Do Check Now`,
                                route: "testresult",
                            };
                        }
                        const myNotifi = new myNotificationModel({
                            user: student._id,
                            title: data.title,
                            message: data.message,
                            route: data.route,
                        });
                        await myNotifi.save();
                        await sendPushNotification(student.fcmToken, data);
                        res.json({
                            status: true,
                            data: null,
                            msg: "Added the score",
                        });
                    } else {
                        res.json({
                            status: false,
                            data: null,
                            msg: "Test Details Not Found",
                        });
                    }
                } else {
                    res.json({
                        status: false,
                        data: null,
                        msg: "Not Authorized",
                    });
                }
            }
        });
    }
);

////
AdminPanel.get("/getMyTestSeries", ValidateToken, async (req, res) => {
    try {
        const user = await jwt.verify(req.token, process.env.ADMIN_SECRET_KEY);
        if (!user) {
            return res.status(401).json({
                status: false,
                data: null,
                msg: "Invalid token",
            });
        }

        const userDetails = await findUserByUserId(user.studentId);
        if (!userDetails) {
            return res.json({
                status: false,
                data: null,
                msg: "User not found",
            });
        }

        const myTestSeriesDetails = await MyTestSeriesTable.find({
            user: userDetails._id,
            is_paid: true,
            is_active: true,
        }).populate({
            path: "testseries_id",
            match: { no_of_test: { $gt: 0 } }, // Include documents where no_of_test > 0
        });
        const helperArray = [];
        await Promise.all(
            myTestSeriesDetails.map(async (myTestSeriesDetail) => {
                if (myTestSeriesDetail.testseries_id) {
                    const tests = await TestSeriesTestTable.find({
                        TestSeries: myTestSeriesDetail.testseries_id,
                    });

                    const [attemptedOffline, attemptedOnline] = await Promise.all([
                        MyAttemptedTestTable.aggregate([
                            {
                                $match: {
                                    user: userDetails._id,
                                    test_id: { $in: tests.map((test) => test._id) },
                                },
                            },
                            {
                                $group: {
                                    _id: "$test_id",
                                    firstDocument: { $first: "$$ROOT" },
                                },
                            },
                            { $replaceRoot: { newRoot: "$firstDocument" } },
                        ]),
                        QuizResponseTable.aggregate([
                            {
                                $match: {
                                    user_id: userDetails._id,
                                    quizId: { $in: tests.map((test) => test._id) },
                                },
                            },
                            {
                                $group: { _id: "$quizId", firstDocument: { $first: "$$ROOT" } },
                            },
                            { $replaceRoot: { newRoot: "$firstDocument" } },
                        ]),
                    ]);

                    const attemptedTestIds = [
                        ...attemptedOffline,
                        ...attemptedOnline,
                    ].map((item) => item._id);
                    // console.log(attemptedTestIds.length)
                    const percentage = attemptedTestIds.length / tests.length;
                    const helperObj = {
                        ...myTestSeriesDetail.toObject(),
                        progress: {
                            percentage: tests.length !== 0 ? percentage.toString() : "0",
                            value: `${attemptedTestIds.length}/${tests.length}`,
                        },
                    };

                    helperArray.push(helperObj);
                }
            })
        );

        return res.json({
            status: true,
            data: helperArray,
            msg: "Fetched all the MyTestSeriesDetails",
        });
    } catch (error) {
        return res.status(500).json({
            status: false,
            data: null,
            msg: "Internal server error",
        });
    }
});

AdminPanel.get(
    "/getTestSeriesPurchased/:id",
    ValidateToken,
    async (req, res) => {
        jwt.verify(req.token, process.env.ADMIN_SECRET_KEY, async (err, Data) => {
            if (err) {
                res.status(401).json({
                    status: false,
                    data: null,
                    msg: err,
                });
            } else {
                const { id } = req.params;
                const TestSeries = await MyTestSeriesTable.find(
                    { user: id },
                    {
                        amount: 0,
                        user: 0,
                        is_paid: 0,
                        is_active: 0,
                        __v: 0,
                        updated_at: 0,
                    }
                ).populate("testseries_id", { testseries_name: 1 });
                if (TestSeries) {
                    res.json({
                        status: true,
                        data: TestSeries,
                        msg: "Fetched all the testSeries of the user",
                    });
                } else {
                    res.json({
                        status: false,
                        data: null,
                        msg: "No data found",
                    });
                }
            }
        });
    }
);

AdminPanel.get(
    "/getTestDetailsPerticular/:id",
    ValidateToken,
    async (req, res) => {
        jwt.verify(req.token, process.env.ADMIN_SECRET_KEY, async (err, Data) => {
            if (err) {
                res.status(401).json({
                    status: false,
                    data: null,
                    msg: err,
                });
            } else {
                const { id } = req.params;
                const TestDetails = await TestSeriesTestTable.findOne({
                    _id: id,
                });
                if (TestDetails) {
                    res.json({
                        status: true,
                        data: TestDetails,
                        msg: "Fetched all the testSeries of the user",
                    });
                } else {
                    res.json({
                        status: false,
                        data: null,
                        msg: "No data found",
                    });
                }
            }
        });
    }
);

AdminPanel.get(
    "/getMySchedularTeacherSide",
    ValidateToken,
    async (req, res) => {
        jwt.verify(req.token, process.env.ADMIN_SECRET_KEY, async (err, Data) => {
            if (err) {
                res.status(401).json({
                    err: err,
                    status: false,
                    data: null,
                    msg: "not an user",
                });
            } else {
                let date = new Date();
                let end = new Date(date.getUTCFullYear(), date.getUTCMonth(), date.getUTCDate(), 28, 89, 59, 59)
                let start = new Date(date.getUTCFullYear(), date.getUTCMonth(), date.getUTCDate(), 5, 30, 0, 0)

                const userDetails = await findAdminTeacherUsingUserId(Data.studentId);
                if (userDetails?.Role == "admin" || userDetails?.Role == "subadmin") {
                    const LectureDetails = await LectureTable.find({
                        startingDate: { $gte: start, $lte: end }
                    }).populate(
                        "teacher",
                        {
                            _id: 1,
                            profilePhoto: 1,
                            FullName: 1,
                        }
                    ).populate("batch", { _id: 1, batch_name: 1 });
                    res.json({
                        status: true,
                        data: LectureDetails?.map((item, index) => { return { ...item?._doc, id: item?._id, sno: index + 1 } }),
                        msg: "fetched all the schedules",
                    });
                } else {
                    res.json({
                        status: true,
                        data: [],
                        msg: "fetched all the schedules",
                    });

                }
            }
        });
    }
);

AdminPanel.get(
    "/getLectureDetailsAssigned",
    ValidateToken,
    async (req, res) => {
        jwt.verify(req.token, process.env.ADMIN_SECRET_KEY, async (err, Data) => {
            if (err) {
                res.status(401).json({
                    err: err,
                    status: false,
                    data: null,
                    msg: "not an user",
                });
            } else {
                const userDetails = await findAdminTeacherUsingUserId(Data.studentId);
                if (userDetails) {
                    const { BatchId } = req.query;
                    const LectureDetails = await LectureTable.find({
                        batch: BatchId,
                    }).populate("teacher", {
                        _id: 1,
                        profilePhoto: 1,
                        FullName: 1,
                    });
                    if (userDetails.Role === "subadmin") {
                        res.json({
                            status: true,
                            data: LectureDetails,
                            msg: "Subadmin all Lectures",
                        });
                    } else {
                        let FilterTeacherFinal = LectureDetails.filter((lecture) => {
                            let check = false;
                            for (let i = 0; i < lecture.teacher.length; i++) {
                                const helper1 = lecture.teacher[i]._id.toHexString();
                                const helper2 = userDetails._id.toHexString();
                                if (helper1 == helper2) {
                                    check = true;
                                    break;
                                }
                            }
                            return check == true;
                        });
                        res.json({
                            status: true,
                            data: FilterTeacherFinal,
                            msg: "Fetched all Lectures",
                        });
                    }
                } else {
                    res.json({
                        status: false,
                        data: null,
                        msg: "Not an Teacher",
                    });
                }
            }
        });
    }
);

// AdminPanel.get('/LearningAggregate',async (req,res)=>{
//   const starting_date='01/12/2021 00:00:00'
//   const ending_date='1/1/2023 00:00:00'
//   const userDetails=await UserTable.aggregate([{ $match: {created_at: {$gte:starting_date,$lt:ending_date} } }])
//   res.json({
//     data:userDetails
//   })
// })

AdminPanel.post(
    "/addTestQuestions/:testID",
    ValidateToken,
    async (req, res) => {
        jwt.verify(req.token, process.env.ADMIN_SECRET_KEY, async (err, Data) => {
            if (err) {
                res.status(401).json({
                    err: err,
                    status: false,
                    data: null,
                    msg: "not an user",
                });
            } else {
                const AdminTeacherDetails = await findAdminTeacherUsingUserId(
                    Data.studentId
                );
                if (AdminTeacherDetails) {
                    const { testID } = req.params;
                    const {
                        question_title,
                        option1,
                        option2,
                        option3,
                        option4,
                        answer,
                        correctOption,
                        is_active,
                    } = req.body;
                    const TestDetails = await TestSeriesTestTable.findOne({
                        _id: testID,
                    });
                    if (TestDetails) {
                        const TestSeriesId = TestDetails.TestSeries;
                        const newTestQuestions = await new TestQuestionsTable({
                            user: AdminTeacherDetails._id,
                            testSeries_id: TestSeriesId,
                            test_id: TestDetails._id,
                            question_title: question_title,
                            option1: option1,
                            option2: option2,
                            option3: option3,
                            option4: option4,
                            answer: answer,
                            correctOption: correctOption,
                            is_active: is_active,
                            created_at: formatDate(
                                new Date(moment().add(5, "hours").add(30, "minutes"))
                            ),
                            updated_at: formatDate(
                                new Date(moment().add(5, "hours").add(30, "minutes"))
                            ),
                        });
                        await newTestQuestions.save();
                        res.json({
                            status: true,
                            data: newTestQuestions,
                            msg: "added the question Successfully",
                        });
                    } else {
                        res.json({
                            status: false,
                            data: null,
                            msg: "Test Details not found",
                        });
                    }
                } else {
                    res.json({
                        status: false,
                        data: null,
                        msg: "Not an adminTeacher",
                    });
                }
            }
        });
    }
);

AdminPanel.delete(
    "/DeleteTestQuestions/:testID",
    ValidateToken,
    async (req, res) => {
        jwt.verify(req.token, process.env.ADMIN_SECRET_KEY, async (err, Data) => {
            if (err) {
                res.status(401).json({
                    err: err,
                    status: false,
                    data: null,
                    msg: "not an user",
                });
            } else {
                const { testID } = req.params;
                const TestDetails = await TestQuestionsTable.findOne({
                    _id: testID,
                });
                if (TestDetails) {
                    await TestQuestionsTable.findByIdAndDelete({});
                    await savePanelEventLogs(
                        adminTeacher?._id,
                        "deleteTestQuestions",
                        "delete",
                        TestDetails
                    )
                    res.json({
                        status: true,
                        data: null,
                        msg: "Deleted the TestQuestion",
                    });
                } else {
                    res.json({
                        status: false,
                        data: null,
                        msg: "TestQuestion not found",
                    });
                }
            }
        });
    }
);

AdminPanel.put(
    "/UpdateTestQuestions/:testQuestionID",
    ValidateToken,
    async (req, res) => {
        jwt.verify(req.token, process.env.ADMIN_SECRET_KEY, async (err, Data) => {
            if (err) {
                res.status(401).json({
                    err: err,
                    status: false,
                    data: null,
                    msg: "not an user",
                });
            } else {
                const AdminTeacherDetails = await findAdminTeacherUsingUserId(
                    Data.studentId
                );
                if (AdminTeacherDetails) {
                    const {
                        TestSeriesId,
                        testId,
                        question_title,
                        option1,
                        option2,
                        option3,
                        option4,
                        answer,
                        correctOption,
                        is_active,
                    } = req.body;
                    const { testQuestionID } = req.params;
                    const TestDetails = await TestQuestionsTable.findOne({
                        _id: testQuestionID,
                    });
                    if (TestDetails) {
                        await TestQuestionsTable.findByIdAndUpdate(
                            { _id: testQuestionID },
                            {
                                user: AdminTeacherDetails._id,
                                testSeries_id: TestSeriesId,
                                test_id: testId,
                                question_title: question_title,
                                option1: option1,
                                option2: option2,
                                option3: option3,
                                option4: option4,
                                answer: answer,
                                correctOption: correctOption,
                                is_active: is_active,
                                updated_at: formatDate(
                                    new Date(moment().add(5, "hours").add(30, "minutes"))
                                ),
                            }
                        );
                        res.json({
                            status: true,
                            data: null,
                            msg: "Updated the TestQuestionsDetails Updated successfully",
                        });
                    } else {
                        res.json({
                            status: false,
                            data: null,
                            msg: "TestDetails not found",
                        });
                    }
                } else {
                    res.json({
                        status: false,
                        data: null,
                        msg: "Not authorized",
                    });
                }
            }
        });
    }
);

AdminPanel.get("/getTestQuestions/:testID", ValidateToken, async (req, res) => {
    jwt.verify(req.token, process.env.ADMIN_SECRET_KEY, async (err, Data) => {
        if (err) {
            res.status(401).json({
                err: err,
                status: false,
                data: null,
                msg: "not an user",
            });
        } else {
            const userDetails = await findUserByUserId(Data.studentId);
            if (userDetails) {
                const { testID } = req.params;
                const allQuestions = await TestQuestionsTable.find({
                    test_id: testID,
                    is_active: true,
                });
                if (allQuestions) {
                    res.json({
                        status: true,
                        data: allQuestions,
                        msg: "Fetched all the questions",
                    });
                } else {
                    res.json({
                        status: false,
                        data: null,
                        msg: "no questions found",
                    });
                }
            } else {
                res.json({
                    status: false,
                    data: null,
                    msg: "Not an user",
                });
            }
        }
    });
});

AdminPanel.get(
    "/getTestQuestionsAdminSide/:testID",
    ValidateToken,
    async (req, res) => {
        jwt.verify(req.token, process.env.ADMIN_SECRET_KEY, async (err, Data) => {
            if (err) {
                res.status(401).json({
                    err: err,
                    status: false,
                    data: null,
                    msg: "not an user",
                });
            } else {
                const userDetails = await findAdminTeacherUsingUserId(Data.studentId);
                if (userDetails) {
                    const { testID } = req.params;
                    //  if(testID && !userId){
                    const allQuestions = await TestQuestionsTable.find({
                        test_id: testID,
                    });
                    if (allQuestions) {
                        res.json({
                            status: true,
                            data: allQuestions,
                            msg: "Fetched all the questions",
                        });
                    } else {
                        res.json({
                            status: false,
                            data: null,
                            msg: "no questions found",
                        });
                    }
                } else {
                    res.json({
                        status: false,
                        data: null,
                        msg: "Not an user",
                    });
                }
            }
        });
    }
);

AdminPanel.post("/addresponseTestQuestion", ValidateToken, async (req, res) => {
    jwt.verify(req.token, process.env.ADMIN_SECRET_KEY, async (err, Data) => {
        if (err) {
            res.status(401).json({
                err: err,
                status: false,
                data: null,
                msg: "not an user",
            });
        } else {
            const { TestQuestionId, selected_answer, is_active, testId } = req.body;
            const StudentDetails = await findUserByUserId(Data.studentId);
            if (StudentDetails) {
                const TestQuestionDetails = await TestQuestionsTable.findOne({
                    _id: TestQuestionId,
                });
                if (TestQuestionDetails) {
                    const ResponseTestDetails = await new ResponseTestTable({
                        user: StudentDetails._id,
                        TestQuestionId: TestQuestionId,
                        selected_answer: selected_answer,
                        is_active: is_active,
                        testId: testId,
                    });
                    await ResponseTestDetails.save();
                    res.json({
                        status: true,
                        data: ResponseTestDetails,
                        msg: "added the Response",
                    });
                } else {
                    res.json({
                        status: false,
                        data: null,
                        msg: "TestQuestion not found",
                    });
                }
            } else {
                res.json({
                    status: false,
                    data: null,
                    msg: "not an student",
                });
            }
        }
    });
});

AdminPanel.get(
    "/getResponsesTestQuestions",
    ValidateToken,
    async (req, res) => {
        jwt.verify(req.token, process.env.ADMIN_SECRET_KEY, async (err, Data) => {
            if (err) {
                res.status(401).json({
                    err: err,
                    status: false,
                    data: null,
                    msg: "not an user",
                });
            } else {
                const userDetails = await findUserByUserId(Data.studentId);
                const { testquestionId } = req.query;
                const { testId } = req.query;
                if (userDetails) {
                    if (testquestionId) {
                        const ResponseDetails = await ResponseTestTable.findOne({
                            user: userDetails._id,
                            TestQuestionId: testquestionId,
                        });
                        const TestQUestionDetails = await TestQuestionsTable.findOne({
                            _id: testquestionId,
                        });
                        let helperResponseDetails;
                        let helperArray = [];
                        if (
                            TestQUestionDetails.correctOption ==
                            ResponseDetails.selected_answer
                        ) {
                            helperResponseDetails = ResponseDetails.toObject();
                            helperResponseDetails.answer = true;
                        } else {
                            helperResponseDetails = ResponseDetails.toObject();
                            helperResponseDetails.answer = false;
                        }
                        helperArray.push(helperResponseDetails);
                        if (ResponseDetails) {
                            res.json({
                                status: false,
                                data: helperArray,
                                msg: "fetched all the Responses submitted",
                            });
                        } else {
                            res.json({
                                status: false,
                                data: null,
                                msg: "Response details not found",
                            });
                        }
                    } else if (testId) {
                        const CheckAnswers = await TestQuestionsTable.find({
                            test_id: testId,
                        });
                        //  console.log(CheckAnswers)
                        const answermap = new Map();
                        for (let i = 0; i < CheckAnswers.length; i++) {
                            const helperObj = {
                                id: CheckAnswers[i]._id,
                                correctAnswer: CheckAnswers[i].correctOption,
                            };
                            const helperChecker = CheckAnswers[i]._id.toHexString();
                            answermap.set(helperChecker, helperObj);
                        }
                        // const ResponseDetails=await ResponseTestTable.find({user:userDetails._id,testId:testId});
                        const ResponsesDetails = await ResponseTestTable.find({
                            user: userDetails._id,
                            testId: testId,
                        });
                        let ResponseArray = [];
                        if (ResponsesDetails) {
                            for (let i = 0; i < ResponsesDetails.length; i++) {
                                const correctAnswer = answermap.get(
                                    ResponsesDetails[i].TestQuestionId.toHexString()
                                );
                                if (correctAnswer) {
                                    if (
                                        ResponsesDetails[i].selected_answer ==
                                        correctAnswer.correctAnswer
                                    ) {
                                        const resultOfTest = ResponsesDetails[i].toObject();
                                        resultOfTest.answer = true;
                                        ResponseArray.push(resultOfTest);
                                    } else {
                                        const resultOfTest = ResponsesDetails[i].toObject();
                                        resultOfTest.answer = false;
                                        ResponseArray.push(resultOfTest);
                                    }
                                }
                            }
                            res.json({
                                status: true,
                                data: ResponseArray,
                                msg: "Fetched the Results",
                            });
                        }
                    } else {
                        res.json({
                            status: false,
                            data: null,
                            msg: "No data found",
                        });
                    }
                } else {
                    res.json({
                        status: false,
                        data: null,
                        msg: "Not an user",
                    });
                }
            }
        });
    }
);

AdminPanel.get("/getTestQuestionsResult", ValidateToken, async (req, res) => {
    jwt.verify(req.token, process.env.ADMIN_SECRET_KEY, async (err, Data) => {
        if (err) {
            res.status(401).json({
                err: err,
                status: false,
                data: null,
                msg: "not an user",
            });
        } else {
            const userDetails = await findUserByUserId(Data.studentId);
            if (userDetails) {
                const { testId } = req.body;
                const CheckAnswers = await TestQuestionsTable.find({
                    test_id: testId,
                });
                //  console.log(CheckAnswers)
                const answermap = new Map();
                for (let i = 0; i < CheckAnswers.length; i++) {
                    const helperObj = {
                        id: CheckAnswers[i]._id,
                        correctAnswer: CheckAnswers[i].correctOption,
                    };
                    const helperChecker = CheckAnswers[i]._id.toHexString();
                    answermap.set(helperChecker, helperObj);
                }
                if (userDetails) {
                    const ResponsesDetails = await ResponseTestTable.find({
                        user: userDetails._id,
                        testId: testId,
                    });
                    let ResponseArray = [];
                    if (ResponsesDetails) {
                        for (let i = 0; i < ResponsesDetails.length; i++) {
                            const correctAnswer = answermap.get(
                                ResponsesDetails[i].TestQuestionId.toHexString()
                            );
                            if (correctAnswer) {
                                if (
                                    ResponsesDetails[i].selected_answer ==
                                    correctAnswer.correctAnswer
                                ) {
                                    const resultOfTest = ResponsesDetails[i].toObject();
                                    resultOfTest.answer = true;
                                    ResponseArray.push(resultOfTest);
                                } else {
                                    const resultOfTest = ResponsesDetails[i].toObject();
                                    resultOfTest.answer = false;
                                    ResponseArray.push(resultOfTest);
                                }
                            }
                        }
                        res.json({
                            status: true,
                            data: ResponseArray,
                            msg: "Fetched the Results",
                        });
                    }
                } else {
                    res.json({
                        status: false,
                        data: null,
                        msg: "No data found",
                    });
                }
            } else {
                res.json({
                    status: false,
                    data: null,
                    msg: "Not an user",
                });
            }
        }
    });
});

AdminPanel.get(
    "/getTestResponsesAdminSide",
    ValidateToken,
    async (req, res) => {
        jwt.verify(req.token, process.env.ADMIN_SECRET_KEY, async (err, Data) => {
            if (err) {
                res.status(401).json({
                    err: err,
                    status: false,
                    data: null,
                    msg: "not an user",
                });
            } else {
                const adminteacherdetails = await findAdminTeacherUsingUserId(
                    Data.studentId
                );
                if (adminteacherdetails) {
                    const { testId, userId } = req.query;
                    if (testId && !userId) {
                        const CheckAnswers = await TestQuestionsTable.find({
                            test_id: testId,
                        });
                        //  console.log(CheckAnswers)
                        const answermap = new Map();
                        for (let i = 0; i < CheckAnswers.length; i++) {
                            const helperObj = {
                                id: CheckAnswers[i]._id,
                                correctAnswer: CheckAnswers[i].correctOption,
                            };
                            const helperChecker = CheckAnswers[i]._id.toHexString();
                            answermap.set(helperChecker, helperObj);
                        }
                        const ResponsesDetails = await ResponseTestTable.find({
                            testId: testId,
                        });
                        let ResponseArray = [];
                        if (ResponsesDetails) {
                            for (let i = 0; i < ResponsesDetails.length; i++) {
                                const correctAnswer = answermap.get(
                                    ResponsesDetails[i].TestQuestionId.toHexString()
                                );
                                if (correctAnswer) {
                                    if (
                                        ResponsesDetails[i].selected_answer ==
                                        correctAnswer.correctAnswer
                                    ) {
                                        const resultOfTest = ResponsesDetails[i].toObject();
                                        resultOfTest.answer = true;
                                        ResponseArray.push(resultOfTest);
                                    } else {
                                        const resultOfTest = ResponsesDetails[i].toObject();
                                        resultOfTest.answer = false;
                                        ResponseArray.push(resultOfTest);
                                    }
                                }
                            }
                            res.json({
                                status: true,
                                data: ResponseArray,
                                msg: "Fetched the Results",
                            });
                        }
                    } else if (userId && !testId) {
                        const ResponsesDetails = await ResponseTestTable.find({
                            user: userId,
                        });
                        let ResponseArray = [];
                        if (ResponsesDetails) {
                            for (let i = 0; i < ResponsesDetails.length; i++) {
                                const correctAnswer = await TestQuestionsTable.findOne({
                                    _id: ResponsesDetails[i].TestQuestionId,
                                });
                                if (correctAnswer) {
                                    if (
                                        ResponsesDetails[i].selected_answer ==
                                        correctAnswer.correctOption
                                    ) {
                                        const resultOfTest = ResponsesDetails[i].toObject();
                                        resultOfTest.answer = true;
                                        ResponseArray.push(resultOfTest);
                                    } else {
                                        const resultOfTest = ResponsesDetails[i].toObject();
                                        resultOfTest.answer = false;
                                        ResponseArray.push(resultOfTest);
                                    }
                                }
                            }
                            res.json({
                                status: true,
                                data: ResponseArray,
                                msg: "Fetched the Results",
                            });
                        }
                    } else {
                        const ResponsesDetails = await ResponseTestTable.find({
                            user: userId,
                            testId: testId,
                        });
                        let ResponseArray = [];
                        if (ResponsesDetails) {
                            for (let i = 0; i < ResponsesDetails.length; i++) {
                                const correctAnswer = await TestQuestionsTable.findOne({
                                    _id: ResponsesDetails[i].TestQuestionId,
                                });
                                if (correctAnswer) {
                                    if (
                                        ResponsesDetails[i].selected_answer ==
                                        correctAnswer.correctOption
                                    ) {
                                        const resultOfTest = ResponsesDetails[i].toObject();
                                        resultOfTest.answer = true;
                                        ResponseArray.push(resultOfTest);
                                    } else {
                                        const resultOfTest = ResponsesDetails[i].toObject();
                                        resultOfTest.answer = false;
                                        ResponseArray.push(resultOfTest);
                                    }
                                }
                            }
                            res.json({
                                status: true,
                                data: ResponseArray,
                                msg: "Fetched the Results",
                            });
                        }
                    }
                } else {
                    res.json({
                        status: false,
                        data: null,
                        msg: "Not Authorized",
                    });
                }
            }
        });
    }
);

// timeSpendOnLecture

// create
AdminPanel.post("/createTimeSpend", ValidateToken, async (req, res) => {
    const { lectureId, timeSpend } = req.body;
    if (!lectureId) {
        return res.json({
            status: false,
            data: null,
            msg: `Lecture Id not Found`
        })
    }
    try {
        const decoded = jwt.verify(req.token, process.env.SECRET_KEY);
        const studentDetails = await findUserByUserId(decoded.studentId);
        if (!studentDetails) {
            return res.json({
                status: false,
                data: null,
                msg: 'not an user'
            })
        }
        const isLecture = await LectureTable.findOne({ _id: lectureId });
        if (!isLecture) {
            return res.json({
                status: false,
                data: null,
                msg: ``
            })
        }
        const isTimeSpend = await timeSpendOnLecture.findOne({ lecture: lectureId, user: studentDetails._id });
        if (isTimeSpend) {
            let newTimeSpend = parseInt(isTimeSpend.timeSpend) + parseInt(timeSpend);
            const updateTimeSpend = await timeSpendOnLecture.findByIdAndUpdate(
                isTimeSpend._id,
                {
                    timeSpend: newTimeSpend
                },
                { new: true, lean: true }
            )
            return res.json({
                status: true,
                data: updateTimeSpend.timeSpend,
                msg: `Time spend updated for lecture`
            })
        }
        const date = new Date(moment().add(5, "hours").add(30, "minutes"));
        const newTimeSpend = new timeSpendOnLecture({
            user: studentDetails._id,
            lecture: isLecture._id,
            timeSpend: timeSpend ?? "0",
            createdAt: formatDate(date),
        })
        const saveTimeSpend = await newTimeSpend.save();
        return res.json({
            status: true,
            data: saveTimeSpend.timeSpend,
            msg: `Time spend created for lecture`
        })
    } catch (error) {
        return res.json({
            status: false,
            data: null,
            msg: error.message || 'time Spend not created'
        })
    }

})


// getAll for Admin
AdminPanel.get("/getTimeSpendDetails", isAdmin, async (req, res) => {
    try {
        const decoded = jwt.verify(req.token, process.env.ADMIN_SECRET_KEY);
        const adminDetails = await findAdminTeacherUsingUserId(decoded.studentId);
        if (!adminDetails) {
            return res.status(401).json({
                status: false,
                data: null,
                msg: "Not an admin",
            });
        }
        const timeSpends = await timeSpendOnLecture.find({});
        return res.json({
            status: true,
            data: timeSpends,
            msg: `All time spends fetched successfully`
        })

    } catch (error) {
        return res.json({
            status: false,
            data: null,
            msg: error.message || 'Time spends not fetched'
        })
    }

})
// gettimeSpend by lectureId
AdminPanel.get("/getTimeSpendByLecture/:id", isAdmin, async (req, res) => {
    const { id } = req.params;
    if (!id) {
        return res.json({
            status: false,
            data: null,
            msg: `Lecture Id not Found`
        })
    }
    try {
        const timeSpends = await timeSpendOnLecture.find({ lecture: id }).populate("user", "_id FullName");
        return res.json({
            status: true,
            data: timeSpends.map((item) => {
                return {
                    userId: item?.user?._id ?? "",
                    userName: item?.user?.FullName ?? "",
                    timeSpends: item?.timeSpend ?? ""
                }

            }),
            msg: 'lecture analytic found'
        })

    } catch (error) {
        return res.json({
            status: false,
            data: null,
            msg: error.message || 'Lecture analytics not fetched'
        })
    }
})

AdminPanel.get("/getAllCTA", isAdmin, async (req, res) => {
    try {
        const decoded = jwt.verify(req.token, process.env.ADMIN_SECRET_KEY);
        const adminDetails = await findAdminTeacherUsingUserId(decoded.studentId);
        if (!adminDetails) {
            return res.status(401).json({
                status: false,
                data: null,
                msg: "Not an admin",
            });
        }
        const CTAs = await ctaTable.find({}).populate('category', "_id title ").sort({ createdAt: -1 });
        return res.json({
            status: true,
            data: CTAs.map((item) => {
                return {
                    id: item._id ?? "",
                    email: item?.email ?? "",
                    msg: item?.msg ?? "",
                    fullName: item?.fullName ?? "",
                    categoryDetails: { id: item?.category?._id ?? "", title: item?.category?.title ?? "" },
                    phoneNumber: item.phoneNumber ?? "",
                    utmCampaign: item?.utm_campaign ?? "",
                    utmSource: item?.utm_source ?? "",
                    utmMedium: item?.utm_medium ?? "",
                    createdAt: `${moment(item.createdAt).add(5, "hours").add(30, "minutes").format("DD-MM-YYYY HH:mm:ss")}` ?? "",
                    updatedAt: `${moment(item.updatedAt).add(5, "hours").add(30, "minutes").format("DD-MM-YYYY HH:mm:ss")}` ?? "",
                }
            }),
            msg: `CTAs fetched`
        })
    } catch (error) {
        return res.json({
            status: false,
            data: null,
            msg: error.message || 'CTAs is not fetched'
        })

    }

})
AdminPanel.delete("/deleteCTA/:id", isAdmin, async (req, res) => {
    const { id } = req.params;
    if (!id) {
        return res.json({
            status: false,
            data: null,
            msg: 'Required Id!'
        })
    }
    try {
        const decoded = jwt.verify(req.token, process.env.ADMIN_SECRET_KEY);
        const adminDetails = await findAdminTeacherUsingUserId(decoded.studentId);
        if (!adminDetails) {
            return res.status(401).json({
                status: false,
                data: null,
                msg: "Not an admin",
            });
        }
        const CTA = await ctaTable.findOne({ _id: id });
        if (!CTA) {
            return res.json({
                status: false,
                data: null,
                msg: 'CTA not found',
            })
        }

        const result = await ctaTable.findByIdAndDelete({ _id: id });
        await savePanelEventLogs(
            adminDetails?._id,
            "deleteCTA",
            "delete",
            CTA
        )
        return res.json({
            status: true,
            data: null,
            msg: `CTA deleted`
        })
    } catch (error) {
        return res.json({
            status: false,
            data: null,
            msg: error.message || 'CTAs is not Deleted'
        })

    }

})
AdminPanel.get("/getMyBatchById/:id", ValidateToken, async (req, res) => {
    const { id } = req.params;
    if (!id) {
        return res.json({
            status: false,
            data: null,
            msg: 'Required Id!'
        })
    }
    try {
        const decoded = jwt.verify(req.token, process.env.SECRET_KEY);
        const studentDetails = await findUserByUserId(decoded.studentId);
        // console.log(studentDetails)
        if (studentDetails) {
            const findMyBatchDetails = await MybatchTable.findOne({
                batch_id: id,
            });

            if (findMyBatchDetails) {
                let UserMyBatchDetails = [];
                // console.log(findMyBatchDetails[i])
                const diffdays = getDateDifference(
                    findMyBatchDetails.created_at
                );
                let findBatch = await BatchesTable.findOne(
                    {
                        _id: findMyBatchDetails.batch_id,
                        is_active: true,
                    },
                    {
                        created_at: 0,
                        student: 0,
                        charges: 0,
                        discount: 0,
                        __v: 0,
                    }
                ).populate("subject")
                    .populate({
                        path: 'teacher', select: '_id FullName profilePhoto qualification demoVideo',
                        populate: {
                            path: 'subject'
                            // , select : 'title'
                        }
                    })

                // .populate("teacher", {
                //     FullName: 1,
                //     profilePhoto: 1,
                //     _id: 1,
                // })
                // .populate("subject", { title: 1 });
                const LectureDetails = await LectureTable.find(
                    {
                        batch: findBatch._id,
                    },
                    {
                        student: 0,
                        batch: 0,
                        user_admin: 0,
                        __v: 0,
                        created_at: 0,
                    }
                )
                    .populate("subject")
                    .populate({
                        path: 'teacher', select: '_id FullName profilePhoto qualification demoVideo',
                        populate: {
                            path: 'subject'
                            // , select : 'title'
                        }
                    }).populate('batch', '_id batch_name slug')
                // .populate("teacher", {
                //     FullName: 1,
                //     profilePhoto: 1,
                //     _id: 1,
                // }); //.populate('teacher',{FullName:1,profilePhoto:1});
                let helperObj = {
                    MyBatch_id: findMyBatchDetails._id,
                    // created_at: findMyBatchDetails.created_at,
                    // Amount: findMyBatchDetails.amount,
                    // is_paid: findMyBatchDetails.is_paid,
                    is_active: findMyBatchDetails.is_active,
                    lectureDetails: await Promise.all(LectureDetails?.map(async (lecture) => {
                        // const rooms = await lectureRoomTable.find({ lecture : item?._id , user :  user?._id }).populate('batch' , 'batch_name').populate('mentor' , '_id FullName');
                        const userRoom = await lectureRoomTable.findOne({ lecture: lecture?._id, students: { $in: studentDetails?._id } }).populate('batch', 'batch_name').populate("mentor", "_id FullName").select('_id title mentor');

                        // let rooms = await lectureRoomTable.find({ lecture: lecture?._id }).select('students title _id');
                        return {
                            ...lecture?._doc, teacher: lecture?.teacher[0],
                            // teacher: {id : lecture?.teacher[0]?._id ,
                            //     demoVideo : lecture?.teacher[0]?.demoVideo ?? "" ,  
                            //     name: lecture?.teacher[0]?.FullName ?? "",
                            //      profilePhoto: lecture?.teacher[0]?.profilePhoto ?? "" , 
                            //      qualification :  lecture?.teacher[0]?.qualification ?? "",
                            //      subject : lecture?.teacher[0]?.subject?.map((item2) => { return item2?.title}) ?? [],
                            //     } ?? { name: "", profilePhoto: ""  , qualification : "" , demoVideos: "" , subject : []},
                            banner: lecture?.banner ?? "https://static.sdcampus.com/assets/lecture_default_1732539568.jpg",
                            socketUrl: lecture?.socketUrl ?? "https://twoway-backend-prod.sdcampus.com/mediasoup",
                            roomDetails: { id: userRoom?._id ?? "", title: userRoom?.title ?? "", batchName: userRoom?.batch?.batch_name ?? "", mentor: userRoom?.mentor?.map((item2) => { return { mentorId: item2?._id ?? "", mentorName: item2?.FullName ?? "" } }) } ?? []
                        }
                    })),
                    // lectureDetails: LectureDetails?.map((item) => { return { ...item?._doc  , banner : item?.banner ?? "https://static.sdcampus.com/assets/lecture_default_1732539568.jpg" }}),
                    batchDetails: findBatch,
                };
                // UserMyBatchDetails = UserMyBatchDetails.reduce((a, v) => ({ ...a, [v]: v }), {})
                const isPurchase = await MybatchTable.findOne({ user: studentDetails._id, batch_id: findMyBatchDetails.batch_id });
                res.json({
                    status: true,
                    data: helperObj,
                    msg: "fetched the MyBatch details",
                    isPurchase: isPurchase ? true : false
                });
            } else {
                res.json({
                    status: false,
                    data: null,
                    msg: "No Data Found",
                    isPurchase: false
                });
            }
        } else {
            return res.json({
                status: false,
                data: null,
                msg: "User not found",
                isPurchase: false,
            });
        }
    } catch (err) {
        res.status(401).json({
            status: false,
            data: null,
            msg: err.message,
            isPurchase: false,
        });
    }
})

AdminPanel.get("/getTestSeriesById/:id", ValidateToken, async (req, res) => {
    const { id } = req.params;
    if (!id) {
        return res.json({
            status: false,
            data: null,
            msg: 'Required Id!'
        })
    }
    try {
        const decoded = jwt.verify(req.token, process.env.SECRET_KEY);
        const studentDetails = await findUserByUserId(decoded.studentId);

        if (studentDetails) {
            const myTestSeriesDetails = await MyTestSeriesTable.find({
                user: studentDetails._id,
                _id: id,
                user: studentDetails._id,
                is_paid: true,
                is_active: true,
            }).populate({
                path: "testseries_id",
                match: { no_of_test: { $gt: 0 } }, // Include documents where no_of_test > 0
            });
            const helperArray = [];
            await Promise.all(
                myTestSeriesDetails.map(async (myTestSeriesDetail) => {
                    if (myTestSeriesDetail.testseries_id) {
                        const tests = await TestSeriesTestTable.find({
                            TestSeries: myTestSeriesDetail.testseries_id,
                        });

                        const [attemptedOffline, attemptedOnline] = await Promise.all([
                            MyAttemptedTestTable.aggregate([
                                {
                                    $match: {
                                        user: studentDetails._id,
                                        test_id: { $in: tests.map((test) => test._id) },
                                    },
                                },
                                {
                                    $group: {
                                        _id: "$test_id",
                                        firstDocument: { $first: "$$ROOT" },
                                    },
                                },
                                { $replaceRoot: { newRoot: "$firstDocument" } },
                            ]),
                            QuizResponseTable.aggregate([
                                {
                                    $match: {
                                        user_id: studentDetails._id,
                                        quizId: { $in: tests.map((test) => test._id) },
                                    },
                                },
                                {
                                    $group: { _id: "$quizId", firstDocument: { $first: "$$ROOT" } },
                                },
                                { $replaceRoot: { newRoot: "$firstDocument" } },
                            ]),
                        ]);

                        const attemptedTestIds = [
                            ...attemptedOffline,
                            ...attemptedOnline,
                        ].map((item) => item._id);
                        // console.log(attemptedTestIds.length)
                        const percentage = attemptedTestIds.length / tests.length;
                        const helperObj = {
                            ...myTestSeriesDetail.toObject(),
                            progress: {
                                percentage: tests.length !== 0 ? percentage.toString() : "0",
                                value: `${attemptedTestIds.length}/${tests.length}`,
                            },
                        };

                        helperArray.push(helperObj);
                    }
                })
            );

            return res.json({
                status: true,
                data: helperArray[0],
                msg: 'TestSeries found'
            })
        } else {
            return res.json({
                status: false,
                data: null,
                msg: "User not found",
            });
        }
    } catch (err) {
        res.status(401).json({
            status: false,
            data: null,
            msg: err.message,
        });
    }
})

AdminPanel.get("/getTestById/:id", ValidateToken, async (req, res) => {
    const { id } = req.params;
    if (!id) {
        return res.json({
            status: false,
            data: null,
            msg: 'Required Id'
        })
    }
    try {
        const decoded = jwt.verify(req.token, process.env.SECRET_KEY);
        const studentDetails = await findUserByUserId(decoded.studentId);

        if (studentDetails) {
            const test = await TestSeriesTestTable.findOne({ _id: id });
            let helperObj = test.toObject();
            const MyAttemptedTest = await MyAttemptedTestTable.findOne({
                user: studentDetails._id,
                // testSeries_id: TestSeries_id,
                test_id: test._id
            });
            if (MyAttemptedTest) {
                const emptyObj = {
                    fileLoc: "",
                    fileName: "",
                    fileSize: "",
                };
                let obj = {
                    Score: MyAttemptedTest[i].Score,
                    answer_sheet: MyAttemptedTest[i].answer_sheet,
                    checked_answer_sheet: MyAttemptedTest[i].checked_answer_sheet
                        ? MyAttemptedTest[i].checked_answer_sheet
                        : emptyObj,
                    is_livetest: false,
                };
                helper.attempted = obj;
                helperObj.is_attempted = true;

            } else {
                helperObj.attempted = {
                    answer_sheet: {
                        fileLoc: "",
                        fileName: "",
                        fileSize: "",
                    },
                    checked_answer_sheet: {
                        fileLoc: "",
                        fileName: "",
                        fileSize: "",
                    },
                    Score: "NA",
                    is_livetest: false,
                };
                helperObj.is_attempted = false;

            }
            return res.json({
                status: true,
                data: helperObj,
                msg: "Test details found"
            })
        } else {
            return res.json({
                status: false,
                data: null,
                msg: "User not found",
            });
        }
    } catch (err) {
        res.status(401).json({
            status: false,
            data: null,
            msg: err.message,
        });
    }
})

AdminPanel.get("/getVideoById/:id", ValidateToken, async (req, res) => {
    const { id } = req.params;
    if (!id) {
        return res.json({
            status: false,
            data: null,
            msg: 'Required Id!'
        })
    }
    try {
        const decoded = jwt.verify(req.token, process.env.SECRET_KEY);
        const studentDetails = await findUserByUserId(decoded.studentId);

        if (studentDetails) {
            const video = await YouTube_Url.findOne({ _id: id });
            return res.json({
                status: true,
                data: video,
                msg: "Video details found"
            })
        } else {
            return res.json({
                status: false,
                data: null,
                msg: "User not found",
            });
        }
    } catch (err) {
        res.status(401).json({
            status: false,
            data: null,
            msg: err.message,
        });
    }
})

AdminPanel.get("/getQuizById/:id", ValidateToken, async (req, res) => {
    const { id } = req.params;
    if (!id) {
        return res.json({
            status: false,
            data: null,
            msg: 'Required Id!'
        })
    }
    try {
        const decoded = jwt.verify(req.token, process.env.SECRET_KEY);
        const studentDetails = await findUserByUserId(decoded.studentId);

        if (studentDetails) {
            const quiz = await QuizTable.findOne({ _id: id });
            return res.json({
                status: true,
                data: {
                    id: quiz._id,
                    quiz_title: quiz.quiz_title,
                    quiz_desc: quiz.quiz_desc,
                    quiz_duration: quiz.quiz_duration,
                    no_ques: quiz.no_ques.toString(),
                    quiz_banner: quiz.quiz_banner[0],
                    language: quiz.language,
                    is_negative: quiz.is_negative,
                    negativeMarks: quiz.negativeMarks,
                    eachQueMarks: quiz.eachQueMarks,
                    shareLink: "",
                    shareUrl: { link: quiz?.shareLink?.link ?? "", text: quiz?.shareLink?.text ?? "" },
                    quiz_created_at: quiz.created_at,
                },
                msg: "Quiz details found"
            })
        } else {
            return res.json({
                status: false,
                data: null,
                msg: "User not found",
            });
        }
    } catch (err) {
        res.status(401).json({
            status: false,
            data: null,
            msg: err.message,
        });
    }
})

AdminPanel.get("/getLectureById/:id", ValidateToken, async (req, res) => {
    const { id } = req.params;
    if (!id) {
        return res.json({
            status: false,
            data: null,
            msg: 'Required Lecture Id!'
        })
    }
    try {
        const decoded = jwt.verify(req.token, process.env.SECRET_KEY);
        const studentDetails = await findUserByUserId(decoded.studentId);
        if (studentDetails) {
            const lecture = await LectureTable.findOne({ _id: id }).populate("subject").populate(
                {
                    path: "teacher",
                    select: '_id FullName qualification demoVideo profilePhoto',
                    populate: {
                        path: 'subject',
                        // select : 'title'
                    }

                }).populate('batch', '_id batch_name slug').populate('subject');
            let isMyBatch = await MybatchTable.findOne({ batch_id: lecture?.batch, user: studentDetails?._id });
            if (!isMyBatch) {
                return res.json({
                    status: false,
                    data: null,
                    msg: 'Not Authorized'
                })
            }
            const userRoom = await lectureRoomTable.findOne({ lecture: lecture?._id, students: { $in: studentDetails?._id } }).populate('batch', 'batch_name').populate("mentor", "_id FullName").select('_id title mentor');

            // let rooms = await lectureRoomTable.find({ lecture: lecture?._id }).select('students title _id');
            let response = {
                ...lecture?._doc, teacher: lecture?.teacher[0],
                batch: lecture?._doc?.batch?._id ?? "",
                batchDetails: { id: lecture?._doc?.batch?._id, batchName: lecture?._doc?.batch?.batch_name, slug: lecture?._doc?.batch?.slug } ?? { id: "", batchName: "", slug: "" },
                commonName: lecture?._doc?.commonName ?? "",
                isCommentAllowed: lecture?._doc?.isCommentAllowed ?? false,
                // teacher: {id : lecture?.teacher[0]?._id ,
                //     demoVideo : lecture?.teacher[0]?.demoVideo ?? "" ,  
                //     name: lecture?.teacher[0]?.FullName ?? "",
                //      profilePhoto: lecture?.teacher[0]?.profilePhoto ?? "" , 
                //      qualification :  lecture?.teacher[0]?.qualification ?? "",
                //      subject : lecture?.teacher[0]?.subject?.map((item2) => { return item2?.title}) ?? [],
                //     } ?? { name: "", profilePhoto: ""  , qualification : "" , demoVideos: "" , subject : []},
                banner: lecture?.banner ?? "https://static.sdcampus.com/assets/lecture_default_1732539568.jpg",
                socketUrl: lecture?.socketUrl ?? "https://twoway-backend-prod.sdcampus.com/mediasoup",
                roomDetails: { id: userRoom?._id ?? "", title: userRoom?.title ?? "", batchName: userRoom?.batch?.batch_name ?? "", mentor: userRoom?.mentor?.map((item2) => { return { mentorId: item2?._id ?? "", mentorName: item2?.FullName ?? "" } }) } ?? {}
            }
            if (!lecture) {
                return res.json({
                    status: false,
                    data: null,
                    msg: "Lecture Not Found"
                })
            }
            return res.json({
                status: true,
                // data: lecture,
                data: response,
                msg: "Lecture details"
            })

        } else {
            return res.json({
                status: false,
                data: null,
                msg: "User not found",
            });
        }
    } catch (err) {
        res.status(401).json({
            status: false,
            data: null,
            msg: err.message,
        });
    }
})

AdminPanel.put("/changeLive", async (req, res) => {
    try {
        // const decoded = jwt.verify(req.token, process.env.ADMIN_SECRET_KEY);
        // const adminDetails = await findAdminTeacherUsingUserId(decoded.studentId);
        // if (!adminDetails) {
        //   return res.json({
        //     status: false,
        //     data: null,
        //     msg: "Not an admin",
        //   });
        // }
        const currentDate = moment().subtract(1, "day").set({ hour: 23, minute: 59, second: 59, millisecond: 0 }).format('YYYY-MM-DDTHH:mm:ssZ');
        console.log(currentDate)
        // const newOne = await LectureTable.updateMany({ lecture_type: "YT", LiveOrRecorded: "Live", ending_date: { $lte: currentDate } }, { $set: { LiveOrRecorded: 'Recorded' } });
        const newOne = await LectureTable.find({ endingDate: { $lt: currentDate }, lecture_type: "YT", LiveOrRecorded: "Live" });

        // let list= [];
        let count = 0;
        await Promise.all(newOne.map(async (item) => {
            // await LectureTable.findByIdAndUpdate(item._id, { LiveOrRecorded: "Recorded" });

            // const date = moment(item.ending_date, "DD-MM-YYYY HH:mm:ss").format('YYYY-MM-DDTHH:mm:ssZ')
            // if (moment(date, 'YYYY-MM-DDTHH:mm:ssZ') < moment(currentDate, 'YYYY-MM-DDTHH:mm:ssZ')) {
            //     // count++;
            //     // let item1 = await LectureTable.findOne({_id : item._id} , { LiveOrRecorded : "Live"})
            //     // list.push(item1);
            //     //  console.log(item._id, item.starting_date, item.ending_date)
            //     await LectureTable.findByIdAndUpdate(item._id, { LiveOrRecorded: "Recorded" });
            // }
        }))
        return res.json({
            status: true,
            data: newOne.length,
            length: count,
            msg: `Youtube live lecture changes into recorded .`
        })
    } catch (error) {
        return res.json({
            status: false,
            data: null,
            msg: error.message

        })
    }
})

// shlorship test
AdminPanel.post("/createScholarshipTest", upload.single("file"), isAdmin, async (req, res) => {
    const { quizId, title, description, startingAt, duration, resultDeclaration, registrationEndAt, isActive } = req.body
    try {
        const decoded = jwt.verify(req.token, process.env.ADMIN_SECRET_KEY);
        const adminDetails = await findAdminTeacherUsingUserId(decoded.studentId);
        if (!adminDetails) {
            return res.json({
                status: false,
                data: null,
                msg: "Not an admin",
            });
        }
        let icon;
        if (req.file) {
            const helperString = Math.floor(Date.now() / 1000);
            const filename = (req.file.originalname.split(".")[0]).replace(/\s+/g, '_').replace(/[^a-zA-Z0-9_]/g, '');
            const extension = "." + req.file.originalname.split(".").pop();
            FileUploadLocation = `ScholarShipTest/${title?.replace(/\s+/g, '_').replace(/[^a-zA-Z0-9_]/g, '')}/${filename}_${helperString}${extension}`;
            let helperfileLoc = await uploadFile(req.file.path, FileUploadLocation);
            icon = helperfileLoc;
        }
        // check quizId exist or not
        const isValidQuiz = await QuizTable.findOne({ _id: quizId, is_active: true });
        if (!isValidQuiz) {
            return res.json({
                status: false,
                data: null,
                msg: `Quiz not valid`
            })
        }
        const newTest = new scholarshipTestTable({
            user: adminDetails._id,
            quizId,
            title,
            banner: icon,
            description,
            startingAt: formatDatetime(startingAt),
            duration,
            registrationEndAt: formatDatetime(registrationEndAt),
            resultDeclaration: formatDatetime(resultDeclaration),
            created_at: formatDatetime(new Date()),
            isActive

        });
        const saveTest = await newTest.save();
        return res.json({
            status: true,
            data: saveTest,
            msg: `New Scholar ship Test added`
        })
    } catch (error) {
        return res.json({
            status: false,
            data: null,
            msg: error.message
        })
    }
})

AdminPanel.put("/updateScholarshipTest/:id", upload.single("file"), isAdmin, async (req, res) => {
    const { id } = req.params;
    if (!id) {
        return res.json({
            status: false,
            data: null,
            msg: `Id required`
        })
    }
    const { quizId, title, description, startingAt, duration, resultDeclaration, registrationEndAt, isActive } = req.body
    try {
        const decoded = jwt.verify(req.token, process.env.ADMIN_SECRET_KEY);
        const adminDetails = await findAdminTeacherUsingUserId(decoded.studentId);
        if (!adminDetails) {
            return res.json({
                status: false,
                data: null,
                msg: "Not an admin",
            });
        }
        const isTest = await scholarshipTestTable.findOne({ _id: id });
        if (!isTest) {
            return res.json({
                status: false,
                data: null,
                msg: `Test not found.`

            })
        }
        let icon;
        if (req.file) {
            const helperString = Math.floor(Date.now() / 1000);
            const filename = (req.file.originalname.split(".")[0]).replace(/\s+/g, '_').replace(/[^a-zA-Z0-9_]/g, '');
            const extension = "." + req.file.originalname.split(".").pop();
            FileUploadLocation = `ScholarShipTest/${title?.replace(/\s+/g, '_').replace(/[^a-zA-Z0-9_]/g, '')}/${filename}_${helperString}${extension}`;
            let helperfileLoc = await uploadFile(req.file.path, FileUploadLocation);
            icon = helperfileLoc;
        } else {
            icon = isTest.banner
        }
        // check quizId exist or not
        if (quizId) {
            const isValidQuiz = await QuizTable.findOne({ _id: quizId, is_active: true });
            if (!isValidQuiz) {
                return res.json({
                    status: false,
                    data: null,
                    msg: `Quiz not valid`
                })
            }
        }

        const updatedTest = await scholarshipTestTable.findByIdAndUpdate(isTest._id, {
            // user : adminDetails._id,
            quizId: quizId ? quizId : isTest.quizId,
            title: title ? title : isTest.title,
            banner: icon,
            description: description ? description : isTest.description,
            startingAt: startingAt ? formatDatetime(startingAt) : isTest.startingAt,
            duration: duration ? duration : isTest.duration,
            registrationEndAt: registrationEndAt ? formatDatetime(registrationEndAt) : isTest.registrationEndAt,
            resultDeclaration: resultDeclaration ? formatDatetime(resultDeclaration) : isTest.resultDeclaration,
            isActive: isActive
            // created_at: formatDatetime(new Date())
        }, { new: true, lean: true });
        return res.json({
            status: true,
            data: updatedTest,
            msg: `Scholar ship Test Updated`
        })
    } catch (error) {
        return res.json({
            status: false,
            data: null,
            msg: error.message
        })
    }
})

AdminPanel.get("/getScholarshipTests", isAdmin, async (req, res) => {
    // const { scholarshipTestId } = req.body;
    try {
        const decoded = jwt.verify(req.token, process.env.ADMIN_SECRET_KEY);
        const adminDetails = await findAdminTeacherUsingUserId(decoded.studentId);
        if (!adminDetails) {
            return res.json({
                status: false,
                data: null,
                msg: "Not an admin",
            });
        }
        const tests = await scholarshipTestTable.find({}).populate('quizId');
        return res.json({
            status: true,
            data: tests.map((test) => {
                return {
                    _id: test._id,
                    id: test._id,
                    label: test.title ?? "",
                    value: test._id ?? "",
                    title: test.title ?? "",
                    banner: test.banner ?? "",
                    description: test.description ?? "",
                    startingAt: test.startingAt ?? "",// test start date
                    registrationEndAt: test.registrationEndAt ?? "", /// registration end date
                    duration: test.duration ?? "",
                    resultDeclaration: test.resultDeclaration ?? "",
                    quizId: { id: test.quizId?._id ?? "", title: test?.quizId?.quiz_title ?? "" },
                    //  isRegister : isReg ? true : false
                    isActive: test?.isActive ?? false
                }
            }),
            msg: 'Test details fetched'
        })

    } catch (error) {
        return res.json({
            status: false,
            data: null,
            msg: error.message
        })
    }
})

AdminPanel.get("/getScholarshipTest/:id", isAdmin, async (req, res) => {
    const { id } = req.params;
    if (!id) {
        return res.json({
            status: false,
            data: null,
            msg: `Id required`
        })
    }
    try {
        const decoded = jwt.verify(req.token, process.env.ADMIN_SECRET_KEY);
        const adminDetails = await findAdminTeacherUsingUserId(decoded.studentId);
        if (!adminDetails) {
            return res.json({
                status: false,
                data: null,
                msg: "Not an admin",
            });
        }
        const isTest = await scholarshipTestTable.findOne({ _id: id });
        if (!isTest) {
            return res.json({
                status: false,
                data: null,
                msg: `Test not found.`
            })
        }
        const test = await scholarshipTestTable.findOne({ _id: id }).populate('quizId');
        return res.json({
            status: true,
            data:
            {
                id: test._id,
                title: test.title ?? "",
                banner: test.banner ?? "",
                description: test.description ?? "",
                startingAt: test.startingAt ?? "",// test start date
                registrationEndAt: test.registrationEndAt ?? "", /// registration end date
                duration: test.duration ?? "",
                resultDeclaration: test.resultDeclaration ?? "",
                quizId: { id: test.quizId?._id ?? "", title: test?.quizId?.quiz_title ?? "" },
                isActive: test.isActive,
                //  isRegister : isReg ? true : false
            }
            ,
            msg: 'Test details fetched'
        })

    } catch (error) {
        return res.json({
            status: false,
            data: null,
            msg: error.message
        })
    }
})

AdminPanel.delete("/deleteScholarshipTest/:id", isAdmin, async (req, res) => {
    const { id } = req.params;
    if (!id) {
        return res.json({
            status: false,
            data: null,
            msg: `Id required`
        })
    }
    try {
        const decoded = jwt.verify(req.token, process.env.ADMIN_SECRET_KEY);
        const adminDetails = await findAdminTeacherUsingUserId(decoded.studentId);
        if (!adminDetails) {
            return res.json({
                status: false,
                data: null,
                msg: "Not an admin",
            });
        }
        const isTest = await scholarshipTestTable.findOne({ _id: id });
        if (!isTest) {
            return res.json({
                status: false,
                data: null,
                msg: `Test not found.`
            })
        }
        const deletedTest = await scholarshipTestTable.findByIdAndDelete(isTest._id)
        await savePanelEventLogs(
            adminDetails?._id,
            "deleteScholorshipTest",
            "delete",
            isTest
        )
        return res.json({
            status: true,
            data: {},
            msg: `${deletedTest.title} Scholar ship Test deleted`
        })
    } catch (error) {
        return res.json({
            status: false,
            data: null,
            msg: error.message
        })
    }
})

AdminPanel.post("/registerationForScholarTest", ValidateToken, async (req, res) => {
    const { scholarshipTestId } = req.body;
    try {
        const decoded = jwt.verify(req.token, process.env.SECRET_KEY);
        const studentDetails = await findUserByUserId(decoded.studentId);
        if (!studentDetails) {
            return res.json({
                status: false,
                data: null,
                msg: `not an user`
            })
        }
        const newReg = new scholarshipRegTable({
            user: studentDetails._id,
            scholarshipTestId,
            registrateredAt: formatDatetime(new Date())
        })
        const saveReg = await newReg.save();
        return res.json({
            status: true,
            data: saveReg,
            msg: `Succesfully Registered for test`
        })
    } catch (error) {
        return res.json({
            status: false,
            data: null,
            msg: error.message
        })
    }
})
// all Test
AdminPanel.get("/getAllScholarshipTest", ValidateToken, async (req, res) => {
    try {
        const decoded = jwt.verify(req.token, process.env.SECRET_KEY);
        const studentDetails = await findUserByUserId(decoded.studentId);
        if (!studentDetails) {
            return res.json({
                status: false,
                data: null,
                msg: `not an user`
            })
        }
        // const tests = await scholarshipTestTable.find({ resultDeclaration: { $gte: formatDatetime(new Date()) } });
        const tests = await scholarshipTestTable.find({ isActive: true });
        return res.json({
            status: true,
            data: await Promise.all(tests.map(async (test) => {
                const isReg = await scholarshipRegTable.findOne({ user: studentDetails._id, scholarshipTestId: test._id })
                return {
                    id: test._id,
                    title: test.title ?? "",
                    banner: test.banner ?? "",
                    description: test.description ?? "",
                    startingAt: test.startingAt ?? "",// test start date
                    registrationEndAt: test.registrationEndAt ?? "", /// registration end date
                    duration: test.duration ?? "",
                    resultDeclaration: test.resultDeclaration ?? "",
                    quizId: test.quizId,
                    isRegister: isReg ? true : false
                }
            })),
            msg: 'Test details fetched'
        })

    } catch (error) {
        return res.json({
            status: false,
            data: null,
            msg: error.message
        })
    }
})
AdminPanel.get("/getUserScholarshipTest/:id", ValidateToken, async (req, res) => {
    const { id } = req.params;
    if (!id) {
        return res.json({
            status: false,
            data: null,
            msg: `Id required`
        })
    }
    try {
        const decoded = jwt.verify(req.token, process.env.SECRET_KEY);
        const studentDetails = await findUserByUserId(decoded.studentId);
        if (!studentDetails) {
            return res.json({
                status: false,
                data: null,
                msg: `not an user`
            })
        }
        const test = await scholarshipTestTable.findOne({ _id: id });
        if (!test) {
            return res.json({
                status: false,
                data: null,
                message: `Test not found`
            })
        }

        const isReg = await scholarshipRegTable.findOne({ user: studentDetails._id, scholarshipTestId: test._id })
        return res.json({
            status: true,
            data: {
                id: test._id,
                title: test.title ?? "",
                banner: test.banner ?? "",
                quizId: test.quizId,
                description: test.description ?? "",
                startingAt: test.startingAt ?? "",
                duration: test.duration ?? "",
                shareUrl: { link: test?.shareLink?.link ?? "", text: test?.shareLink?.text ?? "" },
                shareLink: "",
                registrationEndAt: test.registrationEndAt ?? "",
                resultDeclaration: test.resultDeclaration ?? "",

                isRegister: isReg ? true : false,
                isRegisterationClose: moment(new Date()).isAfter(moment(test.registrationEndAt, 'DD-MM-YYYY HH:mm:ss')) ?? false,
                startingAtFormat: moment(test.startingAt, 'DD-MM-YYYY HH:mm:ss').format('Do MMMM h:mm A') ?? "",
                registrationEndAtFormat: moment(test.registrationEndAt, 'DD-MM-YYYY HH:mm:ss').format("DD-MM-YYYY HH:mm A") ?? "",
                resultDeclarationFormat: moment(test.resultDeclaration, 'DD-MM-YYYY HH:mm:ss').format('D MMM | h:mm A') ?? "",
            },
            msg: 'Test details fetched'
        })

    } catch (error) {
        return res.json({
            status: false,
            data: null,
            msg: error.message
        })
    }
})


AdminPanel.get("/getAllUsersScholarshipTest/:id", isAdmin, async (req, res) => {
    const { id } = req.params;
    if (!id) {
        return res.json({
            status: false,
            data: null,
            msg: `Id required`
        })
    }
    try {
        const decoded = jwt.verify(req.token, process.env.ADMIN_SECRET_KEY);
        const adminDetails = await findAdminTeacherUsingUserId(decoded.studentId);
        if (!adminDetails) {
            return res.json({
                status: false,
                data: null,
                msg: "Not an admin",
            });
        }
        const isTest = await scholarshipTestTable.findOne({ _id: id });
        if (!isTest) {
            return res.json({
                status: false,
                data: null,
                msg: `Test not found.`
            })
        }
        const users = await scholarshipRegTable.find({ scholarshipTestId: isTest._id }).populate("user", "_id email FullName mobileNumber");
        return res.json({
            status: true,
            data: users.map((item, index) => {
                return {
                    sN: index + 1,
                    id: item._id,
                    name: item?.user?.FullName ?? "",
                    email: item?.user?.email ?? "",
                    phone: item?.user?.mobileNumber ?? "",
                    registrateredAt: item?.registrateredAt ?? "",
                }
            }),
            msg: `All User fetched for Scholar ship Test`
        })
    } catch (error) {
        return res.json({
            status: false,
            data: null,
            msg: error.message
        })
    }
})
// announcements
AdminPanel.post("/createAnnouncement", isAdmin, async (req, res) => {
    const { title, description, link, linkWith, isActive } = req.body;
    try {
        const decoded = jwt.verify(req.token, process.env.ADMIN_SECRET_KEY);
        const adminDetails = await findAdminTeacherUsingUserId(decoded.studentId);
        if (!adminDetails) {
            return res.json({
                status: false,
                data: null,
                msg: "Not an admin",
            });
        }
        let isBatch;
        if (link == 'batch') {
            isBatch = await BatchesTable.findOne({ _id: linkWith }).populate('features', '_id feature');
            if (!isBatch) {
                return res.json({
                    status: false,
                    data: null,
                    msg: 'Provide correct batch'
                })
            }
            if (!isBatch?.features?.find((item) => item?.feature == 'announcement')) {
                return res.json({
                    status: false,
                    data: null,
                    msg: 'This feature not allowed on batch.'
                })
            }

        }
        let isTestSeries;
        if (link == 'testSeries') {
            isTestSeries = await TestSeriesTable.findOne({ _id: linkWith });
            if (!isTestSeries) {
                return res.json({
                    status: false,
                    data: null,
                    msg: 'Provide correct testSeries'
                })
            }
        }

        const newAnnouncement = new announcementTable({
            admin: adminDetails._id,
            title,
            description,
            link,
            linkWith,
            isActive

        })
        const saveAnnouncement = await newAnnouncement.save();
        if (isActive) {
            if (link == 'batch') {
                const data = {
                    title: `${isBatch?.batch_name} Announcement.!!` ?? "",
                    message: description,
                    fileUrl: "",
                    route: "announceBatchbyid",
                    rootId: `${isBatch?._id}`,
                    childId: ""
                };
                await sendCustomNotification(isBatch?.student, data);
            } else if (link == 'testSeries') {
                const data = {
                    title: title ?? "",
                    message: `${isTestSeries?.testseries_name} : ${description}`,
                    fileUrl: "",
                    route: "announceTestSeriesbyid",
                    rootId: `${isTestSeries?._id}`,
                    childId: ""
                };
                await sendCustomNotification(isTestSeries?.student, data);
            }
        }

        return res.json({
            status: true,
            data: saveAnnouncement,
            msg: 'New Announcement created successfully'
        })


    } catch (error) {
        return res.json({
            status: false,
            data: null,
            msg: error.message
        })
    }
})

AdminPanel.post("/createAnnouncementForBatches", isAdmin, async (req, res) => {
    const { title, description, link, batches, isActive } = req.body;
    try {
        const decoded = jwt.verify(req.token, process.env.ADMIN_SECRET_KEY);
        const adminDetails = await findAdminTeacherUsingUserId(decoded.studentId);
        if (!adminDetails) {
            return res.json({
                status: false,
                data: null,
                msg: "Not an admin",
            });
        }
        for (let batch of batches) {
            const isBatch = await BatchesTable.findOne({ _id: batch }).populate('features', '_id feature');
            if (!isBatch) {
                return res.json({
                    status: false,
                    data: null,
                    msg: 'Provide correct batch'
                })
            }
            if (!isBatch?.features?.find((item) => item?.feature == 'announcement')) {
                return res.json({
                    status: false,
                    data: null,
                    msg: 'This feature not allowed on this batch'
                })
            }


            const newAnnouncement = new announcementTable({
                admin: adminDetails._id,
                title,
                description,
                link,
                linkWith: isBatch._id,
                isActive

            })

            await newAnnouncement.save();
            if (isActive) {
                const data = {
                    title: `${isBatch?.batch_name} Announcement.!!` ?? "",
                    message: `${description}`,
                    fileUrl: isBatch?.banner[0].fileLoc,
                    route: "announceBatchbyid",
                    rootId: `${isBatch?._id}`,
                    childId: ""
                };
                await sendCustomNotification(isBatch?.student, data);
            }
        }


        return res.json({
            status: true,
            data: [],
            msg: 'New Announcement created successfully for batches'
        })


    } catch (error) {
        return res.json({
            status: false,
            data: null,
            msg: error.message
        })
    }
})

AdminPanel.put("/updateAnnouncement/:id", isAdmin, async (req, res) => {
    const { id } = req.params;
    if (!id) {
        return res.json({
            status: false,
            data: null,
            msg: `Id required`
        })
    }
    const { title, description, link, linkWith, isActive } = req.body;
    try {
        const decoded = jwt.verify(req.token, process.env.ADMIN_SECRET_KEY);
        const adminDetails = await findAdminTeacherUsingUserId(decoded.studentId);
        if (!adminDetails) {
            return res.json({
                status: false,
                data: null,
                msg: "Not an admin",
            });
        }
        const isExist = await announcementTable.findOne({ _id: id });
        if (!isExist) {
            return res.json({
                status: false,
                data: null,
                msg: 'Announcement not exists'
            })
        }
        if (link == 'batch') {
            const isBatch = await BatchesTable.findOne({ _id: linkWith });
            if (!isBatch) {
                return res.json({
                    status: false,
                    data: null,
                    msg: 'Provide correct batch'
                })
            }

        }
        if (link == 'testSeries') {
            const isTestSeries = await TestSeriesTable.findOne({ _id: linkWith });
            if (!isTestSeries) {
                return res.json({
                    status: false,
                    data: null,
                    msg: 'Provide correct testSeries'
                })
            }
        }

        const updatedAnnouncement = await announcementTable.findByIdAndUpdate(isExist._id, {
            admin: adminDetails._id,
            title,
            description,
            link,
            linkWith,
            isActive

        }, { new: true, lean: true })
        return res.json({
            status: true,
            data: {},
            msg: `${updatedAnnouncement.title} Announcement updated successfully`
        })


    } catch (error) {
        return res.json({
            status: false,
            data: null,
            msg: error.message
        })
    }
})
AdminPanel.delete("/deleteAnnouncement/:id", isAdmin, async (req, res) => {
    const { id } = req.params;
    if (!id) {
        return res.json({
            status: false,
            data: null,
            msg: `Id required`
        })
    }

    try {
        const decoded = jwt.verify(req.token, process.env.ADMIN_SECRET_KEY);
        const adminDetails = await findAdminTeacherUsingUserId(decoded.studentId);
        if (!adminDetails) {
            return res.json({
                status: false,
                data: null,
                msg: "Not an admin",
            });
        }
        const isExist = await announcementTable.findOne({ _id: id });
        if (!isExist) {
            return res.json({
                status: false,
                data: null,
                msg: 'Announcement not exists'
            })
        }
        const delectedAnnouncement = await announcementTable.findByIdAndDelete(isExist._id);
        await savePanelEventLogs(
            adminDetails?._id,
            "deleteAnnouncement",
            "delete",
            isExist
        )
        return res.json({
            status: true,
            data: {},
            msg: `${delectedAnnouncement.title} Announcement deleted successfully`
        })
    } catch (error) {
        return res.json({
            status: false,
            data: null,
            msg: error.message
        })
    }
})
AdminPanel.get("/getAllAnnouncement", isAdmin, async (req, res) => {
    try {
        const decoded = jwt.verify(req.token, process.env.ADMIN_SECRET_KEY);
        const adminDetails = await findAdminTeacherUsingUserId(decoded.studentId);
        if (!adminDetails) {
            return res.json({
                status: false,
                data: null,
                msg: "Not an admin",
            });
        }

        const announcements = await announcementTable.find({}).populate("admin", "FullName Role");
        const response = await Promise.all(announcements.map(async (item) => {
            let linkWith = {};
            let link = "";
            if (item.link == 'batch') {
                const batch = await BatchesTable.findOne({ _id: item?.linkWith });
                if (!batch) {
                    linkWith = { id: "NA", title: "NA" }
                }
                link = "Batch"
                linkWith = { id: batch?._id, title: batch?.batch_name }

            } else if (item.link == 'testSeries') {
                const testSeries = await TestSeriesTable.findOne({ _id: item?.linkWith });
                if (!testSeries) {
                    linkWith = { id: "NA", title: "NA" }
                }
                link = "Test Series"
                linkWith = { id: testSeries?._id, title: testSeries?.testseries_name }

            } else {
                link = "None"
                linkWith = { id: "NA", title: "NA" }
            }

            return {
                id: item?._id ?? "",
                title: item?.title ?? "",
                link,
                admin: item?.admin ?? "",
                linkWith,
                isActive: item?.isActive,
                createdAt: formatDatetime(item?.createdAt),
            }
        }))
        return res.json({
            status: true,
            data: response ?? [],
            msg: `All Announcements fetched successfully`
        })
    } catch (error) {
        return res.json({
            status: false,
            data: null,
            msg: error.message
        })
    }
})
AdminPanel.get("/getAnnouncementById/:id", isAdmin, async (req, res) => {
    const { id } = req.params;
    if (!id) {
        return res.json({
            status: false,
            data: null,
            msg: `Id required`
        })
    }

    try {
        const decoded = jwt.verify(req.token, process.env.ADMIN_SECRET_KEY);
        const adminDetails = await findAdminTeacherUsingUserId(decoded.studentId);
        if (!adminDetails) {
            return res.json({
                status: false,
                data: null,
                msg: "Not an admin",
            });
        }
        const isExist = await announcementTable.findOne({ _id: id });
        if (!isExist) {
            return res.json({
                status: false,
                data: null,
                msg: 'Announcement not exists'
            })
        }
        const announcement = await announcementTable.findById(isExist._id);
        return res.json({
            status: true,
            data: announcement,
            msg: `${announcement.title} Announcement fetched successfully`
        })
    } catch (error) {
        return res.json({
            status: false,
            data: null,
            msg: error.message
        })
    }
})
AdminPanel.get("/getAnnouncementByLinkWith/:id", ValidateToken, async (req, res) => {
    const { id } = req.params;
    if (!id) {
        return res.json({
            status: false,
            data: null,
            msg: `Id required`
        })
    }
    // const isMyBatch = await MybatchTable.findOne({ user: req.userId, batch_id: id });
    //     if (!isMyBatch) {
    //       return res.json({
    //         status: false,
    //         data: null,
    //         msg: "not authorized to access"
    //       })
    //     }

    try {
        const decoded = jwt.verify(req.token, process.env.SECRET_KEY);
        const studentDetails = await findUserByUserId(decoded.studentId);
        if (!studentDetails) {
            return res.json({
                status: false,
                data: null,
                msg: "Not an user",
            });
        }
        const announcements = await announcementTable.find({ linkWith: id, isActive: true }).sort({ _id: -1 }).limit(5);
        // moment(createdAt).fromNow()
        // new Date(moment().add(5, "hours").add(30, "minutes"));
        return res.json({
            status: true,
            data: announcements.map((item) => {
                return {
                    _id: item._id ?? "",
                    admin: item.admin ?? "",
                    title: item.title ?? "",
                    description: item.description ?? "",
                    link: item.link ?? "",
                    linkWith: item.linkWith ?? "",
                    isActive: item.isActive ?? false,
                    createdAt: moment(item.createdAt).fromNow() ?? "",
                    updatedAt: moment(item.updatedAt).fromNow() ?? "",
                    __v: 0
                }
            }),
            msg: `Announcement fetched successfully`
        })
    } catch (error) {
        return res.json({
            status: false,
            data: null,
            msg: error.message
        })
    }
})

AdminPanel.get("/getTeachersSchedule", async (req, res) => {
    const { startDate, endDate } = req.query;


    try {
        let date = moment().add(1, "days").format("DD-MM-YYYY");
        // console.log("SSS", date)
        // console.log(date);
        const lectures = await LectureTable.find({}).populate("teacher", "_id FullName email").populate("batch", "_id batch_name").populate("subject", "_id title");
        // console.log(lectures);
        let scheduleLectures = lectures.filter((item, index) => {
            const startDate = moment(item.starting_date, "DD-MM-YYYY HH:mm:ss").format('DD-MM-YYYY');
            // console.log(startDate)
            // console.log("Date", date)
            if (date == startDate) {
                // console.log("item", item)
                return item
            }
        })
        // console.log("Classes", scheduleLectures)
        scheduleLectures = scheduleLectures.map((item, index) => {
            return {
                // sNo:index+1,
                startDate: item.starting_date.split(' ')[0],
                day: moment(item.starting_date, "DD-MM-YYYY HH:mm:ss").format('dddd'),
                teacherName: item?.teacher[0]?.FullName ?? "",
                teacherEmail: item?.teacher[0]?.email ?? "",
                batchName: item?.batch?.batch_name ?? "",
                startTiming: item.starting_date,
                endTiming: item.ending_date,
                lectureTopic: item.lecture_title,
            }
        });
        const groupedData = scheduleLectures.reduce((acc, lecture) => {
            const teacherName = lecture.teacherName;
            if (!acc[teacherName]) {
                acc[teacherName] = [];
            }
            acc[teacherName].push(lecture);
            return acc;
        }, {});

        // Convert the grouped data to the desired format
        // const result = Object.keys(groupedData).map(teacherName => ({ [teacherName]: groupedData[teacherName] }));
        const result = Object.keys(groupedData).map(teacherName => (groupedData[teacherName]))
        for (let i = 0; i < result.length; i++) {
            // console.log(result[i][0]['teacherEmail']);
            // console.log(result[i][0]['teacherName']);
            // console.log(result[i]);
            // await sendEmail("scheduleLectures", 'govind.s@sdempire.co.in', result[i][0]['teacherName'], result[i])
            await sendEmail("scheduleLectures", result[i][0]['teacherEmail'], result[i][0]['teacherName'], result[i])
        }
        // await sendEmail("scheduleLectures" , 'abhishek05kv@gmail.com' , "Abhishek" , result[2]["Kanika Mam"])
        // console.log(result[2]["Kanika Mam"]);
        return res.json({
            status: true,
            // data: scheduleLectures.map((item, index) => {
            //   return {
            //     sNo: index + 1,
            //     startDate: item.starting_date,
            //     day: moment(item.starting_date, "DD-MM-YYYY HH:mm:ss").format('dddd'),
            //     teacherName: item?.teacher[0]?.FullName ?? "",
            //     batchName: item?.batch?.batch_name ?? "",
            //     startTiming: item.starting_date,
            //     endTiming: item.ending_date,
            //     lectureTopic: item.lecture_title,
            //   }
            // }),
            data: {},
            msg: 'Schedule lecture found'
        })

    } catch (error) {
        return res.json({
            status: false,
            data: null,
            msg: error.message
        })
    }
})
const filePath = path.join(__dirname, '..', 'data.js');
AdminPanel.post("/writeAndReadData", async (req, res) => {
    const { data } = req.body;
    try {

        if (data) {
            // const moduleContent = `{ data: ${JSON.stringify(data, null, 2)} }`;
            await fs.writeFile(filePath, JSON.stringify(data, null, 2), 'utf-8');
        }
        let response = await fs.readFile(filePath, 'utf-8');
        return res.json({
            status: true,
            data: JSON.parse(response),
            msg: "Data fetched successfully"
        });

    } catch (error) {
        return res.json({
            status: false,
            data: null,
            msg: error.message
        })
    }
})

AdminPanel.get("/updatePreReqApp", async (req, res) => {
    try {
        return res.json({
            status: true,
            data: {
                isUpdate: false
            },
            msg: "Success"
        });

    } catch (error) {
        return res.json({
            status: false,
            data: null,
            msg: error.message
        })
    }
})

AdminPanel.get("/logoutPreReqApp", async (req, res) => {
    try {
        return res.json({
            status: true,
            data: {
                isLogout: false
            },
            msg: "Success"
        });

    } catch (error) {
        return res.json({
            status: false,
            data: null,
            msg: error.message
        })
    }
})

AdminPanel.post(
    "/addBlog",
    isAdmin,
    upload.single("file"),
    async (req, res) => {
        const {
            title,
            category,
            tags,
            desc,
            platform,
            excerptTitle,
            relatedBlogs,
            link,
            metaTitle,
            metaDesc,
            language,
            isActive,
            // featuredImage,
        } = req.body;
        try {
            const decoded = jwt.verify(req.token, process.env.ADMIN_SECRET_KEY);
            const adminDetails = await findAdminTeacherUsingUserId(decoded.studentId);
            if (!adminDetails) {
                return res.json({
                    status: false,
                    data: null,
                    msg: "Not an admin",
                });
            }
            let fileUrl;
            if (req.file) {
                const helperString = Math.floor(Date.now() / 1000);
                const filename = (req.file.originalname.split(".")[0]).replace(/\s+/g, '_').replace(/[^a-zA-Z0-9_]/g, '');
                const extension = "." + req.file.originalname.split(".").pop();
                FileUploadLocation = `blog/${filename}_${helperString}${extension}`;
                let fileLocHelper = await uploadFile(req.file.path, FileUploadLocation);
                fileUrl = fileLocHelper;
            } else {
                fileUrl = featuredImage;
            }
            const slug = await generateSlug(title);
            const newBlog = new blogsTable({
                author: adminDetails._id,
                title,
                category,
                slug,
                featuredImage: fileUrl,
                tags,
                metaTitle,
                metaDesc,
                platform,
                desc,
                link,
                excerptTitle,
                relatedBlogs,
                language,
                isActive,
            });
            const saveBlog = await newBlog.save();
            return res.json({
                status: true,
                data: saveBlog,
                msg: "New Blog added successfully",
            });
        } catch (error) {
            return res.json({
                status: false,
                data: null,
                msg: error.message || `Blog not added`,
            });
        }
    }
);

AdminPanel.post("/updateBlog/:id", upload.single("file"), isAdmin, async (req, res) => {
    const { id } = req.params;
    let {
        title,
        category,
        tags,
        link,
        slug,
        excerptTitle,
        metaTitle,
        metaDesc,
        platform,
        relatedBlogs,
        desc,
        language,
        isActive,
        featuredImage,
    } = req.body;
    if (!id) {
        return res.json({
            status: false,
            data: null,
            msg: "Product Id not found",
        });
    }
    try {
        const decoded = jwt.verify(req.token, process.env.ADMIN_SECRET_KEY);
        const adminDetails = await findAdminTeacherUsingUserId(decoded.studentId);
        if (!adminDetails) {
            return res.json({
                status: false,
                data: null,
                msg: "Not an admin",
            });
        }
        const isExist = await blogsTable.findOne({ _id: id });
        if (!isExist) {
            return res.json({
                status: false,
                data: null,
                msg: "Blog not found",
            });
        }
        const isSlugExist = await blogsTable.findOne({ _id: { $ne: id }, slug: slug });
        if (isSlugExist) {
            return res.json({
                status: false,
                data: null,
                msg: "Slug already exists",
            });
        }
        const regex = /^[A-Za-z0-9\s\-]+$/;
        let isValid = regex.test(slug);
        if (!isValid && slug) {
            return res.json({
                status: false,
                data: null,
                msg: 'Slug can contain only characters & number '
            })
        }

        const newSlug = slug ? await generateSlug(slug) : isExist?.slug;
        title = title ? title : proCat.title;
        let fileUrl;
        if (req.file) {
            const helperString = Math.floor(Date.now() / 1000);
            const filename = (req.file.originalname.split(".")[0]).replace(/\s+/g, '_').replace(/[^a-zA-Z0-9_]/g, '');
            const extension = "." + req.file.originalname.split(".").pop();
            FileUploadLocation = `blog/${title?.replace(/\s+/g, '_').replace(/[^a-zA-Z0-9_]/g, '')}/${filename}_${helperString}${extension}`;
            let fileLocHelper = await uploadFile(req.file.path, FileUploadLocation);
            fileUrl = fileLocHelper;
        }
        if (featuredImage) {
            fileUrl = featuredImage;
        }

        const updateProduct = await blogsTable.findByIdAndUpdate(
            isExist._id,
            {
                title,
                category,
                slug: newSlug,
                featuredImage: fileUrl,
                tags,
                link,
                excerptTitle,
                metaTitle,
                metaDesc,
                platform,
                relatedBlogs,
                desc,
                language,
                isActive,
            },
            { new: true, lean: true }
        );
        return res.json({
            status: true,
            data: updateProduct,
            msg: `Blog Details updated`,
        });
    } catch (error) {
        return res.json({
            status: false,
            data: null,
            msg: error.message || `Product details not added`,
        });
    }
});

AdminPanel.delete("/deleteBlog/:id", isAdmin, async (req, res) => {
    const { id } = req.params;
    if (!id) {
        return res.json({
            status: false,
            data: null,
            msg: `Blog id not found.`,
        });
    }
    try {
        const decoded = jwt.verify(req.token, process.env.ADMIN_SECRET_KEY);
        const adminDetails = await findAdminTeacherUsingUserId(decoded.studentId);
        if (!adminDetails) {
            return res.status(401).json({
                status: false,
                data: null,
                msg: "Not an admin",
            });
        }
        const isBata = await blogsTable.findOne({ _id: id })
        if (!isBata) {
            return res.status(404).json({
                status: false,
                data: null,
                msg: "Blog not found",
            });
        }
        await savePanelEventLogs(
            adminDetails?._id,
            "deleteBlog",
            "delete",
            isBata
        )
        await blogsTable.findByIdAndDelete(id);
        res.json({
            status: true,
            data: isBata,
            msg: "Blog deleted",
        });
    } catch (error) {
        return res.json({
            status: false,
            data: null,
            msg: error.message
        });
    }
});

AdminPanel.get("/getAllBlog", isAdmin, async (req, res) => {
    try {
        const decoded = jwt.verify(req.token, process.env.ADMIN_SECRET_KEY);
        const adminDetails = await findAdminTeacherUsingUserId(decoded.studentId);
        if (!adminDetails) {
            return res.status(401).json({
                status: false,
                data: null,
                msg: "Not an admin",
            });
        }
        const data = await blogsTable.find({}).populate("author", "FullName Role").populate("category", "_id title");
        res.json({
            status: true,
            data: data.map((item, index) => {
                return {
                    ...item._doc,
                    id: item._id,
                    sNo: index + 1,
                    createdAt: moment(item.createdAt).format("DD-MM-YYYY HH:mm:ss"),
                    updatedAt: moment(item.updatedAt).format("DD-MM-YYYY HH:mm:ss")
                }
            }),
            msg: "Blog Fetched",
        });
    } catch (error) {
        return res.json({
            status: false,
            data: null,
            msg: error.message
        });
    }
});
AdminPanel.get("/getBlogById/:id", isAdmin, async (req, res) => {
    const { id } = req.params;
    if (!id) {
        return res.json({
            status: false,
            data: null,
            msg: `Blog id not found.`,
        });
    }
    try {
        const decoded = jwt.verify(req.token, process.env.ADMIN_SECRET_KEY);
        const adminDetails = await findAdminTeacherUsingUserId(decoded.studentId);
        if (!adminDetails) {
            return res.status(401).json({
                status: false,
                data: null,
                msg: "Not an admin",
            });
        }
        const data = await blogsTable.findOne({ _id: id }).populate("category", "_id title").populate('author', "FullName");
        if (!data) {
            return res.status(404).json({
                status: false,
                data: null,
                msg: "Blog not found",
            });
        }

        res.json({
            status: true,
            data: { ...data._doc, createdAt: moment(data.createdAt).format("DD-MM-YYYY HH:mm:ss"), updatedAt: moment(data.updatedAt).format("DD-MM-YYYY HH:mm:ss") },
            msg: "Blog found",
        });
    } catch (error) {
        return res.json({
            status: false,
            data: null,
            msg: error.message
        });
    }
});

AdminPanel.get("/getBlogs", async (req, res) => {

    let { category, categorySlug, seoCategorySlug, page, pageSize, platform } = req.query;
    // console.log(category);
    try {
        page = parseInt(page) || 1;
        pageSize = parseInt(pageSize) || 10;
        let categoryArray = [];
        if (category || categorySlug) {
            let cateQuery = category ? { _id: category } : { slug: categorySlug };
            let isCategory = await categoryTable.findOne(cateQuery);
            if (!isCategory) {
                return res.json({
                    status: false,
                    data: null,
                    msg: "Not a Valid Category"
                })
            }
            categoryArray.push(mongoose.Types.ObjectId(isCategory._id));
        }
        if (seoCategorySlug) {
            let isCategory = await categoryTable.findOne({ seoSlug: seoCategorySlug })
            if (!isCategory) {
                return res.json({
                    status: false,
                    data: null,
                    msg: "Not a Valid Category"
                })
            }
            categoryArray.push(mongoose.Types.ObjectId(isCategory?._id))
        }
        const blogs = await blogsTable.aggregate([
            {
                $facet: {
                    blogs: [
                        { $match: { isActive: true, ...(platform ? { platform: platform } : {}), ...(categoryArray.length > 0 && { category: { $in: categoryArray } }) } },
                        { $sort: { createdAt: -1 } },
                        { $skip: (page - 1) * pageSize },
                        { $limit: pageSize },
                        {
                            $lookup:
                            {
                                from: "categorytables",
                                localField: 'category',
                                foreignField: "_id",
                                as: 'categoryDetails'
                            },
                        },
                        {
                            $unwind: '$categoryDetails'
                        }
                    ],
                    totalCounts: [
                        { $group: { _id: null, count: { $sum: 1 } } },
                    ]
                }
            },
            {
                $project: {
                    blogs: 1,
                    totalCounts: { $arrayElemAt: ['$totalCounts', 0] },

                }
            }
        ])
        let responseData = blogs[0].blogs.map((item) => {
            return {
                id: item?._id ?? "",
                title: item?.title ?? "",
                excerptTitle: item?.excerptTitle ?? "",
                metaTitle: item?.metaTitle ?? "",
                metaDesc: item?.metaDesc ?? "",
                slug: item?.slug ?? "",
                platform: item?.platform ?? "",
                featuredImage: item?.featuredImage ?? "",
                language: item?.language ?? '',
                category: {
                    id: item?.categoryDetails?._id ?? "",
                    title: item?.categoryDetails?.title ?? "",
                    slug: item?.categoryDetails?.slug ?? "",
                    icon: item?.categoryDetails?.icon ?? "",
                    tags: item?.categoryDetails?.tags ?? [],
                    seoMetaTitle: item?.categoryDetails?.seoMetaTitle ?? "",
                    seoMetaDesc: item?.categoryDetails?.seoMetaDesc ?? "",
                    seoSlug: item?.categoryDetails?.seoSlug ?? "",
                },
                createdAt: moment(item.createdAt).format("DD MMMM YYYY"),
            }
        });

        return res.json({
            status: true,
            data: { blogs: responseData, totalCounts: blogs[0].totalCounts.count },
            msg: 'blogs fetched'
        })

    } catch (error) {
        return res.json({
            status: false,
            data: null,
            msg: error.message
        })
    }
})
AdminPanel.get("/getLatestBlog", async (req, res) => {
    let { page, pageSize, platform } = req.query;
    try {
        page = parseInt(page) || 1;
        pageSize = parseInt(pageSize) || 10;
        // console.log( page + " "+pageSize);
        // const latestBlogs = await blogsTable.find({}).skip((page - 1)*pageSize).limit(pageSize).populate("category", "_id title slug icon").sort({ createdAt: -1 }).limit(6);
        const latestBlogs = await blogsTable.aggregate([
            {
                $facet: {
                    blogs: [
                        { $match: { isActive: true, ...(platform ? { platform: platform } : {}) } },
                        { $sort: { createdAt: -1 } },
                        { $skip: (page - 1) * pageSize },
                        { $limit: pageSize },
                        {
                            $lookup: {
                                from: 'categorytables',
                                localField: 'category',
                                foreignField: '_id',
                                as: 'categoryDetails'
                            }
                        },
                        {
                            $unwind: '$categoryDetails'
                        }

                    ],
                    totalCounts: [
                        { $group: { _id: null, count: { $sum: 1 } } }
                    ]
                }
            },
            {
                $project: {
                    blogs: 1,
                    totalCounts: { $arrayElemAt: ['$totalCounts', 0] },

                }
            }

        ])
        let resLatest = latestBlogs[0].blogs.map((item) => {
            return {
                id: item?._id ?? "",
                title: item?.title ?? "",
                excerptTitle: item?.excerptTitle ?? "",
                metaTitle: item?.metaTitle ?? "",
                metaDesc: item?.metaDesc ?? "",
                slug: item?.slug ?? "",
                platform: item.platform ?? "",
                featuredImage: item?.featuredImage ?? "",
                language: item?.language ?? '',
                category: {
                    id: item?.categoryDetails?._id ?? "",
                    title: item?.categoryDetails?.title ?? "",
                    slug: item?.categoryDetails?.slug ?? "",
                    icon: item?.categoryDetails?.icon ?? "",
                    tags: item?.categoryDetails?.tags ?? [],
                    seoMetaTitle: item?.categoryDetails?.seoMetaTitle ?? "",
                    seoMetaDesc: item?.categoryDetails?.seoMetaDesc ?? "",
                    seoSlug: item?.categoryDetails?.seoSlug ?? "",
                },
                createdAt: moment(item.createdAt).format("DD MMMM YYYY"),
            }
        });
        return res.json({
            status: true,
            data: { blogs: resLatest, totalCounts: latestBlogs[0]?.totalCounts?.count },
            msg: 'latest blog fethced'
        })
    } catch (error) {
        return res.json({
            status: false,
            data: null,
            msg: error.message
        })
    }
})
AdminPanel.get("/getBlog", async (req, res) => {
    const { id, slug } = req.query;
    if (!id && !slug) {
        return res.json({
            status: false,
            data: null,
            msg: "Requires Id Or Slug"
        })
    }
    try {
        let blog;
        if (id) {
            blog = await blogsTable.findOne({ _id: id }).populate("category", "_id title slug icon seoMetaTitle seoMetaDesc seoSlug");
        }
        if (slug) {
            blog = await blogsTable.findOne({ slug: slug }).populate("category", "_id title slug icon seoMetaTitle seoMetaDesc seoSlug");
        }
        if (!blog) {
            return res.json({
                status: false,
                data: null,
                msg: "Blog not found"
            })
        }

        let responseData =
        {
            id: blog?._id ?? "",
            title: blog?.title ?? "",
            excerptTitle: blog?.excerptTitle ?? "",
            metaTitle: blog?.metaTitle ?? "",
            metaDesc: blog?.metaDesc ?? "",
            slug: blog?.slug ?? "",
            featuredImage: blog?.featuredImage ?? "",
            desc: blog?.desc ?? "",
            language: blog?.language ?? '',
            category: {
                id: blog?.category?._id ?? "",
                title: blog?.category?.title ?? "",
                slug: blog?.category?.slug ?? "",
                icon: blog?.category?.icon ?? "",
                tags: blog?.category?.tags ?? [],
                seoMetaTitle: blog?.category?.seoMetaTitle ?? "",
                seoMetaDesc: blog?.category?.seoMetaDesc ?? "",
                seoSlug: blog?.category?.seoSlug ?? "",
            },
            createdAt: moment(blog.createdAt).format("DD MMMM YYYY"),
        }
            ;

        return res.json({
            status: true,
            data: responseData,
            msg: 'blog fetched'
        })

    } catch (error) {
        return res.json({
            status: false,
            data: null,
            msg: error.message
        })
    }
})

AdminPanel.get("/freeCourses", ValidateToken, async (req, res) => {
    let { stream, page, pageSize, subCategory } = req.query;
    try {
        page = parseInt(page) || 1;
        pageSize = parseInt(pageSize) || 150;
        const decoded = jwt.verify(req.token, process.env.SECRET_KEY);
        const user = await findUserByUserId(decoded.studentId);
        if (!user) {
            return res.json({
                status: false,
                data: null,
                msg: 'Not an user'
            })
        }
        const myBatches = await MybatchTable.find({ user: user._id });
        let myBatchIdArray = myBatches.map((item) => { return item.batch_id })
        // console.log()
        let query = {};
        if (stream && stream != 'all') {
            query = {
                _id: { $nin: myBatchIdArray },
                stream: stream,
                isPaid: false,
                charges: '0',
                discount: '0',
                is_active: true,
            }
        } else {
            query = {
                _id: { $nin: myBatchIdArray },
                isPaid: false,
                discount: "0",
                charges: '0',
                is_active: true,
            }
        }
        if (!["", null, undefined].includes(subCategory)) {
            const isSubCategory = await subCategoryTable.findOne({ _id: subCategory });
            if (isSubCategory) {
                query.subCategory = { $in: [isSubCategory?._id] }
            }
        }
        // console.log(query)
        const batches = await BatchesTable.find(query)
            .populate({
                path: 'teacher',
                select: "FullName profilePhoto qualification demoVideo",
                populate: {
                    path: 'subject',
                    select: 'title'
                }
            })
            .populate("subject", { _id: 1, title: 1 })
            .populate("subCategory", 'title, slug')
            .sort({ createdAt: -1 }).skip((page - 1) * pageSize).limit(pageSize);

        let responseArr = [];

        const ResponseArray = await Promise.all(batches.map(async (item) => {
            const lectureCount = await LectureTable.find({ batch: item?._id, LiveOrRecorded: 'Recorded' }).countDocuments();
            const category = await categoryTable.findOne({ title: item.stream });
            let obj = {
                _id: item._id ?? "",
                batch_name: item.batch_name ?? "",
                slug: item.slug ?? "",
                exam_type: item.exam_type ?? "",
                student: [],
                subject: item.subject ?? [],
                teacher: item.teacher ?? [],
                starting_date: item.starting_date ?? "",
                ending_date: item.ending_date ?? "",
                mode: item.mode ?? "",
                materials: item.materials ?? "",
                // language : item.language ?? "",
                charges: item.charges ?? "",
                discount: item.discount ?? "",
                description: item.description ?? "",
                banner: item.banner ?? {},
                language: item.language ?? "",
                stream: item.stream ?? "",
                remark: item.remark ?? "",
                demoVideo: item.demoVideo ?? "",
                validity: item.validity ?? "",
                is_active: item.is_active ?? "",
                isPaid: item.isPaid ?? "",
                isCoinApplicable: item.isCoinApplicable ?? "",
                maxAllowedCoins: item.maxAllowedCoins ?? "",
                course_review: item.course_review ?? "",
                batchOrder: item?.batchOrder ?? "",
                shareUrl: { link: item?.shareLink?.link ?? "", text: item?.shareLink?.text ?? "" },
                shareLink: "",
                batchFeatureUrl: batchValidityFeatures(item.stream),
                subCategory: item.subCategory[0].title ?? "",
                planner: item?.planner ?? {
                    fileLoc: "",
                    fileName: "",
                    fileSize: "",
                },
                created_at: item.created_at ?? "",
                NoOfVideos: lectureCount,
            }
            if (category?.is_active == true) {
                responseArr.push(obj)
            }

        }));

        return res.json({
            status: true,
            // data: ResponseArray ?? [],
            data: responseArr ?? [],
            msg: 'free Courses fetched'
        })

    } catch (error) {
        return res.json({
            status: false,
            data: null,
            msg: error.message
        })
    }
})
AdminPanel.get("/paidCourses", ValidateToken, async (req, res) => {
    let { stream, page, pageSize, subCategory } = req.query;
    try {
        page = parseInt(page) || 1;
        pageSize = parseInt(pageSize) || 150;
        const decoded = jwt.verify(req.token, process.env.SECRET_KEY);
        const user = await findUserByUserId(decoded.studentId);
        if (!user) {
            return res.json({
                status: false,
                data: null,
                msg: 'Not an user'
            })
        }
        const myBatches = await MybatchTable.find({ user: user._id });
        let myBatchIdArray = myBatches.map((item) => { return item.batch_id })
        let query = {};
        if (stream && stream != 'all') {
            query = {
                _id: { $nin: myBatchIdArray },
                stream: stream,
                isPaid: true,
                charges: { $gt: '0' },
                is_active: true,
            }
        } else {
            query = {
                _id: { $nin: myBatchIdArray },
                isPaid: true,
                charges: { $gt: '0' },
                is_active: true,
            }
        }
        // console.log(query);
        if (!["", null, undefined].includes(subCategory)) {
            const isSubCategory = await subCategoryTable.findOne({ _id: subCategory });
            if (isSubCategory) {
                query.subCategory = { $in: [isSubCategory?._id] }
            }
        }
        const batches = await BatchesTable.find(query)
            .populate({
                path: 'teacher',
                select: "FullName profilePhoto qualification demoVideo",
                populate: {
                    path: 'subject',
                    select: 'title'
                }
            })
            .populate("subject", { _id: 1, title: 1 })
            .populate("subCategory", 'title slug')
            .sort({ createdAt: -1 }).skip((page - 1) * pageSize).limit(pageSize);

        let responseArr = [];
        const ResponseArray = await Promise.all(batches.map(async (item) => {
            const lectureCount = await LectureTable.find({ batch: item?._id, LiveOrRecorded: 'Recorded' }).countDocuments();
            const category = await categoryTable.findOne({ title: item.stream });
            let obj = {
                _id: item._id ?? "",
                batch_name: item.batch_name ?? "",
                slug: item.slug ?? "",
                exam_type: item.exam_type ?? "",
                student: [],
                subject: item.subject ?? [],
                teacher: item.teacher ?? [],
                starting_date: item.starting_date ?? "",
                ending_date: item.ending_date ?? "",
                mode: item.mode ?? "",
                materials: item.materials ?? "",
                // language : item.language ?? "",
                charges: item.charges ?? "",
                discount: item.discount ?? "",
                description: item.description ?? "",
                banner: item.banner ?? {},
                language: item.language ?? "",
                stream: item.stream ?? "",
                remark: item.remark ?? "",
                demoVideo: item.demoVideo ?? "",
                validity: item.validity ?? "",
                is_active: item.is_active ?? "",
                isPaid: item.isPaid ?? "",
                isCoinApplicable: item.isCoinApplicable ?? "",
                maxAllowedCoins: item.maxAllowedCoins ?? "",
                course_review: item.course_review ?? "",
                batchOrder: item?.batchOrder ?? "",
                shareUrl: { link: item?.shareLink?.link ?? "", text: item?.shareLink?.text ?? "" },
                shareLink: "",
                batchFeatureUrl: batchValidityFeatures(item.stream),
                subCategory: item?.subCategory[0]?.title ?? "",
                planner: item?.planner ?? {
                    fileLoc: "",
                    fileName: "",
                    fileSize: "",
                },
                created_at: item.created_at ?? "",
                NoOfVideos: lectureCount,

            }
            if (category?.is_active == true) {
                responseArr.push(obj);
            }
        }));

        return res.json({
            status: true,
            // data: ResponseArray ?? [],
            data: responseArr ?? [],
            msg: 'Paid Courses fetched'
        })

    } catch (error) {
        return res.json({
            status: false,
            data: null,
            msg: error.message
        })
    }
})

AdminPanel.get("/getSubjectOfBatch", ValidateToken, async (req, res) => {
    const { batchId } = req.query;
    if (!batchId) {
        return res.json({
            status: false,
            data: null,
            msg: 'Required batchId'
        })
    }
    try {
        const decoded = jwt.verify(req.token, process.env.SECRET_KEY);
        const user = await findUserByUserId(decoded.studentId);
        if (!user) {
            return res.json({
                status: false,
                data: null,
                msg: 'Not an user'
            })
        }
        const isMyBatch = await MybatchTable.findOne({ user: user._id, batch_id: batchId });
        if (!isMyBatch) {
            return res.json({
                status: false,
                data: null,
                msg: "not authorized to access"
            })
        }
        const isBatch = await BatchesTable.findOne({ _id: batchId }).populate('features', '_id feature icon isActive order').populate("subject", "_id title icon");
        if (!isBatch) {
            return res.json({
                status: false,
                data: null,
                msg: 'Batch not found'
            })
        }
        return res.json({
            status: true,
            data: isBatch?.subject?.map((item) => {
                return {
                    id: item?._id ?? "",
                    title: item?.title ?? "",
                    icon: item?.icon ?? "https://d1mbj426mo5twu.cloudfront.net/assets/science.png",
                }
            }),
            data1: {
                subjects: isBatch?.subject?.map((item) => {
                    return {
                        id: item?._id ?? "",
                        title: item?.title ?? "",
                        icon: item?.icon ?? "https://d1mbj426mo5twu.cloudfront.net/assets/science.png",
                    }
                }),
                batchFeatures: isBatch?.features?.filter((item) => item.isActive != false).sort((a, b) => a.order - b.order).map((item) => {
                    return {
                        featureId: item?._id ?? "",
                        icon: item?.icon ?? "",
                        feature: item?.feature ?? "",
                    }
                })
            },
            msg: 'All Subject fetched'
        })

    } catch (error) {
        return res.json({
            status: false,
            data: null,
            msg: error.message
        })
    }
})

AdminPanel.get("/getLecturesOfSubject", ValidateToken, async (req, res) => {
    const { batchId, subjectId } = req.query;
    if (!batchId && !subjectId) {
        return res.json({
            status: false,
            data: null,
            msg: 'Required batchId or subjectId'
        })
    }
    try {
        const decoded = jwt.verify(req.token, process.env.SECRET_KEY);
        const user = await findUserByUserId(decoded.studentId);
        if (!user) {
            return res.json({
                status: false,
                data: null,
                msg: 'Not an user'
            })
        }
        const isMyBatch = await MybatchTable.findOne({ user: user._id, batch_id: batchId });
        if (!isMyBatch) {
            return res.json({
                status: false,
                data: null,
                msg: "not authorized to access"
            })
        }
        // let today = moment().startOf('day'); 
        // let expireDate = moment(isMyBatch?.expireDate).startOf('day');
        // if (expireDate.isBefore(today)) {

        //      return res.json({
        //                     status: false,
        //                     data: null,
        //                     msg: 'Batch expired.'
        //             })
        // }
        const isBatch = await BatchesTable.findOne({ _id: batchId }).populate("subject", "_id title");
        if (!isBatch) {
            return res.json({
                status: false,
                data: null,
                msg: 'Batch not found'
            })
        }
        const isSubject = await SubjectTable.findOne({ _id: subjectId });
        if (!isSubject) {
            return res.json({
                status: false,
                data: null,
                msg: 'Subject not found'
            })
        }
        let lectures = 0;
        if(isBatch?.materials == "recorded") {
            lectures = await LectureTable.find({ batch: batchId, subject: subjectId, isActive: true }).populate("subject")
                .populate({
                    path: 'teacher',
                    select: "FullName profilePhoto",
                    populate: {
                        path: 'subject',
                        select: 'title'
                    }
                }).sort({ startingDate: -1 });
        } else {
            lectures = await LectureTable.find({ batch: batchId, subject: subjectId, createdAt: { $exists: true, $gte: isMyBatch?.assignedDate }, isActive: true }).populate("subject")
                .populate({
                    path: 'teacher',
                    select: "FullName profilePhoto",
                    populate: {
                        path: 'subject',
                        select: 'title'
                    }
                }).sort({ startingDate: -1 });
        }

        return res.json({
            status: true,
            data: lectures?.map((item) => {
                return {
                    _id: item?._id ?? "",
                    lecture_type: item?.lecture_type ?? "",
                    lecture_title: item?.lecture_title ?? "",
                    description: item?.description ?? "",
                    teacher: item?.teacher ?? [],
                    subject: item?.subject ?? {},
                    link: item?.link ?? "",
                    // link : "" , 
                    LiveOrRecorded: item?.LiveOrRecorded ?? "",
                    starting_date: item?.starting_date ?? "",
                    ending_date: item?.ending_date ?? "",
                    material: item?.material ?? "",
                    dpp: item?.dpp ?? "",
                    ytLiveChatId: item?.ytLiveChatId ?? "",
                    created_at: item?.created_at ?? "",
                    language: item?.language ?? "",
                }
            }),
            msg: 'All Subject fetched'
        })

    } catch (error) {
        return res.json({
            status: false,
            data: null,
            msg: error.message
        })
    }
})

AdminPanel.get("/getLectureOfSubject", ValidateToken, async (req, res) => {
    const { batchId, subjectId } = req.query;
    if (!batchId && !subjectId) {
        return res.json({
            status: false,
            data: null,
            msg: 'Required batchId or subjectId'
        })
    }
    try {
        const decoded = jwt.verify(req.token, process.env.SECRET_KEY);
        const user = await findUserByUserId(decoded.studentId);
        if (!user) {
            return res.json({
                status: false,
                data: null,
                msg: 'Not an user'
            })
        }
        const isMyBatch = await MybatchTable.findOne({ user: user._id, batch_id: batchId });
        if (!isMyBatch) {
            return res.json({
                status: false,
                data: null,
                msg: "not authorized to access"
            })
        }
        // let today = moment().startOf('day'); 
        // let expireDate = moment(isMyBatch?.expireDate).startOf('day');
        // if (expireDate.isBefore(today)) {

        //      return res.json({
        //                     status: false,
        //                     data: null,
        //                     msg: 'Batch expired.'
        //             })
        // }
        const isBatch = await BatchesTable.findOne({ _id: batchId }).populate("subject", "_id title");
        if (!isBatch) {
            return res.json({
                status: false,
                data: null,
                msg: 'Batch not found'
            })
        }
        const isSubject = await SubjectTable.findOne({ _id: subjectId });
        if (!isSubject) {
            return res.json({
                status: false,
                data: null,
                msg: 'Subject not found'
            })
        }
        let lectures = 0;
        if(isBatch?.materials == "recorded") {
            lectures = await LectureTable.find({ batch: batchId, subject: subjectId, isActive: true }).populate("subject")
                .populate({
                    path: 'teacher',
                    select: "FullName profilePhoto",
                    populate: {
                        path: 'subject',
                        // select: 'title'
                    }
                }).populate('batch', '_id batch_name slug').sort({ startingDate: -1 });
        } else {
            lectures = await LectureTable.find({ batch: batchId, subject: subjectId, startingDate: { $exists: true, $gte: isMyBatch?.assignedDate }, isActive: true }).populate("subject")
                .populate({
                    path: 'teacher',
                    select: "FullName profilePhoto",
                    populate: {
                        path: 'subject',
                        // select: 'title'
                    }
                }).populate('batch', '_id batch_name slug').sort({ startingDate: -1 });
        }
        let response = await Promise.all(lectures?.map(async (item) => {
            let userRoom = { _id: "", mentor: [], title: "" };
            if (item?.lecture_type == 'TWOWAY' && item?.LiveOrRecorded == "Live") {
                userRoom = await lectureRoomTable.findOne({ lecture: item?._id, students: { $in: user?._id } }).populate("mentor", "_id FullName Role").select('_id title mentor');
            }
            // userRoom = await lectureRoomTable.findOne({ lecture: item?._id, students: { $in: user?._id } }).populate("mentor", "_id FullName Role").select('_id title mentor');
            return {
                ...item?._doc,
                teacher: item?.teacher[0] ?? {},
                banner: item?.banner != "" ? item?.banner : "https://static.sdcampus.com/assets/lecture_default_1732539568.jpg",
                batch: item?._doc?.batch?._id ?? "",
                batchDetails: { id: item?._doc?.batch?._id, batchName: item?._doc?.batch?.batch_name, slug: item?._doc?.batch?.slug } ?? { id: "", batchName: "", slug: "" },
                commonName: item?._doc?.commonName ?? "",
                // socketUrl : item?.socketUrl ?? "https://twoway-backend-prod.sdcampus.com/mediasoup",
                roomDetails: {
                    id: userRoom?._id ?? "", roomName: userRoom?.title ?? "",
                    mentor: userRoom?.mentor?.map((item2) => { return { mentorId: item2?._id ?? "", mentorName: item2?.FullName ?? "" } }) ?? [],
                    batchName: isBatch?.batch_name ?? "",
                } ?? {}
            }
        }))
        return res.json({
            status: true,
            data: response,
            msg: 'All Subject fetched'
        })
    } catch (error) {
        return res.json({
            status: false,
            data: null,
            msg: error.message
        })
    }
})

AdminPanel.get("/getNotesByBatch/:batchId", ValidateToken, async (req, res) => {
    const { batchId } = req.params;
    if (!batchId) {
        return res.json({
            status: false,
            data: null,
            msg: "Required batchId"
        })
    }
    try {
        const decoded = jwt.verify(req.token, process.env.SECRET_KEY);
        const user = await findUserByUserId(decoded.studentId);
        if (!user) {
            return res.json({
                status: false,
                data: null,
                msg: 'Not an user'
            })
        }
        const isBatch = await BatchesTable.findOne({ _id: batchId });
        if (!isBatch) {
            return res.json({
                status: false,
                data: null,
                msg: "Batch not found"
            })
        }
        const isMyBatch = await MybatchTable.findOne({ user: user._id, batch_id: batchId });
        if (!isMyBatch) {
            return res.json({
                status: false,
                data: null,
                msg: "not authorized to access"
            })
        }
        // let today = moment().startOf('day'); 
        // let expireDate = moment(isMyBatch?.expireDate).startOf('day');
        // if (expireDate.isBefore(today)) {

        //      return res.json({
        //                     status: false,
        //                     data: null,
        //                     msg: 'Batch expired.'
        //             })
        // }
        let lectures = [];
        if (isBatch?.materials == "recorded") {
            lectures = await LectureTable.find({ batch: batchId, isActive: true });
        } else {
            lectures = await LectureTable.find({ batch: batchId, createdAt: { $exists: true, $gte: isMyBatch?.assignedDate }, isActive: true });
        }
        
        let responseArr = [];
        for (let lec of lectures) {
            const notes = await LectureResourceTable.find({ lecture: lec._id, resourceType: { $ne: "DPP" }, is_active: true });
            let lectureMaterial = {
                resource_title: lec?.material?.fileName ?? "", resourceType: "pdf", file: lec?.material ?? {
                    fileLoc: "",
                    fileName: "",
                    fileSize: "",
                }
            }
            let resArr = [];
            if (lectureMaterial.file.fileLoc != "") resArr.push(lectureMaterial);
            notes.map((item) => {
                let resource = item.upload_file ?? {
                    fileLoc: "",
                    fileName: "",
                    fileSize: "",
                }
                if (resource.fileLoc != "") resArr.push({ resource_title: item.title, resourceType: item.resourceType, file: resource });
            })
            if (resArr.length > 0) responseArr.push({ title: lec.lecture_title, res: resArr });
        }

        return res.json({
            status: true,
            data: responseArr,
            msg: 'All Notes fetched'
        })

    } catch (error) {
        return res.json({
            status: false,
            data: null,
            msg: error.message,
        })
    }
})

AdminPanel.post("/updateCurrentCategory", ValidateToken, async (req, res) => {
    const { category, subCategory } = req.body;
    try {
        const decoded = jwt.verify(req.token, process.env.SECRET_KEY);
        const user = await findUserByUserId(decoded.studentId);
        if (!user) {
            return res.json({
                status: false,
                data: null,
                msg: 'Not an user'
            })
        }
        const isCategory = await categoryTable.findOne({ title: category });
        if (!isCategory) {
            return res.json({
                status: false,
                data: null,
                msg: "Category not exist"
            })
        }
        let isSubCategory = { _id: null };
        if (!["", null, undefined].includes(subCategory)) {
            let isSubCategory = await subCategoryTable.findOne({ _id: subCategory, category: isCategory?._id, is_active: true });
            if (!isSubCategory) {
                return res.json({
                    status: false,
                    data: null,
                    msg: `Sub Catgeory Not Valid`
                })
            }

        }
        const curCategory = await currentCategory.findOneAndUpdate({ user: user._id }, { categoryId: isCategory._id, subCategory: isSubCategory?._id }, { new: true, upsert: true });
        return res.json({
            status: true,
            data: isCategory.title,
            msg: `catgeory changes into ${isCategory.title}`
        })

    } catch (error) {
        return res.json({
            status: false,
            data: null,
            msg: error.message
        })
    }
})

AdminPanel.get("/getNotes", ValidateToken, async (req, res) => {
    const { batchId, subjectId } = req.query;
    if (!batchId || !subjectId) {
        return res.json({
            status: false,
            data: null,
            msg: "Required batchId Or SubjectId"
        })
    }
    try {
        const decoded = jwt.verify(req.token, process.env.SECRET_KEY);
        const user = await findUserByUserId(decoded.studentId);
        if (!user) {
            return res.json({
                status: false,
                data: null,
                msg: 'Not an user'
            })
        }
        const isMyBatch = await MybatchTable.findOne({ user: user._id, batch_id: batchId });
        if (!isMyBatch) {
            return res.json({
                status: false,
                data: null,
                msg: "not authorized to access"
            })
        }
        // let today = moment().startOf('day'); 
        // let expireDate = moment(isMyBatch?.expireDate).startOf('day');
        // if (expireDate.isBefore(today)) {

        //      return res.json({
        //                     status: false,
        //                     data: null,
        //                     msg: 'Batch expired.'
        //             })
        // }
        const isBatch = await BatchesTable.findOne({ _id: batchId, subject: { $in: subjectId } });
        if (!isBatch) {
            return res.json({
                status: false,
                data: null,
                msg: "Batch not found"
            })
        }

        let lectures = [];
        if (isBatch?.materials == "recorded") {
            lectures = await LectureTable.find({ batch: batchId, subject: subjectId, isActive: true });
        } else {
            lectures = await LectureTable.find({ batch: batchId, subject: subjectId, createdAt: { $exists: true, $gte: isMyBatch?.assignedDate }, isActive: true });
        }
        let responseArr = [];
        for (let lec of lectures) {
            const notes = await LectureResourceTable.find({ lecture: lec._id, resourceType: { $ne: "DPP" }, is_active: true });
            let lectureMaterial = {
                resource_title: lec?.material?.fileName ?? "", resourceType: "pdf", file: lec?.material ?? {
                    fileLoc: "",
                    fileName: "",
                    fileSize: "",
                }
            }
            let resArr = [];
            if (lectureMaterial.file.fileLoc != "") resArr.push(lectureMaterial);
            notes.map((item) => {
                let resource = item.upload_file ?? {
                    fileLoc: "",
                    fileName: "",
                    fileSize: "",
                }
                if (resource.fileLoc != "") resArr.push({ resource_title: item.title, resourceType: item.resourceType, file: resource });
            })
            if (resArr.length > 0) responseArr.push({ title: lec.lecture_title, res: resArr });
        }

        return res.json({
            status: true,
            data: responseArr,
            msg: 'All Notes fetched'
        })

    } catch (error) {
        return res.json({
            status: false,
            data: null,
            msg: error.message,
        })
    }
})

AdminPanel.get("/getDPPs", ValidateToken, async (req, res) => {
    const { batchId, subjectId } = req.query;
    if (!batchId || !subjectId) {
        return res.json({
            status: false,
            data: null,
            msg: "Required batchId Or SubjectId"
        })
    }
    try {
        const decoded = jwt.verify(req.token, process.env.SECRET_KEY);
        const user = await findUserByUserId(decoded.studentId);
        if (!user) {
            return res.json({
                status: false,
                data: null,
                msg: 'Not an user'
            })
        }
        const isMyBatch = await MybatchTable.findOne({ user: user._id, batch_id: batchId });
        if (!isMyBatch) {
            return res.json({
                status: false,
                data: null,
                msg: "not authorized to access"
            })
        }
        // let today = moment().startOf('day'); 
        // let expireDate = moment(isMyBatch?.expireDate).startOf('day');
        // if (expireDate.isBefore(today)) {

        //      return res.json({
        //                     status: false,
        //                     data: null,
        //                     msg: 'Batch expired.'
        //             })
        // }
        const isBatch = await BatchesTable.findOne({ _id: batchId, subject: { $in: subjectId } });
        if (!isBatch) {
            return res.json({
                status: false,
                data: null,
                msg: "Batch not found"
            })
        }

        const lectures = await LectureTable.find({ batch: batchId, subject: subjectId });
        let responseArr = [];
        for (let lec of lectures) {
            const notes = await LectureResourceTable.find({ lecture: lec._id, resourceType: { $eq: "DPP" }, is_active: true });
            let lectureDPP = {
                resource_title: lec?.dpp?.fileName ?? "", resourceType: "pdf", file: lec?.dpp ?? {
                    fileLoc: "",
                    fileName: "",
                    fileSize: "",
                }
            }
            let resArr = [];
            if (lectureDPP.file.fileLoc != "") resArr.push(lectureDPP);
            notes.map((item) => {
                let resource = item.upload_file ?? {
                    fileLoc: "",
                    fileName: "",
                    fileSize: "",
                }
                if (resource.fileLoc != "") resArr.push({ resource_title: item.title, resourceType: item.resourceType, file: resource });
            })
            if (resArr.length > 0) responseArr.push({ title: lec.lecture_title, res: resArr });
        }

        return res.json({
            status: true,
            data: responseArr,
            msg: 'All Notes fetched'
        })

    } catch (error) {
        return res.json({
            status: false,
            data: null,
            msg: error.message,
        })
    }
})

AdminPanel.post("/uploadImage", upload.single('file'), isAdmin, async (req, res) => {
    try {
        const decoded = jwt.verify(req.token, process.env.ADMIN_SECRET_KEY);
        const adminDetails = await findAdminTeacherUsingUserId(decoded.studentId);
        if (!adminDetails) {
            return res.status(401).json({
                status: false,
                data: null,
                msg: "Not an admin",
            });
        }
        let fileUrl;
        if (req.file) {
            // console.log(req.file);
            const helperString = Math.floor(Date.now() / 1000);
            const filename = (req.file.originalname.split(".")[0]).replace(/\s+/g, '_').replace(/[^a-zA-Z0-9_]/g, '');
            const extension = "." + req.file.originalname.split(".").pop();
            FileUploadLocation = `blogDesc/${filename}_${helperString}${extension}`;
            let fileLocHelper = await uploadFile(req.file.path, FileUploadLocation);
            fileUrl = fileLocHelper;
        }
        return res.json({
            status: true,
            data: fileUrl,
            msg: ` image uploaded successfully`,
        })
    } catch (error) {
        return res.json({
            status: false,
            data: null,
            msg: error.message
        })
    }
})

AdminPanel.post("/updateBatchSlug", upload.single('file'), isAdmin, async (req, res) => {
    const { batchId, slug } = req.body;
    if (!batchId || !slug) {
        return res.json({
            status: false,
            data: null,
            msg: `Required BatchId Or Slug`
        })
    }
    try {
        const decoded = jwt.verify(req.token, process.env.ADMIN_SECRET_KEY);
        const adminDetails = await findAdminTeacherUsingUserId(decoded.studentId);
        if (!adminDetails) {
            return res.status(401).json({
                status: false,
                data: null,
                msg: "Not an admin",
            });
        }
        const regex = /^[A-Za-z0-9\s\-]+$/;
        let isValid = regex.test(slug);
        if (!isValid && slug) {
            return res.json({
                status: false,
                data: null,
                msg: 'Slug can contain only characters & number '
            })
        }
        const isBatch = await BatchesTable.findOne({ _id: batchId });
        if (!isBatch) {
            return res.json({
                status: false,
                data: null,
                msg: "Batch not found"
            })
        }
        const isExistSlug = await BatchesTable.findOne({ _id: { $ne: isBatch?._id }, slug: slug });
        if (isExistSlug) {
            return res.json({
                status: false,
                data: null,
                msg: "Batch Slug already exist"
            })
        }
        let genSlug = await generateSlug(slug);
        const updateSlug = await BatchesTable.findByIdAndUpdate(isBatch?._id, { slug: genSlug }, { new: true, lean: true });

        return res.json({
            status: true,
            data: updateSlug?.slug,
            msg: ` image uploaded successfully`,
        })
    } catch (error) {
        return res.json({
            status: false,
            data: null,
            msg: error.message
        })
    }
})

AdminPanel.get("/getWebSitePaymentsByUserId", isAdmin, async (req, res) => {
    const { id } = req.query;
    if (!id) {
        return res.json({
            status: false,
            data: null,
            msg: `Required id`
        })
    }
    try {
        const decoded = jwt.verify(req.token, process.env.ADMIN_SECRET_KEY);
        const adminDetails = await findAdminTeacherUsingUserId(decoded.studentId);
        if (!adminDetails) {
            return res.status(401).json({
                status: false,
                data: null,
                msg: "Not an admin",
            });
        }
        const userDetails = await UserTable.findOne({ _id: id });
        if (!userDetails) {
            return res.json({
                status: false,
                data: null,
                msg: 'User not found'
            })
        }
        const payments = await courseTxnTable.find({ user: userDetails?._id, isPaid: true })
            .populate({
                path: 'orderId',
                select: "courseId",
                populate: {
                    path: 'courseId',
                    select: "batch_name"
                }
            });
        // console.log(payments);
        return res.json({
            status: true,
            data: payments?.map((item) => {
                return {
                    course: item?.orderId?.courseId?.batch_name ?? "",
                    txnAmount: item?.txnAmount ?? "",
                    txnId: item?.txnId ?? "",
                    easePayId: item?.easePayId ?? "",
                    txnDate: item?.txnDate ?? "",
                }
            }) ?? [],
            msg: `User transaction fetched successfully for website`,
        })
    } catch (error) {
        return res.json({
            status: false,
            data: null,
            msg: error.message
        })
    }
})
AdminPanel.get("/getStorePaymentsByUserId", isAdmin, async (req, res) => {
    const { id } = req.query;
    if (!id) {
        return res.json({
            status: false,
            data: null,
            msg: `Required id`
        })
    }
    try {
        const decoded = jwt.verify(req.token, process.env.ADMIN_SECRET_KEY);
        const adminDetails = await findAdminTeacherUsingUserId(decoded.studentId);
        if (!adminDetails) {
            return res.status(401).json({
                status: false,
                data: null,
                msg: "Not an admin",
            });
        }
        const userDetails = await UserTable.findOne({ _id: id });
        if (!userDetails) {
            return res.json({
                status: false,
                data: null,
                msg: 'User not found'
            })
        }
        const payments = await storeTxnTable.find({ user: userDetails?._id, isPaid: true })
            .populate({
                path: 'orderId',
                select: "products",
                populate: {
                    path: 'products.productId',
                    select: "title"
                }
            });
        // console.log(payments);
        return res.json({
            status: true,
            data: payments?.map((item, index) => {
                return {
                    id: item?._id,
                    sno: index + 1,
                    products: item?.orderId?.products ?? [],
                    txnAmount: item?.txnAmount ?? "",
                    txnId: item?.txnId ?? "",
                    easePayId: item?.easePayId ?? "",
                    txnDate: item?.txnDate ?? "",
                }
            }) ?? [],
            // data1 : payments,
            msg: `User transaction fetched successfully for Store`,
        })
    } catch (error) {
        return res.json({
            status: false,
            data: null,
            msg: error.message
        })
    }
})

AdminPanel.get("/getDashBoardDetails", isAdmin, async (req, res) => {
    try {
        const decoded = jwt.verify(req.token, process.env.ADMIN_SECRET_KEY);
        const adminDetails = await findAdminTeacherUsingUserId(decoded.studentId);
        if (!adminDetails) {
            return res.status(401).json({
                status: false,
                data: null,
                msg: "Not an admin",
            });
        }
        const userCount = await UserTable.find({}).countDocuments();
        const teacherCount = await adminTeacherTable.find({ Role: 'teacher' }).countDocuments();
        const batchCount = await BatchesTable.countDocuments();
        const testSeriesCount = await TestSeriesTable.countDocuments();


        return res.json({
            status: true,
            data: {
                userCount,
                teacherCount,
                batchCount,
                testSeriesCount
            },
            msg: `All Count fetched`,
        })
    } catch (error) {
        return res.json({
            status: false,
            data: null,
            msg: error.message
        })
    }
})

AdminPanel.get("/lectureDetails/:id", ValidateToken, async (req, res) => {
    const { id } = req.params;
    if (!id) {
        return res.json({
            status: false,
            data: null,
            msg: 'Required Id'
        })
    }
    try {
        const decoded = jwt.verify(req.token, process.env.SECRET_KEY);
        const user = await findUserByUserId(decoded?.studentId);
        if (!user) {
            return res.json({
                status: false,
                data: null,
                msg: `Not an user`
            })
        }

        const isLecture = await LectureTable.findOne({ _id: id });
        if (!isLecture) {
            return res.json({
                status: false,
                data: null,
                msg: 'lecture not found'
            })
        }

        const isMyBatch = await MybatchTable.findOne({ user: user?._id, batch_id: isLecture?.batch });
        if (isMyBatch) {
            return res.json({
                status: true,
                data: isLecture,
                msg: 'Lecture Details fetched'
            })
        } else {
            return res.json({
                status: false,
                data: null,
                msg: 'Not authorized to access'
            })
        }


    } catch (error) {
        return res.json({
            status: false,
            data: null,
            msg: error.message
        })
    }
})

AdminPanel.get("/searchCourses", ValidateToken, async (req, res) => {
    const { search } = req.query;
    try {
        const deocode = jwt.verify(req.token, process.env.SECRET_KEY);
        const user = await findUserByUserId(deocode?.studentId);
        if (!user) {
            return res.json({
                status: false,
                data: null,
                msg: 'Not an user'
            })
        }


        let query = { is_active: true };
        if (search) {
            // console.log(search)
            query.$or = [
                { batch_name: { $regex: search, $options: "i" } },
                { stream: { $regex: search, $options: "i" } },
                // { remark: { $regex: search, $options: "i" } },
                // { metaTitle: { $regex: search, $options: "i" } },
                // { metaDesc: { $regex: search, $options: "i" } },
            ]
        }
        // console.log(query.$or);
        if (!["", null, undefined, " "]?.includes(search)) {
            const storeLogs = new userStoreLogsTable({
                user: user?._id,
                searchText: search,
                searchQuery: query,
                type: 'course'
            })
            await storeLogs.save();
        }
        let BatchesDetails = await BatchesTable.find(query)
            .populate({
                path: 'teacher',
                select: "FullName profilePhoto",
                populate: {
                    path: 'subject',
                    select: 'title'
                }
            })
            .populate("subCategory", 'title slug')
            .populate("subject", { _id: 1, title: 1 });

        let responseArr = [];
        const ResponseArray = await Promise.all(BatchesDetails.map(async (item) => {
            const category = await categoryTable.findOne({ title: item.stream });
            let obj = {
                _id: item._id ?? "",
                batch_name: item.batch_name ?? "",
                slug: item.slug ?? "",
                exam_type: item.exam_type ?? "",
                student: [],
                subject: item.subject ?? [],
                teacher: item.teacher ?? [],
                starting_date: item.starting_date ?? "",
                ending_date: item.ending_date ?? "",
                mode: item.mode ?? "",
                materials: item.materials ?? "",
                // language : item.language ?? "",
                charges: item.charges ?? "",
                discount: item.discount ?? "",
                description: item.description ?? "",
                banner: item.banner ?? {},
                language: item.language ?? "",
                stream: item.stream ?? "",
                remark: item.remark ?? "",
                demoVideo: item.demoVideo ?? "",
                validity: item.validity ?? "",
                is_active: item.is_active ?? "",
                isPaid: item.isPaid ?? "",
                isCoinApplicable: item.isCoinApplicable ?? "",
                maxAllowedCoins: item.maxAllowedCoins ?? "",
                course_review: item.course_review ?? "",
                batchOrder: item?.batchOrder ?? "",
                shareUrl: { link: item?.shareLink?.link ?? "", text: item?.shareLink?.text ?? "" },
                shareLink: "",
                batchFeatureUrl: batchValidityFeatures(item.stream),
                subCategory: item.subCategory[0].title ?? "",
                planner: item?.planner ?? {
                    fileLoc: "",
                    fileName: "",
                    fileSize: "",
                },
                created_at: item.created_at ?? "",
            }
            if (category?.is_active == true) {
                responseArr.push(obj);
            }
        }));
        return res.json({
            status: true,
            // data: BatchesDetails,
            // data: ResponseArray ?? [],
            data: responseArr ?? [],
            msg: "Batches fetched"
        })

    } catch (error) {
        return res.json({
            status: false,
            data: null,
            msg: error.message
        })
    }
})

AdminPanel.get("/getStudents", async (req, res) => {
    const { page = 1, pageSize = 25, searchText } = req.query;

    try {
        const pageNum = parseInt(page) || 1;
        const size = parseInt(pageSize) || 10;

        const baseFilter = { Stream: { $exists: true } };

        const buildSearchQuery = (text) => {
            const regex = new RegExp(text, 'i');
            return {
                $or: [
                    { username: { $regex: regex } },
                    { userId: { $regex: regex } },
                    { enrollId: { $regex: regex } },
                    { FullName: { $regex: regex } },
                    { email: { $regex: regex } },
                    { created_at: { $regex: regex } },
                    { mobileNumber: { $regex: regex } },
                    { signinType: { $regex: regex } },
                    { utm_campaign: { $regex: regex } },
                    { utm_source: { $regex: regex } },
                    { utm_medium: { $regex: regex } },
                    { Stream: { $elemMatch: { $regex: regex } } }
                ]
            };
        };

        const matchQuery = searchText
            ? { ...baseFilter, ...buildSearchQuery(searchText) }
            : baseFilter;

        const students = await UserTable.aggregate([
            {
                $facet: {
                    students: [
                        { $match: matchQuery },
                        { $sort: { createdAt: -1 } },
                        { $skip: (pageNum - 1) * size },
                        { $limit: size },
                    ],
                    count: [
                        { $match: matchQuery },
                        { $count: 'count' }
                    ]
                }
            },
            {
                $project: {
                    students: 1,
                    count: { $ifNull: [{ $arrayElemAt: ['$count.count', 0] }, 0] }
                }
            }
        ]);

        const result = students[0];

        return res.json({
            status: true,
            data: {
                studentList: result.students.map((item) => ({
                    ...item,
                    id: item._id,
                    isVerified: item?.isVerified ?? false
                })),
                count: result.count
            },
            msg: 'Students fetched successfully'
        });

    } catch (error) {
        return res.json({
            status: false,
            data: null,
            msg: error.message
        });
    }
})

AdminPanel.get("/timeSpendOnBatch/:id", isAdmin, async (req, res) => {
    const { id } = req.params;
    if (!id) {
        return res.json({
            status: false,
            data: null,
            msg: 'Required Id'
        })
    }
    try {
        const decode = jwt.verify(req.token, process.env.ADMIN_SECRET_KEY);
        const admin = await findAdminTeacherUsingUserId(decode.studentId);
        if (!admin) {
            return res.json({
                status: false,
                data: null,
                msg: 'NOt an admin'
            })
        }
        const isBatch = await BatchesTable.findOne({ _id: id });
        if (!isBatch) {
            return res.json({
                status: false,
                data: null,
                msg: 'Batch not found'
            })
        }

        const timeSpends = await timeSpendOnLecture.aggregate([
            {
                $lookup: {
                    from: 'userstables',
                    localField: 'user',
                    foreignField: '_id',
                    as: "userDetails"
                }
            },
            {
                $unwind: '$userDetails'
            },
            {
                $lookup: {
                    from: 'lecturetables',
                    localField: 'lecture',
                    foreignField: '_id',
                    as: 'lectures'
                }
            },
            {
                $unwind: '$lectures'
            },
            {
                $lookup: {
                    from: 'subjecttables',
                    localField: 'lectures.subject',
                    foreignField: '_id',
                    as: 'subjects'
                }
            },
            {
                $unwind: '$subjects'
            },
            {
                $lookup: {
                    from: 'adminteachertables',
                    localField: 'lectures.teacher',
                    foreignField: '_id',
                    as: 'teachers'
                }
            },
            // {
            //     $unwind : '$subjects'
            // },
            {
                $match: {
                    'lectures.batch': mongoose.Types.ObjectId(id)
                }
            },
            {
                $project: {
                    _id: 1,
                    "userDetails._id": 1,
                    "userDetails.FullName": 1,
                    "userDetails.email": 1,
                    "userDetails.mobileNumber": 1,
                    "lectures._id": 1,
                    "lectures.lecture_title": 1,
                    "lectures.starting_date": 1,
                    "lectures.ending_date": 1,
                    "subjects.title": 1,
                    'teachers': 1,

                    timeSpend: 1,

                }
            }

        ])

        const hashmap = new Map();
        for (let timespend of timeSpends) {
            let time = convertSecondsToTime(timespend?.timeSpend);
            let duration = moment(timespend?.lectures?.ending_date).diff(moment(timespend?.lectures?.starting_date), 'seconds')
            duration = convertSecondsToTime(duration);
            // console.log(timespend);
            // console.log( typeof duration);
            let obj = {
                Name: timespend?.userDetails?.FullName,
                Phone: timespend?.userDetails?.mobileNumber,
                Email: timespend?.userDetails?.email == 'user@gmail.com' ? "NA" : timespend?.userDetails?.email,
                Duration: time,
                lectureName: timespend?.lectures?.lecture_title,
                lectureStartDateTime: timespend?.lectures?.starting_date,
                lectureEndDateTime: timespend?.lectures?.ending_date,
                subject: timespend?.subjects.title ?? "",
                lectureDuration: duration?.includes('NaN') ? "0s" : duration,
                teacherName: timespend?.teachers[0]?.FullName ?? "",
            }
            // timespend?.timeSpend =   (timespend?.timeSpend / 60)
            if (!hashmap.has(timespend?.lectures?.lecture_title)) {
                hashmap.set(timespend?.lectures?.lecture_title, [obj]);
            } else {
                let array = hashmap.get(timespend?.lectures?.lecture_title);
                array.push(obj);
                hashmap.set(timespend?.lectures?.lecture_title, array);
            }

        }
        let response = [...hashmap].map(([name, value]) => ({ lectureName: name, timeSpendOnLecture: value }));
        return res.json({
            status: true,
            // data : timeSpends,
            data: response,
            msg: 'timeSpends feched'
        })
    } catch (error) {
        return res.json({
            status: false,
            data: null,
            msg: error.message
        })
    }
})

AdminPanel.get("/getAllStudentList", isAdmin, async (req, res) => {
    try {
        const decode = jwt.verify(req.token, process.env.ADMIN_SECRET_KEY);
        const admin = await findAdminTeacherUsingUserId(decode?.studentId);
        if (!admin) {
            return res.json({
                status: false,
                data: null,
                msg: 'Not an Admin'
            })
        }
        const students = await UserTable.find({}).sort({ createdAt: -1 }).select("_id enrollId FullName mobileNumber email userId utm_campaign utm_source utm_medium mobileNumberVerified Stream created_at is_active");
        const responseArr = students?.map((item, index) => {
            return {
                serialNumber: index + 1,
                userId: item?.userId ?? "",
                enrollId: item?.enrollId ?? "",
                Name: item?.FullName ?? "",
                Email: item?.email == 'user@gmail.com' ? "NA" : item?.email,
                Phone: item?.mobileNumber ?? "",
                stream: item?.Stream?.reduce((acc, curr) => acc + " " + curr, ""),
                isMobileNumberVerified: item?.mobileNumberVerified == true ? "Verified" : "Not Verified",
                isActive: item?.is_active == true ? "Active" : "Not Active",
                createdAt: item?.created_at ?? "",
                UtmCampaign: item?.utm_campaign ?? "",
                UtmMedium: item?.utm_medium ?? "",
                UtmSource: item?.utm_source ?? "",


            }
        })

        return res.json({
            status: true,
            data: responseArr,
            msg: `All Users Data fetched`
        })
    } catch (error) {
        return res.json({
            status: false,
            data: null,
            msg: error.message
        })
    }
})

AdminPanel.get("/getCouponsForPanel", isAdmin, async (req, res) => {
    const { type } = req.query;
    try {
        let query = {};
        if (type == 'store') {
            query.$or = [
                { link: { $eq: 'product' } },
                { link: { $eq: 'productCategory' } }
            ]
        } else if (type == 'website') {
            query.$or = [
                { link: { $eq: 'batch' } },
                { link: { $eq: 'none' } },
                { link: { $eq: 'testSeries' } }
            ]
        } else {
            query = {}
        }
        // console.log(type)
        const coupons = await couponTable.find(query).populate('user', 'FullName Role').populate('student', '_id FullName mobileNumber').sort({ createdAt: -1 })
        let couponArray = await Promise.all(coupons?.map(async (item) => {
            let link = "none";
            let linkWith = "NA";
            let linkWiths = "NA";
            if (item.link == 'batch') {
                if (item?.linkWith == 'all') {
                    link = item.link ?? "";
                    linkWith = { id: "All", title: "All" };
                    linkWiths = "All";
                } else {
                    const batch = await BatchesTable.findOne({ _id: item?.linkWith }).select('batch_name');
                    const batches = await BatchesTable.find({ _id: { $in: item?.linkWiths } }).select("batch_name");

                    if (!batch) {
                        link = item.link ?? "";
                        linkWith = { id: "NA", title: "NA" };
                        linkWiths = "NA";
                    }
                    link = item.link ?? "";
                    linkWith = { id: batch?._id ?? "NA", title: batch?.batch_name ?? "NA" };
                    linkWiths = batches?.reduce((acc, curr) => acc + curr?.batch_name + ", ", "") ?? "NA"
                }

            }
            else if (item.link == 'category') {
                const batchCategory = await categoryTable.findOne({ _id: item?.linkWith }).select('title');
                const categories = await categoryTable.find({ _id: { $in: item?.linkWiths } }).select("title");

                if (!batchCategory) {
                    link = item.link ?? "";
                    linkWith = { id: "NA", title: "NA" };
                    linkWiths = "NA";
                }

                link = item.link ?? "";
                linkWith = { id: batchCategory?._id ?? "NA", title: batchCategory?.title ?? "NA" };
                linkWiths = categories?.reduce((acc, curr) => acc + curr?.title + ", ", "") ?? "NA"
            } else if (item.link == 'testSeries') {
                const allTestSeries = await TestSeriesTable.find({ _id: { $in: item?.linkWiths } }).select('testseries_name');
                const testSeries = await TestSeriesTable.findOne({ _id: item?.linkWiths }).select('testseries_name');

                if (testSeries) {
                    link = item.link ?? ""
                    linkWith = { id: "NA", title: "NA" }
                    linkWiths = "NA";
                }
                link = item.link ?? "";
                linkWith = { id: testSeries?._id ?? "NA", title: testSeries?.testseries_name ?? "NA" };
                linkWiths = allTestSeries?.reduce((acc, curr) => acc + curr?.testseries_name + ", ", "") ?? "NA"

            } else if (item.link == 'product') {
                if (item.linkWith == 'all') {
                    link = item.link ?? "";
                    linkWith = { id: "All", title: "All" };
                    linkWiths = "All"
                } else {
                    const products = await storeProductTable.find({ _id: { $in: item.linkWiths } }).select('title');
                    const product = await storeProductTable.findOne({ _id: item.linkWith }).select('title');

                    if (!product) {
                        link = item.link ?? "";
                        linkWith = { id: "NA", title: "NA" };

                    }
                    link = item.link ?? "";
                    linkWith = { id: product?._id ?? "NA", title: product?.title ?? "NA" };
                    linkWiths = products?.reduce((acc, curr) => acc + curr?.title + ", ", "") ?? "NA"

                }

            } else if (item.link == 'productCategory') {
                const productCategories = await productCategoryTable.find({ _id: { $in: item?.linkWiths } }).select('title');
                const productCategory = await productCategoryTable.find({ _id: item?.linkWiths }).select('title');

                if (!productCategory) {
                    link = item.link ?? "";
                    linkWith = { id: "NA", title: "NA" };
                }

                link = item.link ?? "";
                linkWith = { id: productCategory?._id ?? "NA", title: productCategory?.title ?? "NA" };
                linkWiths = productCategories?.reduce((acc, curr) => acc + curr?.title + ", ", "") ?? "NA"

            }
            else {

                link = item.link ?? "";
                linkWith = { id: "NA", title: "NA" };
            }
            return {
                id: item?._id,
                couponId: item?._id,
                createdBy: { name: item?.user?.FullName, role: item?.user?.Role },
                couponCode: item?.couponCode,
                couponType: item?.couponType,
                link,
                linkWith,
                linkWiths,
                couponValue: item?.couponValue,
                expirationDate: moment(item?.expirationDate).format('DD-MM-YYYY HH:mm:ss'),
                couponAccess: item?.couponAccess,
                is_active: item?.is_active,
                count: item?.student ? item?.count : "Unlimited",
                student: { name: item?.student?.FullName ?? "NA", phone: item?.student?.mobileNumber ?? "" },
                created_at: moment(item?.createdAt).format("DD-MM-YYYY HH:mm:ss"),
                updated_at: item?.updatedAt,
            }
        }))


        return res.json({
            status: true,
            data: couponArray,
            msg: "All Coupon Fetched"
        })

    } catch (error) {
        return res.json({
            status: false,
            data: null,
            msg: error.message
        })
    }
})


AdminPanel.get("/getPaidStudentOfBatch/:batchId", isAdmin, async (req, res) => {
    const { batchId } = req.params;
    if (!batchId) {
        return res.json({
            status: false,
            data: null,
            msg: 'Required BatchId'
        })
    }
    try {
        const decode = jwt.verify(req.token, process.env.SECRET_KEY);
        const admin = await findAdminTeacherUsingUserId(decode?.studentId);
        if (!admin) {
            return res.json({
                status: false,
                data: null,
                msg: 'Not An Admin'
            })
        }

        const batches = await MybatchTable.find({ batch_id: batchId }).populate('batch_id', '_id batch_name').populate('validity', 'month salePrice regularPrice').populate('user', "_id FullName email username userId mobileNumber profilePhoto");
        let responseArr = await Promise.all(batches.map(async (item, index) => {
            let invoice = "";
            let paymentDetails = {};
            let couponDetails = {
                code: 'NA',
                value: "NA",
                type: "NA"
            };
            // find coursePaymentTxn 
            // 1 -> first get courseOrder for userId and batchId 
            const courseOrder = await courseOrdesTable.findOne({ user: item?.user?._id, courseId: item?.batch_id?._id, isPaid: true }).select('_id txnId totalAmount invoice couponId').populate('couponId', "_id couponCode couponValue couponType").sort({ createdAt: -1 });
            // then get paument txn 
            if (courseOrder?._id) {
                // let paymentTxn = await courseTxnTable.findOne({ user : item?.user?._id , t })
                // console.log(courseOrder?._id)
                // console.log(courseOrder?.invoice)
                invoice = courseOrder?.invoice ?? [];
                paymentDetails = {
                    txnId: courseOrder?.txnId,
                    totalAmount: courseOrder?.totalAmount,
                    assignedAt: moment(item?.assignedDate).add(5, 'hours').add(30, 'minutes').format('DD-MM-YYYY HH:mm:ss')
                }
                couponDetails = {
                    code: courseOrder?.couponId?.couponCode ?? 'NA',
                    value: courseOrder?.couponId?.couponValue ?? "NA",
                    type: courseOrder?.couponId?.couponType ?? "NA"
                }
            }
            // app transaction table 
            // 1 - get transaction -- for userId and batchName 
            let appPayment = await paymentTransactionTable.findOne({ user: item?.user?._id, batch_name: item?.batch_id?.batch_name, success: true }).select('_id payment_id amount invoice couponId remark').populate('couponId', '_id couponCode couponValue couponType').sort({ createdAt: -1 });
            if (appPayment) {
                invoice = appPayment?.invoice ?? [];
                paymentDetails = {
                    txnId: appPayment?.payment_id,
                    totalAmount: appPayment?.amount,
                    remark: appPayment?.remark ?? "",
                    assignedAt: moment(item?.assignedDate).add(5, 'hours').add(30, 'minutes').format('DD-MM-YYYY HH:mm:ss')
                };
                couponDetails = {
                    code: appPayment?.couponId?.couponCode ?? 'NA',
                    value: appPayment?.couponId?.couponValue ?? "NA",
                    type: appPayment?.couponId?.couponType ?? "NA"
                }
            }
            return {
                sNo: index + 1,
                id: item?._id ?? "",
                user_id: item?.user?._id ?? "",
                batchId: item?.batch_id?._id,
                batchName: item?.batch_id?.batch_name,
                mobileNumber: item?.user?.mobileNumber ?? "",
                invoice,
                namePhoto: { name: item?.user?.FullName ?? "", profilePhoto: item?.user?.profilePhoto ?? "" },
                username: item?.user?.username ?? "",
                userId: item?.user?.userId ?? "",
                email: item?.user?.email ?? "",
                isEmi: item?.isEmi ?? "",
                validity: item?.validity?.month ?? "NA",
                validityExpire: item?.validity?.month ? moment(item?.assignedDate).add(item?.validity?.month, 'months').format('DD-MM-YYYY') : "NA",
                nextInstallmentDate: item?.isEmi ? moment(item?.nextInstallmentDate).format('DD-MM-YYYY') : "NA",
                pendingInstallment: item?.pendingInstallment ?? "",
                is_active: item?.is_active,
                ...paymentDetails,
                couponDetails
            }
        }))

        return res.json({
            status: true,
            data: responseArr,
            msg: 'Batch Student fetched'
        })

    } catch (error) {
        return res.json({
            status: false,
            data: null,
            msg: error.message
        })
    }
})

AdminPanel.get("/getAllInvoice/:batchId/:studentId", isAdmin, async (req, res) => {
    const { batchId, studentId } = req.params;
    if (!batchId || !studentId) {
        return res.json({
            status: false,
            data: null,
            msg: 'Required BatchId and StudentId'
        })
    }
    try {
        const decode = jwt.verify(req.token, process.env.SECRET_KEY);
        const admin = await findAdminTeacherUsingUserId(decode?.studentId);
        if (!admin) {
            return res.json({
                status: false,
                data: null,
                msg: 'Not An Admin'
            })
        }

        const batches = await MybatchTable.findOne({ batch_id: batchId, user: studentId }).populate('batch_id', '_id batch_name').populate('validity', 'month salePrice regularPrice').populate('user', "_id FullName email username userId mobileNumber profilePhoto");
        let appPayment = await paymentTransactionTable.find({ user: studentId, batch_name: batches?.batch_id?.batch_name, success: true }).select('_id payment_id amount invoice couponId remark name email mobileNumber batch_name').populate('couponId', '_id couponCode couponValue couponType').populate('validity').sort({ createdAt: -1 });

        return res.json({
            status: true,
            data: appPayment,
            msg: 'All Invoice Details fetched'
        })

    } catch (error) {
        return res.json({
            status: false,
            data: null,
            msg: error.message
        })
    }
})

AdminPanel.get("/getCourseOrder", isAdmin, async (req, res) => {
    const { batchId, userId } = req.query;
    if (!batchId || !userId) {
        return res.json({
            status: false,
            data: null,
            msg: 'Required BatchId & userId'
        })
    }
    try {
        const decode = jwt.verify(req.token, process.env.ADMIN_SECRET_KEY);
        const admin = await findAdminTeacherUsingUserId(decode?.studentId);
        if (!admin) {
            return res.json({
                status: false,
                data: null,
                msg: 'Not an Admin'
            })
        }
        const courseOrder = await courseOrdesTable.findOne({ courseId: batchId, user: userId }).select("_id totalAmount noOfInstallments isEmi pendingInstallment pendingAmount eachInstallmentAmount nextInstallmentDate");
        return res.json({
            status: true,
            data: {
                nextInstallmentDate: moment(courseOrder?.nextInstallmentDate).format('DD-MM-YYYY') ?? "",
                eachInstallmentAmount: courseOrder?.eachInstallmentAmount ?? "",
                pendingAmount: courseOrder?.pendingAmount ?? "",
                pendingInstallment: courseOrder?.pendingInstallment ?? "",
                noOfInstallments: courseOrder?.noOfInstallments ?? "",
                isEmi: courseOrder?.noOfInstallments ?? "",
                totalAmount: courseOrder?.totalAmount ?? "",
                courseOrderId: courseOrder?._id ?? "",

            },
            msg: 'Emi Details Fetched'
        })

    } catch (error) {
        return res.json({
            status: false,
            data: null,
            msg: error.message
        })
    }
})

AdminPanel.get("/getLectureByName", isAdmin, async (req, res) => {
    let { commonName } = req.query;
    if (!commonName) {
        return res.json({
            status: false,
            data: null,
            msg: `Required common name`
        })
    }
    try {
        const decode = jwt.verify(req.token, process.env.ADMIN_SECRET_KEY);
        const admin = await findAdminTeacherUsingUserId(decode.studentId);
        if (!admin) {
            return res.json({
                status: false,
                data: null,
                msg: "Not an Admin"
            })
        }
        // console.log(commonName)
        const lect = await LectureTable.find({ commonName: commonName }).populate('batch', '_id batch_name');
        // console.log(lect.length)
        let response = [];

        for (let lecture of lect) {
            const rooms = await lectureRoomTable.find({ lecture: lecture?._id }).populate("mentor", "_id FullName");
            // console.log(rooms?.length)
            let obj = {
                lectureId: lecture?._id ?? "",
                lectureTitle: lecture?.lecture_title ?? "",
                batchId: lecture?.batch?._id,
                batchName: lecture?.batch?.batch_name ?? "",
                description: lecture?.description ?? "",
                dpp: lecture?.dpp ?? {},
                starting_date: lecture?.starting_date ?? "",
                ending_date: lecture?.ending_date ?? "",
                material: lecture?.material ?? {},
                rooms: rooms?.map((item) => {
                    // console.log(item?.mentor)
                    return {
                        roomId: item?._id,
                        mentor: item?.mentor?.map((item2) => { return { mentorName: item2?.FullName ?? "", mentorId: item2?._id ?? "" } }),
                        students: item?.students ?? [],
                        roomSize: 2,
                        roomName: item?.title ?? ""
                    }
                })
            }
            response.push(obj);
        }
        // console.log(lect)
        // const lectures = await LectureTable.aggregate([
        //   { $match :  { commonName : commonName}},
        //   {
        //     $lookup : {
        //       from : 'batchestables',
        //       localField : 'batch',
        //       foreignField : "_id",
        //       as : 'batch'
        //     }
        //   },
        //   {
        //     $unwind : "$batch"
        //   },
        //   {
        //     $lookup : {
        //       from : 'lectureroomtables',
        //       localField : '_id',
        //       foreignField : "lectureId",
        //       as : 'rooms'
        //     }
        //   },
        //   //  {
        //   //     $project : {
        //   //       _id :  1 ,
        //   //       lecture_title : 1 ,
        //   //       '$batch.batch_name' : 1 ,
        //   //       rooms : 1,

        //   //     }

        //   //  }
        // ])
        // const response  = lectures?.map((item) => {
        //   return {
        //     lectureId :  item?._id ,
        //     batchName :  item?.batch_name ?? "",
        //     lectureName : item?.lecture_title ?? "",
        //     rooms : item?.rooms?.map((item2) => {
        //       return { 
        //         roomId :  item2?._id ?? "",
        //         mentor : item?.mentor?._id ??
        //       }
        //     })
        //   }
        // })
        return res.json({
            status: true,
            data: response,
            msg: " lectures with room"
        })

    } catch (error) {
        return res.json({
            status: false,
            data: null,
            msg: error.message
        })
    }
})

AdminPanel.get("/getlogs", isAdmin, async (req, res) => {
    try {
        const decode = jwt.verify(req.token, process.env.ADMIN_SECRET_KEY);
        const admin = await findAdminTeacherUsingUserId(decode?.studentId);
        if (!admin) {
            return res.json({
                status: false,
                data: null,
                msg: 'Not an Admin'
            })
        }
        const logs = await logsTables.find({}).sort({ createdAt: -1 }).populate('admin', "_id FullName Role");
        let response = logs?.map((item, index) => {
            // console.log(item?.admin)
            let event = item?.event.replace(/([A-Z])/g, " $1")
            event = event.charAt(0).toUpperCase() + event.slice(1);
            let action = item?.action.replace(/([A-Z])/g, " $1")
            action = action.charAt(0).toUpperCase() + action.slice(1);
            return {
                sNo: index + 1,
                id: item?._id,
                event: event,
                action: action,
                admin: { name: item?.admin?.FullName ?? "", role: item?.admin?.Role ?? "" },
                data: item?.data[0],
                createdAt: moment(item?.createdAt).format('DD-MM-YYYY HH:mm:ss')
            }
        })

        return res.json({
            status: false,
            data: response,
            msg: `All Logs`
        })

    } catch (error) {
        return res.json({
            status: false,
            data: null,
            msg: error.message
        })
    }
})


AdminPanel.get("/getTeacherList", isAdmin, async (req, res) => {
    try {
        const decode = jwt.verify(req.token, process.env.ADMIN_SECRET_KEY);
        const admin = await findAdminTeacherUsingUserId(decode?.studentId);
        if (!admin) {
            return res.json({
                status: false,
                data: null,
                msg: 'Not an Admin'
            })
        }

        const teachers = await adminTeacherTable.find({ Role: 'teacher', isActive: true }).populate('subject', '_id title').select("_id FullName profilePhoto Role").sort({ createdAt: -1 });
        return res.json({
            status: true,
            data: teachers?.map((item) => {
                return {
                    id: item?._id ?? "",
                    name: item?.FullName ?? "",
                    role: item?.Role ?? "",
                    profile: item?.profilePhoto ?? "",
                    subject: item?.subject ?? [],
                }
            }),
            msg: 'Teacher List'
        })
    } catch (error) {
        return res.json({
            status: false,
            data: null,
            msg: error.message
        })
    }
})

AdminPanel.get("/getTeacherLectureList", isAdmin, async (req, res) => {
    const { teacherId } = req.query;
    if (!teacherId) {
        return res.json({
            status: false,
            data: null,
            msg: 'Required teacherId'
        })
    }
    try {
        const decode = jwt.verify(req.token, process.env.ADMIN_SECRET_KEY);
        const admin = await findAdminTeacherUsingUserId(decode?.studentId);
        if (!admin) {
            return res.json({
                status: false,
                data: null,
                msg: 'Not an Admin'
            })
        }
        let date = new Date();
        let end = new Date(date.getUTCFullYear(), date.getUTCMonth(), date.getUTCDate(), 28, 89, 59, 59)
        let start = new Date(date.getUTCFullYear(), date.getUTCMonth(), date.getUTCDate(), 5, 30, 0, 0)
        const lectures = await LectureTable.find({ teacher: { $in: teacherId }, startingDate: { $gte: start, $lte: end }, isActive: true }).sort({ createdAt: -1 }).populate({
            path: 'teacher',
            select: "FullName profilePhoto demoVideo category qualification",
            populate: {
                path: 'subject',
                select: 'title'
            }
        }).populate('batch', '_id batch_name slug');

        // let responseArray = [] ;
        // let currentDate = moment(new Date()).format('DD-MM-YYYY');
        // let todayLecture = lectures.filter((item) => {
        //     let startDate = moment(item?.starting_date, 'DD-MM-YYYY HH:mm:ss').format('DD-MM-YYYY');
        //     let endDate = moment(item?.ending_date, 'DD-MM-YYYY HH:mm:ss').format('DD-MM-YYYY');
        //     return moment(currentDate, 'DD-MM-YYYY').isSame(moment(startDate, 'DD-MM-YYYY'));
        // });

        return res.json({
            status: true,
            data: await Promise.all(lectures?.map(async (item) => {
                const rooms = await lectureRoomTable.find({ lecture: item?._id }).populate('batch', 'batch_name').populate('mentor', '_id FullName');

                return {
                    id: item?._id ?? "",
                    // _id: item?._id ?? "",
                    commonName: item?.commonName ?? "",
                    lectureType: item?.lecture_type ?? "YT",
                    lectureTitle: item?.lecture_title ?? "",
                    teacher: { name: item?.teacher[0]?.FullName ?? "", profilePhoto: item?.teacher[0]?.profilePhoto ?? "", qualification: item?.teacher[0]?.qualification ?? "" } ?? { name: "", profilePhoto: "", qualification: "" },
                    starting_date: item?.starting_date ?? "",
                    batchDetails: { id: item?.batch?._id, batchName: item?.batch?.batch_name ?? "", slug: item?.batch?.slug ?? "" },
                    batchSlug: item?.batch?.slug ?? "",
                    duration: moment(item?.ending_date, 'DD-MM-YYYY HH:mm:ss').diff(moment(item?.starting_date, 'DD-MM-YYYY HH:mm:ss'), 'minutes'),
                    language: item?.language ?? "",
                    ending_date: item?.ending_date ?? "",
                    material: item?.material ?? {},
                    dpp: item?.dpp ?? {},
                    description: item?.description ?? "",
                    rooms: rooms?.map((item2) => {
                        return {
                            id: item2?._id ?? "",
                            roomName: item2?.title ?? "",
                            mentor: item2?.mentor?.map((item3) => {
                                return {
                                    mentorId: item3?._id ?? "",
                                    mentorName: item3?.FullName ?? "",
                                }
                            }),
                            batchName: item2?.batch?.batch_name ?? "",
                            students: item2?.students ?? [],
                        }
                    })
                }
            })),
            msg: 'Teacher today lectures'
        })

    } catch (error) {
        return res.json({
            status: false,
            data: null,
            msg: error.message
        })
    }
})

// AdminPanel.post("/markAttendence" , ValidateToken , async(req , res) => {
AdminPanel.post("/markAttendence", async (req, res) => {
    const { lectureId, userId } = req.body;
    try {
        let user = { _id: userId }
        // const decode  = jwt.verify(req.token , process.env.SECRET_KEY) ;
        // const user =  await findUserByUserId(decode?.studentId);
        // if( !user){
        //     return res.json({
        //         status : false ,
        //         data : null ,
        //         msg :  `Not an user`
        //     })
        // }
        const userRoom = await lectureRoomTable.findOne({ lecture: lectureId, students: { $in: user?._id } }).select('_id title');

        const isExist = await timeSpendOnLecture.findOne({ lecture: lectureId, roomId: userRoom?._id, user: user?._id });
        if (isExist) {
            // console.log( 'old one')
            let currentDate = new Date();
            let diffence = Math.floor((currentDate.getTime() - isExist?.attainAt.getTime()) / 1000);
            // console.log(isExist?._id)
            await timeSpendOnLecture.findByIdAndUpdate(isExist?._id, { timeSpend: diffence, attainAt: currentDate });
        } else {
            // consolr.log('new One')
            const newAttendence = new timeSpendOnLecture({
                user: user?._id,
                lecture: lectureId,
                roomId: userRoom?._id,
                timeSpend: 0,
            });
            await newAttendence.save();
        }

        return res.json({
            status: true,
            data: null,
            msg: 'Attendence Marked'
        })

    } catch (error) {
        return res.json({
            status: false,
            data: null,
            msg: error.message
        })
    }
})

AdminPanel.post("/getTimeSpendByMultipleLecture", async (req, res) => {
    const { lectureIds } = req.body;
    if (lectureIds?.length <= 0) {
        return res.json({
            status: false,
            data: null,
            msg: `Lecture Ids not Found`
        })
    }
    try {
        let timeSpends = await timeSpendOnLecture.find({ lecture: lectureIds }).populate("user", "_id FullName email mobileNumber").populate({
            path: 'lecture',
            select: "_id batch lecture_title starting_date ending_date",
            populate: {
                path: "teacher",
                select: "FullName Role"
            },
            populate: {
                path: 'batch',
                select: '_id batch_name'
            }
        }).populate('roomId', "title");
        // console.log( timeSpends?.length );
        const hashmap = new Map();
        for (let timespend of timeSpends) {
            // console.log( timespend);
            // console.log(   `count`)
            let time = convertSecondsToTime(timespend?.timeSpend);
            // let duration = moment(timespend?.lecture?.ending_date).diff(moment(timespend?.lecture?.starting_date), 'seconds')
            // duration = convertSecondsToTime(duration);

            let obj = {
                Name: timespend?.user?.FullName,
                Phone: timespend?.user?.mobileNumber,
                Email: timespend?.user?.email == 'user@gmail.com' ? "NA" : timespend?.user?.email,
                Duration: time,
                lectureName: timespend?.lecture?.lecture_title,
                batchName: timespend?.lecture?.batch?.batch_name,
                lectureStartDateTime: timespend?.lecture?.starting_date,
                lectureEndDateTime: timespend?.lecture?.ending_date,
                // lectureDuration: duration
            }
            // timespend?.timeSpend =   (timespend?.timeSpend / 60)
            if (!hashmap.has(timespend?.lecture?._id)) {
                hashmap.set(timespend?.lecture?._id, [obj]);
            } else {
                let array = hashmap.get(timespend?.lecture?._id);
                array.push(obj);
                hashmap.set(timespend?.lecture?._id, array);
            }

        }
        // console.log(hashmap)
        let response = [...hashmap].map(([name, value]) => ({ lectureId: name, timeSpendOnLecture: value }));
        return res.json({
            status: true,
            // data : timeSpends,
            data: response,
            msg: 'timeSpends feched'
        })


    } catch (error) {
        return res.json({
            status: false,
            data: null,
            msg: error.message || 'Lecture analytics not fetched'
        })
    }
})

AdminPanel.get('/getLectureRoom', isAdmin, async (req, res) => {
    const { lectureId } = req.query;
    if (!lectureId) {
        return res.json({
            status: false,
            data: null,
            msg: `Required lectureId`
        })
    }
    try {
        const decode = jwt.verify(req.token, process.env.ADMIN_SECRET_KEY);
        const admin = await findAdminTeacherUsingUserId(decode?.studentId);
        if (!admin) {
            return res.json({
                status: false,
                data: null,
                msg: 'Not an admin'
            })
        }
        const rooms = await lectureRoomTable.find({ lecture: lectureId }).populate('lecture', '_id lecture_title').populate('batch', 'batch_name').populate('mentor', '_id FullName profilePhoto');
        return res.json({
            status: true,
            data: rooms?.map((item2, index) => {
                return {
                    sno: index + 1,
                    id: item2?._id ?? "",
                    roomName: item2?.title ?? "",
                    lectureId: item2?.lecture?._id ?? "",
                    lectureName: item2?.lecture?.lecture_title ?? "",
                    mentor: item2?.mentor?.map((item3) => {
                        return {
                            mentorId: item3?._id ?? "",
                            mentorName: item3?.FullName ?? "",
                            profilePhoto: item3?.profilePhoto ?? "",
                            value: item3?._id,
                            label: item3?.FullName,
                        }
                    }),
                    batchName: item2?.batch?.batch_name ?? "",
                    students: item2?.students ?? [],
                }
            }),
            msg: 'Rooms fetched'
        })
    } catch (error) {
        return res.json({
            status: false,
            data: null,
            msg: error.message
        })
    }
})

AdminPanel.get("/getTodayClasses", ValidateToken, async (req, res) => {
    try {
        const decode = jwt.verify(req.token, process.env.SECRET_KEY);
        const user = await findUserByUserId(decode?.studentId);
        if (!user) {
            return res.json({
                status: false,
                data: null,
                msg: 'Not an User'
            })
        }
        const getMyBatches = await MybatchTable.find({ user: user?._id , is_active: true }).select('_id batch_id');
        let batchIds = getMyBatches?.map((item) => { return item?.batch_id });
        // const lectures = await LectureTable.find({ batch: batchIds }).populate({
        //     path: 'teacher',
        //     select: '_id FullName qualification profilePhoto demoVideo',
        //     populate: {
        //         path: 'subject',
        //         // select : "title"
        //     }
        // }).populate("batch", '_id batch_name slug').populate('subject');
        // let date = moment().format('DD-MM')
        let date = new Date();
        let end = new Date(date.getUTCFullYear(), date.getUTCMonth(), date.getUTCDate(), 28, 89, 59, 59)
        let start = new Date(date.getUTCFullYear(), date.getUTCMonth(), date.getUTCDate(), 5, 30, 0, 0)
        // console.warn( start , end)
        // let todayLecture = lectures.filter((item) => {
        //     let startDate = moment(item?.starting_date, 'DD-MM-YYYY HH:mm:ss').format('DD-MM-YYYY');
        //     let endDate = moment(item?.ending_date, 'DD-MM-YYYY HH:mm:ss').format('DD-MM-YYYY');
        //     return moment(currentDate, 'DD-MM-YYYY').isSame(moment(startDate, 'DD-MM-YYYY'));
        // });

        let todayLecture = await LectureTable.find({ batch: batchIds, startingDate: { $gte: start, $lte: end }, isActive: true }).populate({
            path: 'teacher',
            select: '_id FullName qualification profilePhoto demoVideo',
            populate: {
                path: 'subject',
                // select : "title"
            }
        }).populate("batch", '_id batch_name slug').populate('subject').sort({ startingDate: 1 })
        return res.json({
            status: true,
            data: await Promise.all(todayLecture?.map(async (lecture) => {
                // const rooms = await lectureRoomTable.find({ lecture : item?._id , user :  user?._id }).populate('batch' , 'batch_name').populate('mentor' , '_id FullName');
                const userRoom = await lectureRoomTable.findOne({ lecture: lecture?._id, students: { $in: user?._id } }).populate('batch', 'batch_name').populate("mentor", "_id FullName").select('_id title mentor');

                // let rooms = await lectureRoomTable.find({ lecture: lecture?._id }).select('students title _id');
                return {
                    ...lecture?._doc,
                    batch: lecture?._doc?.batch?._id ?? "",
                    batchDetails: { id: lecture?._doc?.batch?._id, batchName: lecture?._doc?.batch?.batch_name, slug: lecture?._doc?.batch?.slug, batchSlug: lecture?.batch?.slug ?? "" } ?? { id: "", batchName: "", slug: "" },
                    commonName: lecture?._doc?.commonName ?? "",
                    teacher: lecture?.teacher[0],
                    ending_time: moment(lecture?.ending_date, 'DD-MM-YYYY HH:mm:ss').format('HH:mm A'),
                    starting_time: moment(lecture?.starting_date, 'DD-MM-YYYY HH:mm:ss').format('HH:mm A'),
                    banner: lecture?.banner != "" ? lecture?.banner : "https://static.sdcampus.com/assets/lecture_default_1732539568.jpg",
                    socketUrl: lecture?.socketUrl ?? "https://twoway-backend-prod.sdcampus.com/mediasoup",
                    roomDetails: { id: userRoom?._id ?? "", title: userRoom?.title ?? "", batchName: userRoom?.batch?.batch_name ?? "", mentor: userRoom?.mentor?.map((item2) => { return { mentorId: item2?._id ?? "", mentorName: item2?.FullName ?? "" } }) } ?? []
                }
            })),
            msg: 'Today lectures'
        })



    } catch (error) {
        return res.json({
            status: false,
            data: null,
            msg: error.message
        })
    }
})


AdminPanel.post("/assignMentors", isAdmin, async (req, res) => {
    const { mentors, roomId, lectureId } = req.body;
    if (!roomId || !lectureId || mentors?.length <= 0) {
        return res.json({
            status: false,
            data: null,
            msg: "Required mentors roomId lectureId"
        })
    }
    try {
        const decode = jwt.verify(req.token, process.env.ADMIN_SECRET_KEY);
        const admin = await findAdminTeacherUsingUserId(decode?.studentId);
        if (!admin) {
            return res.json({
                status: false,
                data: null,
                msg: 'Not an Admin'
            })
        }
        const isExist = await lectureRoomTable.findOne({ _id: roomId });
        if (!isExist) {
            return res.json({
                status: false,
                data: null,
                msg: ' Room not exist'
            })
        }
        let allMentors = [...isExist?.mentor, ...mentors]?.map((item) => { return item?.toString() });
        let uniqueMentors = [...new Set(allMentors)];
        // console.log(uniqueFaqs);
        const newRooms = await lectureRoomTable.findByIdAndUpdate(roomId, { mentor: uniqueMentors }, { new: true, lean: true })
        return res.json({
            status: true,
            data: null,
            msg: 'Mentor Assign this room'
        })

    } catch (error) {
        return res.json({
            status: false,
            data: null,
            msg: error.message
        })
    }
})


AdminPanel.get("/genrateInVoice", async (req, res) => {
    let { page, pageSize } = req.query;
    try {
        // const decode = jwt.verify(req.token, process.env.ADMIN_SECRET_KEY);
        // const admin = await findAdminTeacherUsingUserId(decode?.studentId);
        // if (!admin) {
        //     return res.json({
        //         status: false,
        //         data: null,
        //         msg: 'Not An Admin'
        //     })
        // }
        let successCount = 0;
        let successDocument = [];
        let appSuccesDocument = [];
        let webSiteSuccessDocument = [];
        let failureCount = 0;
        let failureArray = [];
        let date = new Date('2024-06-01T00:00:00.000+00:00').toISOString()
        let currDate = new Date().toISOString();
        // page = parseInt(page) ||  1 ;
        // pageSize = parseInt(pageSize) || 50 ; 
        // console.log( date , currDate);
        // const myBatches = await MybatchTable.find({ createdAt: { $gt: date, $lt: currDate } }).populate('user', '_id FullName email mobileNumber Address').populate('batch_id', '_id batch_name').sort({ createdAt: 1 }).skip((page - 1) * pageSize).limit(pageSize);
        const myBatches = await MybatchTable.find({ createdAt: { $gt: date, $lt: currDate }, amount: { $gt: 0 } }).populate('user', '_id FullName email mobileNumber Address').populate('batch_id', '_id batch_name').sort({ createdAt: 1 });

        console.log(myBatches.length);

        for (let i = 0; i < myBatches?.length; i++) {
            let invoiceLocation = "website";
            // console.log( 'running....')
            const isApp = await paymentTransactionTable.findOne({ user: myBatches[i]?.user?._id, batch_name: myBatches[i]?.batch_id?.batch_name });
            if (isApp) {
                invoiceLocation = 'app';
            }
            if (invoiceLocation == 'app') {
                // let invoiceNumber =  'NA' ;
                // if( parseInt(myBatches[i]?.amount) != 0 ){
                let latestInvoice = await invoiceTable.find({}).sort({ createdAt: -1 }).limit(1);
                invoiceNumber = parseInt(latestInvoice[0]?.invoiceNumber ?? 0) + 1;
                // }

                let addressArray = myBatches[i]?.user?.Address?.split(',');
                let isState = addressArray[addressArray?.length - 2] ?? "";
                let state = isState != "" ? isState?.trim() : "Uttar Pradesh";
                let year = `${moment().format('YY')}-${parseInt(moment().format('YY')) + 1}`
                const dataForInvoice = {
                    invoiceNumber: `${year}/${invoiceNumber}`,
                    invoiceDate: moment().format("DD-MM-YYYY"),
                    studentName: myBatches[i]?.user?.FullName ?? "NA",
                    studentAddress: myBatches[i]?.user?.Address ?? "Uttar Pradesh",
                    SDAddress: `Plot No-16, Block 7, Sector 5, Rajendra Nagar, Ghaziabad,Uttar Pradesh, 201005`,
                    items: [{ name: myBatches[i]?.batch_id?.batch_name ?? "NA", price: parseInt(isApp?.amount) ?? 0, quantity: 1 }],
                    studentEmail: myBatches[i]?.user?.email != 'user@gmail.com' ? myBatches[i]?.user?.email : 'NA',
                    studentPhone: myBatches[i]?.user?.mobileNumber,
                    studentState: state,
                    gstNumber: parseInt(myBatches[i]?.amount) > 0 ? "09ABBCS1440F1ZN" : "NA"
                }
                // if (isApp?.invoice?.length == 0) {
                const FileUploadLocation = await pdfGenerate(dataForInvoice);
                const pdfFilePath = path.join(__dirname, '../', FileUploadLocation);
                let fileName = path.basename(pdfFilePath, path.extname(pdfFilePath));
                let ext = path.extname(pdfFilePath)
                let fileLoc = ''
                const helperString = Math.floor(Date.now() / 1000);
                let FileUploadLocation2 = `invoice/invoice/${fileName}_${helperString}${ext}`;
                await new Promise(resolve => {
                    setTimeout(async () => {
                        fileLoc = await uploadFile(pdfFilePath, FileUploadLocation2);
                        const newpayment1 = await paymentTransactionTable.findByIdAndUpdate(isApp?._id, { invoice: [{ installmentNumber: "1", fileUrl: fileLoc }] }, { new: true, lean: true })
                        // console.log(newpayment1);
                        console.log(" via app", fileLoc);
                        if (newpayment1?.invoice?.length >= 1 && newpayment1?.invoice[0]?.fileUrl != '') {
                            successCount++;
                            successDocument.push(newpayment1);
                            appSuccesDocument.push(newpayment1);
                            const newInvoice = new invoiceTable({
                                invoiceNumber: invoiceNumber,
                            })
                            await newInvoice.save();
                        } else {
                            failureCount++;
                            let obj = {
                                myBatchId: myBatches[i]?._id,
                                user: myBatches[i]?.user,
                                batch: myBatches[i]?.batch_id,
                            }
                            failureArray.push(obj);
                        }
                        resolve();
                    }, 200)
                }
                )


                // }

            } else {
                let courseOrder = await courseOrdesTable.findOne({ courseId: myBatches[i]?.batch_id?._id, user: myBatches[i]?.user?._id, isPaid: true });
                if (courseOrder?.isEmi == true) {
                    let searchInvoiceArray = courseOrder?.invoice?.map((item) => { return item?.installmentNumber })
                    const emiTransaction = await emiTxnTable.find({ courseOrderId: courseOrder?._id, isPaid: true })
                    for (let i = 0; i < emiTransaction?.length; i++) {
                        // if (!searchInvoiceArray.includes(emiTransaction[i]?.installmentNumber)) {
                        let latestInvoice = await invoiceTable.find({}).sort({ createdAt: -1 }).limit(1);
                        let invoiceNumber = parseInt(latestInvoice[0]?.invoiceNumber ?? 0) + 1;
                        let addressArray = myBatches[i]?.user?.Address?.split(',');
                        let isState = addressArray[addressArray?.length - 2] ?? "";
                        let state = isState != "" ? isState?.trim() : "Uttar Pradesh";
                        let year = `${moment().format('YY')}-${parseInt(moment().format('YY')) + 1}`
                        const dataForInvoice = {
                            invoiceNumber: `${year}/${invoiceNumber}`,
                            invoiceDate: moment().format("DD-MM-YYYY"),
                            studentName: myBatches[i]?.user?.FullName ?? "NA",
                            studentAddress: myBatches[i]?.user?.Address ?? "Uttar Pradesh",
                            SDAddress: `Plot No-16, Block 7, Sector 5, Rajendra Nagar, Ghaziabad,Uttar Pradesh, 201005`,
                            items: [{ name: myBatches[i]?.batch_id?.batch_name ?? "NA", price: parseInt(courseOrder?.totalAmount) ?? 0, quantity: 1 }],
                            studentEmail: myBatches[i]?.user?.email != 'user@gmail.com' ? myBatches[i]?.user?.email : 'NA',
                            studentPhone: myBatches[i]?.user?.mobileNumber,
                            studentState: state,
                            gstNumber: "09ABBCS1440F1ZN"
                        }
                        const FileUploadLocation = await pdfGenerate(dataForInvoice);
                        const pdfFilePath = path.join(__dirname, '../', FileUploadLocation);
                        let fileName = path.basename(pdfFilePath, path.extname(pdfFilePath));
                        let ext = path.extname(pdfFilePath)

                        let fileLoc = ''
                        const helperString = Math.floor(Date.now() / 1000);
                        let FileUploadLocation2 = `invoice/invoice/${fileName}_${helperString}${ext}`;
                        await new Promise(resolve => {
                            setTimeout(async () => {
                                fileLoc = await uploadFile(pdfFilePath, FileUploadLocation2);
                                let newpayment2 = await courseOrder.findByIdAndUpdate(courseOrder?._id, { invoice: { $each: [{ installmentNumber: emiTransaction[i]?.installmentNumber, fileUrl: fileLoc }] } }, { new: true, lean: true });
                                // console.log('courseOrder EMi ' + newpayment2);
                                console.log("via EMi", fileLoc);

                                searchInvoiceArray = newpayment2?.invoice?.map((item) => { return item?.installmentNumber });
                                let filterInvoiceObject = newpayment2?.invoice?.filter((item) => { return item?.installmentNumber == emiTransaction[i]?.installmentNumber })
                                if (searchInvoiceArray?.includes(emiTransaction[i]?.installmentNumber) && filterInvoiceObject?.fileUrl != "") {
                                    successCount++;
                                    successDocument.push(newpayment2);
                                    webSiteSuccessDocument.push(newpayment2);
                                    const newInvoice = new invoiceTable({
                                        invoiceNumber: invoiceNumber,
                                    })
                                    await newInvoice.save();
                                } else {
                                    failureCount++;
                                    let obj = {
                                        myBatchId: myBatches[i]?._id,
                                        user: myBatches[i]?.user,
                                        batch: myBatches[i]?.batch_id,
                                    }
                                    failureArray.push(obj);
                                }
                                resolve();
                            }, 200)
                        }
                        )
                        // }
                    }

                } else {

                    let latestInvoice = await invoiceTable.find({}).sort({ createdAt: -1 }).limit(1);
                    let invoiceNumber = parseInt(latestInvoice[0]?.invoiceNumber ?? 0) + 1;
                    let addressArray = myBatches[i]?.user?.Address?.split(',');
                    let isState = addressArray[addressArray?.length - 2] ?? "";
                    let state = isState != "" ? isState?.trim() : "Uttar Pradesh";
                    let year = `${moment().format('YY')}-${parseInt(moment().format('YY')) + 1}`
                    const dataForInvoice = {
                        invoiceNumber: `${year}/${invoiceNumber}`,
                        invoiceDate: moment().format("DD-MM-YYYY"),
                        studentName: myBatches[i]?.user?.FullName ?? "NA",
                        studentAddress: myBatches[i]?.user?.Address ?? "",
                        SDAddress: `Plot No-16, Block 7, Sector 5, Rajendra Nagar, Ghaziabad,Uttar Pradesh, 201005`,
                        items: [{ name: myBatches[i]?.batch_id?.batch_name ?? "", price: parseInt(courseOrder?.totalAmount), quantity: 1 }],
                        studentEmail: myBatches[i]?.user?.email != 'user@gmail.com' ? myBatches[i]?.user?.email : 'NA',
                        studentPhone: myBatches[i]?.user?.mobileNumber,
                        studentState: state,
                        gstNumber: "09ABBCS1440F1ZN"
                    }
                    // if (courseOrder?.invoice?.length == 0) {
                    const FileUploadLocation = await pdfGenerate(dataForInvoice);
                    const pdfFilePath = path.join(__dirname, '../', FileUploadLocation);
                    let fileName = path.basename(pdfFilePath, path.extname(pdfFilePath));
                    let ext = path.extname(pdfFilePath)

                    let fileLoc = ''
                    const helperString = Math.floor(Date.now() / 1000);
                    let FileUploadLocation2 = `invoice/invoice/${fileName}_${helperString}${ext}`;
                    await new Promise(resolve => {
                        setTimeout(async () => {
                            fileLoc = await uploadFile(pdfFilePath, FileUploadLocation2);
                            let newpayment3 = await courseOrdesTable.findOneAndUpdate({ courseId: myBatches[i]?.batch_id?._id, user: myBatches[i]?.user?._id }, { invoice: [{ installmentNumber: "1", fileUrl: fileLoc }] }, { new: true, lean: true })
                            // console.log('courseOrder EMi ' + newpayment3);
                            console.log('Without emi website', fileLoc);

                            if (newpayment3?.invoice?.length >= 1 && newpayment3?.invoice[0]?.fileUrl != "") {
                                successCount++;
                                successDocument.push(newpayment3);
                                webSiteSuccessDocument.push(newpayment3);
                                const newInvoice = new invoiceTable({
                                    invoiceNumber: invoiceNumber,
                                })
                                await newInvoice.save();
                            } else {
                                failureCount++;
                                let obj = {
                                    myBatchId: myBatches[i]?._id,
                                    user: myBatches[i]?.user,
                                    batch: myBatches[i]?.batch_id,
                                }
                                failureArray.push(obj);
                            }
                            resolve();
                        }, 200)
                    }
                    )
                    // console.log(' running....')


                    // }
                }
            }

        }
        // setTimeout(() => {
        return res.json({
            status: true,
            data: { failureArray, failureCount, successCount, successDocument, appSuccesDocument, webSiteSuccessDocument, total: myBatches.length, documents: myBatches },
            msg: 'Invoice genrated'
        })
        // }, 4000)
        // return res.json({
        //     status: true,
        //     data: { failureArray, failureCount, successCount, successDocument, total: myBatches.length },
        //     msg: 'Invoice genrated'
        // })

    } catch (error) {
        return res.json({
            status: false,
            data: null,
            msg: error.message
        })
    }
})


AdminPanel.put("/logoutAdmin/:id", isAdmin, async (req, res) => {
    const { id } = req.params;
    if (!id) {
        return res.json({
            status: false,
            data: null,
            msg: 'Required Id'
        })
    }
    try {
        const decode = jwt.verify(req.token, process.env.ADMIN_SECRET_KEY);
        const admin = await findAdminTeacherUsingUserId(decode?.studentId);
        if (!admin) {
            return res.json({
                status: false,
                data: null,
                msg: 'Not A Admin'
            })
        }
        const logoutUser = await adminTeacherTable.findByIdAndUpdate(id, { refreshToken: "" }, { new: true, lean: true })
        return res.json({
            status: true,
            data: null,
            msg: `${logoutUser?.FullName} logout from device`
        })
    } catch (error) {
        return res.json({
            status: false,
            data: null,
            msg: error.message
        })
    }
})

AdminPanel.get("/getLectureForTwoWay", isAdmin, async (req, res) => {
    const { id } = req.query;
    if (!id) {
        return res.json({
            status: false,
            data: null,
            msg: 'Required id '
        })
    }
    try {
        const decode = jwt.verify(req.token, process.env.ADMIN_SECRET_KEY);
        const admin = await findAdminTeacherUsingUserId(decode?.studentId);
        if (!admin) {
            return res.json({
                status: false,
                data: null,
                msg: 'Not A Admin'
            })
        }
        let isLecture = await LectureTable.findOne({ _id: id, isActive: true }).populate("subject", 'title')
            .populate({
                path: 'teacher',
                select: "FullName profilePhoto demoVideo category",

            }).populate('batch', '_id batch_name slug');
        return res.json({
            status: true,
            data: {

                _id: isLecture?._id ?? "",
                lectureType: isLecture?.lecture_type ?? "",
                lectureTitle: isLecture?.lecture_title ?? "",
                description: isLecture?.description ?? "",
                teacher: { name: isLecture?.teacher[0]?.FullName ?? "", profilePhoto: isLecture?.teacher[0]?.profilePhoto ?? "", demoVideo: isLecture?.teacher[0]?.demoVideo ?? "" } ?? { name: "", profilePhoto: "", demoVideo: "" },
                subject: isLecture?.subject ?? {},
                link: isLecture?.link ?? "",
                // rooms: rooms.map((item) => { return { roomId: item?._id ?? "", students: item?.students ?? [], title: item?.title } }),
                LiveOrRecorded: isLecture?.LiveOrRecorded ?? "",
                starting_date: isLecture?.starting_date ?? "",
                ending_date: isLecture?.ending_date ?? "",
                duration: moment(isLecture?.ending_date, 'DD-MM-YYYY HH:mm:ss').diff(moment(isLecture?.starting_date, 'DD-MM-YYYY HH:mm:ss'), 'minutes'),
                material: isLecture?.material ?? "",
                dpp: isLecture?.dpp ?? "",
                ytLiveChatId: isLecture?.ytLiveChatId ?? "",
                createdAt: isLecture?.created_at ?? "",
                language: isLecture?.language ?? "",
                socketUrl: isLecture?.socketUrl ?? "",
                banner: isLecture?.banner ?? "",
                commonName: isLecture?.commonName ?? "",
                //   batchSlug : isLecture?.batch?.slug ?? "",
                batchDetails: { id: isLecture?.batch?._id ?? "", batchName: isLecture?.batch?.batch_name ?? "", batchSlug: isLecture?.batch?.slug ?? "" }
            }
            ,
            msg: 'Lecture Details fetched'
        })

    } catch (error) {
        return res.json({
            status: false,
            data: null,
            msg: error.message
        })
    }
})

AdminPanel.get('/getLectureReports', isAdmin, async (req, res) => {
    const { lectureId } = req.query;
    if (!lectureId) {
        return res.json({
            status: false,
            data: null,
            msg: 'Required Lecture Id'
        })
    }
    try {
        const decode = jwt.verify(req.token, process.env.ADMIN_SECRET_KEY);
        const admin = await findAdminTeacherUsingUserId(decode?.studentId);
        if (!admin) {
            return res.json({
                status: false,
                data: null,
                msg: 'Not A Admin'
            })
        }
        const reports = await lectureReportTable.find({ lectureId: lectureId }).populate('lectureId', 'lecture_title').populate('user', "email mobileNumber FullName")
        return res.json({
            status: true,
            data: reports.map((item, index) => {
                return {
                    id: item?._id,
                    sno: index + 1,
                    title: item?.title,
                    userDetails: {
                        name: item?.user?.FullName ?? "",
                        phone: item?.user?.mobileNumber ?? "",
                        email: item?.user?.email ?? "",
                        lectureName: item?.lectureId?.lecture_title ?? ""
                    }
                }
            }),
            msg: 'Reports of Lecture'
        })

    } catch (error) {
        return res.json({
            status: false,
            data: null,
            msg: error.message
        })
    }
})

AdminPanel.get("/lectureAttendence", isAdmin, async (req, res) => {
    const { commonName } = req.query;
    if (!commonName) {
        return res.json({
            status: false,
            data: null,
            msg: 'Required commonName'
        })
    }
    try {
        const decode = jwt.verify(req.token, process.env.ADMIN_SECRET_KEY);
        const admin = await findAdminTeacherUsingUserId(decode.studentId);
        if (!admin) {
            return res.json({
                status: false,
                data: null,
                msg: 'NOt an admin'
            })
        }
        const lectures = await LectureTable.find({ commonName: commonName }).select('commonName subject teacher').populate('subject', 'title').populate('teacher', 'FullName');
        let lectureIds = lectures?.map((item) => { return item?._id });
        let timeSpends = await timeSpendOnLecture.find({ lecture: lectureIds }).populate("user", "_id FullName email mobileNumber").populate({
            path: 'lecture',
            select: "_id batch teacher lecture_title subject starting_date ending_date",
            populate: {
                path: "teacher",
                select: "_id FullName Role"
            },
            populate: {
                path: 'batch',
                select: '_id batch_name'
            }
        });
        // console.log(timeSpends[0]?.teacher);
        const hashmap = new Map();
        for (let timespend of timeSpends) {
            // console.log(timespend.lecture.teacher)
            let time = convertSecondsToTime(timespend?.timeSpend);
            let obj = {
                Name: timespend?.user?.FullName,
                Phone: timespend?.user?.mobileNumber,
                Email: timespend?.user?.email == 'user@gmail.com' ? "NA" : timespend?.user?.email,
                Duration: time?.includes('NaN') ? "0s" : time,
                lectureName: timespend?.lecture?.lecture_title,
                batchName: timespend?.lecture?.batch?.batch_name,
                lectureStartDateTime: timespend?.lecture?.starting_date,
                lectureEndDateTime: timespend?.lecture?.ending_date,
                subject: lectures[0]?.subject?.title ?? "",
                teacherName: lectures[0]?.teacher[0]?.FullName ?? "",
            }
            // timespend?.timeSpend =   (timespend?.timeSpend / 60)
            if (!hashmap.has(timespend?.lecture?.batch?.batch_name)) {
                hashmap.set(timespend?.lecture?.batch?.batch_name, [obj]);
            } else {
                let array = hashmap.get(timespend?.lecture?.batch?.batch_name);
                array.push(obj);
                hashmap.set(timespend?.lecture?.batch?.batch_name, array);
            }

        }
        // console.log(hashmap)
        let response = [...hashmap].map(([name, value]) => ({ batchName: name, timeSpendOnLecture: value }));
        return res.json({
            status: true,
            data: response ?? [],
            msg: 'timeSpends feched'
        })
    } catch (error) {
        return res.json({
            status: false,
            data: null,
            msg: error.message
        })
    }
})

AdminPanel.post("/createDeepLink", upload.single('file'), isAdmin, async (req, res) => {
    const { route, rootId, child, utmSource, utmContent, utmTerm, utmCampaign, utmMedium, socialTitle, socialDescription } = req.body;
    if (!['batchbyid', 'dailyQuizbyid', 'feedById', 'scholarshipTestById', 'productByID', 'storeCatagorybyid']?.includes(route) || !rootId) {
        return res.json({
            status: false,
            data: null,
            msg: 'Not Valid type or specific'
        })
    }
    try {
        const decode = jwt.verify(req.token, process.env.ADMIN_SECRET_KEY);
        const admin = await findAdminTeacherUsingUserId(decode?.studentId);
        if (!admin) {
            return res.json({
                status: false,
                data: null,
                msg: 'Not A Admin'
            })
        }
        let link = (route == 'productByID' || route == 'storeCatagorybyid') ? `https://store.sdcampus.com/?route=${route}&rootId=${rootId}&childId=null` : `https://www.sdcampus.com?route=${route}&rootId=${rootId}&childId=null`
        let fileUrl = "";
        if (req.file) {
            size = req.file.size / (1024);
            if (size > 100) {
                return res.json({
                    status: false,
                    data: null,
                    msg: 'icon size 100KB allowed'
                })
            }
            const helperString = Math.floor(Date.now() / 1000);
            const filename = req.file.originalname.split(".")[0].replace(/\s+/g, '_').replace(/[^a-zA-Z0-9_]/g, '');
            const extension = "." + req.file.originalname.split(".").pop();
            FileUploadLocation = `deepLink/${socialTitle.replace(/\s+/g, '_').replace(/[^a-zA-Z0-9_]/g, '')}/${filename}_${helperString}${extension}`;
            let helperfileLoc = await uploadFile(req.file.path, FileUploadLocation);
            fileLoc = helperfileLoc;
            fileUrl = fileLoc
        } else {
            fileUrl = ""
        }
        let details = {
            "link": link ?? "",
            "utmSource": utmSource ?? "",
            "utmMedium": utmMedium ?? "",
            "utmCampaign": utmCampaign ?? "",
            "utmTerm": utmTerm ?? "",
            "utmContent": utmContent ?? "",
            "socialTitle": socialTitle ?? "",
            "socialDescription": socialDescription ?? "",
            "socialImageLink": fileUrl ?? ""
        }
        // console.log(details);
        if (route == 'batchbyid') {
            let batch = await BatchesTable.findOne({ _id: rootId, is_active: true });
            if (batch) {
                const data = await genrateDeepLink(details);
                await BatchesTable.findByIdAndUpdate(batch?._id, { shareLink: { link: data.shortLink, text: batch?.batch_name } })
            } else {
                return res.json({
                    status: false,
                    data: null,
                    msg: `Batch not found `
                })
            }

        } else if (route == 'dailyQuizbyid') {
            let batch = await QuizTable.findOne({ _id: rootId, is_active: true });
            if (batch) {
                const data = await genrateDeepLink(details);
                await QuizTable.findByIdAndUpdate(batch?._id, { shareLink: { link: data.shortLink, text: batch?.quiz_title } })
            } else {
                return res.json({
                    status: false,
                    data: null,
                    msg: `Quiz not found `
                })
            }
        } else if (route == 'feedById') {
            let batch = await cmsPostTable.findOne({ _id: rootId, is_active: true });
            if (batch) {
                const data = await genrateDeepLink(details);
                await cmsPostTable.findByIdAndUpdate(batch?._id, { shareLink: { link: data.shortLink, text: batch?.title } })
            } else {
                return res.json({
                    status: false,
                    data: null,
                    msg: `Post not found `
                })
            }
        } else if (route == 'scholarshipTestById') {
            const test = await scholarshipTestTable.findOne({ _id: rootId, isActive: true });
            if (test) {
                const data = await genrateDeepLink(details);
                await scholarshipTestTable.findByIdAndUpdate(test?._id, { shareLink: { link: data.shortLink, text: test?.title } })
            } else {
                return res.json({
                    status: false,
                    data: null,
                    msg: `Scholarship test not foud`
                })
            }
        } else if (route == 'productByID') {
            const test = await storeProductTable.findOne({ _id: rootId, isActive: true });
            if (test) {
                const data = await genrateDeepLink(details);
                await storeProductTable.findByIdAndUpdate(test?._id, { shareLink: { link: data.shortLink, text: test?.title } })
            } else {
                return res.json({
                    status: false,
                    data: null,
                    msg: `Store Product not found`
                })
            }
        } else if (route == 'storeCatagorybyid') {
            const test = await productCategoryTable.findOne({ _id: rootId, isActive: true });
            if (test) {
                const data = await genrateDeepLink(details);
                await productCategoryTable.findByIdAndUpdate(test?._id, { shareLink: { link: data.shortLink, text: test?.title } })
            } else {
                return res.json({
                    status: false,
                    data: null,
                    msg: `Product Category not found`
                })
            }
        }
        return res.json({
            status: true,
            data: null,
            msg: `Deep Link Genrated`
        })
    } catch (error) {
        return res.json({
            status: false,
            data: null,
            msg: error.message
        })
    }
})

AdminPanel.get("/getDynamicLinks", isAdmin, async (req, res) => {
    try {
        const decode = jwt.verify(req.token, process.env.ADMIN_SECRET_KEY);
        const admin = await findAdminTeacherUsingUserId(decode?.studentId);
        if (!admin) {
            return res.json({
                status: false,
                data: null,
                msg: 'Not A Admin'
            })
        }
        let responseArr = [];
        const batches = await BatchesTable.find({ shareLink: { $exists: true } });
        const cmsPost = await cmsPostTable.find({ shareLink: { $exists: true } });
        const products = await storeProductTable.find({ shareLink: { $exists: true } });
        const prodCat = await productCategoryTable.find({ shareLink: { $exists: true } });
        const test = await scholarshipTestTable.find({ shareLink: { $exists: true } });
        const quiz = await QuizTable.find({ shareLink: { $exists: true } });
        for (let item of batches) {
            let obj = {
                id: item?._id,
                type: 'Batch',
                link: item?.shareLink?.link ?? "",
                text: item?.shareLink?.text ?? "",
            }
            responseArr.push(obj);
        }
        for (let item of cmsPost) {
            let obj = {
                id: item?._id,
                type: 'Cms Post',
                link: item?.shareLink?.link ?? "",
                text: item?.shareLink?.text ?? "",
            }
            responseArr.push(obj);
        }
        for (let item of products) {
            let obj = {
                id: item?._id,
                type: 'Store Products',
                link: item?.shareLink?.link ?? "",
                text: item?.shareLink?.text ?? "",
            }
            responseArr.push(obj);
        }
        for (let item of prodCat) {
            let obj = {
                id: item?._id,
                type: 'Store Category',
                link: item?.shareLink?.link ?? "",
                text: item?.shareLink?.text ?? "",
            }
            responseArr.push(obj);
        }
        for (let item of test) {
            let obj = {
                id: item?._id,
                type: 'Scholar Ship Test',
                link: item?.shareLink?.link ?? "",
                text: item?.shareLink?.text ?? "",
            }
            responseArr.push(obj);
        }
        for (let item of quiz) {
            let obj = {
                id: item?._id,
                type: 'Quiz',
                link: item?.shareLink?.link ?? "",
                text: item?.shareLink?.text ?? "",
            }
            responseArr.push(obj);
        }
        return res.json({
            status: true,
            data: responseArr,
            msg: 'All Dynamic Links fetched'
        })
        // const cmsPost =  await cmsPostTable.find({ shareLink : { $exists : true}});


    } catch (error) {
        return res.json({
            status: false,
            data: null,
            msg: error.message
        })
    }
})

AdminPanel.put("/changeAccessOfStudentForBatch/:id", isAdmin, async (req, res) => {
    const { id } = req.params;
    if (!id) {
        return res.json({
            status: false,
            data: null,
            msg: `Required Id`
        })
    }
    try {
        const decode = jwt.verify(req.token, process.env.ADMIN_SECRET_KEY);
        const admin = await findAdminTeacherUsingUserId(decode?.studentId);
        if (!admin) {
            return res.json({
                status: false,
                data: null,
                msg: 'Not A Admin'
            })
        }
        const isMyBatch = await MybatchTable.findOne({ _id: id });
        if (!isMyBatch) {
            return res.json({
                status: false,
                data: null,
                msg: `My Batch not found`
            })
        }
        const myBatch = await MybatchTable.findByIdAndUpdate(id, { is_active: !isMyBatch?.is_active }, { new: true, lean: true });
        return res.json({
            status: true,
            data: null,
            msg: `Student is  ${myBatch?.is_active == true ? 'enroll in' : 'removed from'} batch`
        })
    } catch (error) {
        return res.json({
            status: false,
            data: null,
            msg: error.message
        })
    }
})

AdminPanel.get("/purchasedCourseByUser/:user", isAdmin, async (req, res) => {
    const { user } = req.params;
    try {
        const decode = jwt.verify(req.token, process.env.ADMIN_SECRET_KEY);
        const admin = await findAdminTeacherUsingUserId(decode?.studentId);
        if (!admin) {
            return res.json({
                status: false,
                data: null,
                msg: 'Not A Admin'
            })
        }
        const myBatches = await MybatchTable.find({ user: user }).populate('batch_id');
        return res.json({
            status: true,
            data: myBatches.map((item, index) => {
                return {
                    sno: index + 1,
                    id: item?._id ?? "",
                    batchId: item?.batch_id?._id,
                    batchName: item?.batch_id?.batch_name,
                    regularPrice: item?.batch_id?.charges,
                    salePrice: item?.batch_id?.discount,
                    studentCount: item?.batch_id?.student.length,
                    isPaid: item?.batch_id?.isPaid,
                    starting_date: item?.batch_id?.starting_date,
                    ending_date: item?.batch_id?.ending_date,
                    is_active: item?.batch_id?.is_active,
                }
            }),
            msg: `Batches Fetched`
        })
    } catch (error) {
        return res.json({
            status: false,
            data: null,
            msg: error.message
        })
    }
})

AdminPanel.get("/getSalePanelDetails", isAdmin, async (req, res) => {
    try {
        const decode = jwt.verify(req.token, process.env.ADMIN_SECRET_KEY);
        const admin = await findAdminTeacherUsingUserId(decode?.studentId);
        if (!admin) {
            return res.json({
                status: false,
                data: null,
                msg: 'Not A Admin'
            })
        }

        const payment = await paymentTransactionTable.find({ success: true })
        const webPayment = await courseTxnTable.find({ isPaid: true });

        let totalSaleBatch = payment.length + webPayment.length;
        let totalAmount = 0;
        payment.map((item) => {
            totalAmount += parseInt(item?.amount)
        })
        webPayment.map((item) => {
            totalAmount += parseInt(item?.txnAmount)
        })

        // sale emi next month due 
        let today = new Date();
        let year = today.getFullYear();
        let month = today.getMonth();

        let todayStartDate = new Date()
        todayStartDate.setHours(0, 0, 0, 0);
        let todayEndDate = new Date()
        todayEndDate.setHours(23, 59, 59, 59);


        if (month === 11) {
            year++;
            month = 0;

        } else {
            month++;
        }
        let nextMonthStartDate = new Date(year, month, 1)
        nextMonthStartDate.setHours(0, 0, 0, 0);
        let nextMonthEndDate = new Date(year, month + 1, 0)
        nextMonthStartDate.setHours(23, 59, 59, 59);

        const nextEmiMonth = await saleEmiTable.find({ isPaid: false, installmentDate: { $gte: nextMonthStartDate.toISOString(), $lte: nextMonthEndDate.toISOString() } })
        // console.log(nextEmiMonth);
        let nextMonthDue = nextEmiMonth?.reduce((acc, curr) => acc + parseInt(curr?.amount), 0)
        // sale today due 
        const todayEmiMonth = await saleEmiTable.find({ isPaid: false, installmentDate: { $gte: todayStartDate.toISOString(), $lte: todayEndDate.toISOString() } });
        // console.log(todayEmiMonth);
        let todayDue = todayEmiMonth?.reduce((acc, curr) => acc + parseInt(curr?.amount), 0)
        const overDueEmi = await saleEmiTable.find({ isPaid: false, installmentDate: { $lte: today } });
        let overDue = overDueEmi?.reduce((acc, curr) => acc + parseInt(curr?.amount), 0)
        // overDue 
        return res.json({
            status: true,
            data: { totalAmount, totalSaleBatch, todayDue, nextMonthDue, overDue },
            msg: 'details fetched'
        })

    } catch (error) {
        return res.json({
            status: false,
            data: null,
            msg: error.message
        })
    }
})

AdminPanel.get("/saleMyBatchDetails/:id", isAdmin, async (req, res) => {
    const { id } = req.params;
    try {
        const decode = jwt.verify(req.token, process.env.ADMIN_SECRET_KEY);
        const admin = await findAdminTeacherUsingUserId(decode?.studentId);
        if (!admin) {
            return res.json({
                status: false,
                data: null,
                msg: 'Not A Admin'
            })
        }
        const myBatchDetails = await MybatchTable.findOne({ _id: id });
        // 
        console.log(myBatchDetails);
        const emis = await saleEmiTable.find({ batch: myBatchDetails?.batch_id, user: myBatchDetails?.user }).sort({ createdAt: 1 })
        return res.json({
            status: true,
            data: [{
                id: myBatchDetails?._id ?? "",
                enrollDate: moment(myBatchDetails?.createdAt).format('DD-MM-YYYY') ?? "",
                enrollAmount: parseInt(myBatchDetails?.enrollAmount) ?? 0,
                totalAmountReceived: parseInt(myBatchDetails?.totalAmountReceived) ?? 0,
                pendingAmount: parseInt(myBatchDetails?.enrollAmount) - parseInt(myBatchDetails?.totalAmountReceived) ?? 0,
                noOfEmi: emis.length ?? "",
                // noOfEmi : 0 ,
                nextEmiDate: "",
                // emiData : emis.map((item) =>{
                //     return {
                //         id : item?._id ?? "" ,
                //         emiNumber : item?.emiNumber ?? 0 ,
                //         txnId : item?.txnId ?? "" ,
                //         txnAmount : item?.txnAmount ?? "" ,
                //         txnMode : item?.txnMode ?? "" ,
                //         txnDate : item?.txnDate ?? "" ,
                //     }
                // })
            }],
            msg: 'details fetched'
        })

    } catch (error) {
        return res.json({
            status: false,
            data: null,
            msg: error.message
        })
    }
})

AdminPanel.get("/saleEmiDetails/:id", isAdmin, async (req, res) => {
    const { id } = req.params;
    try {
        const decode = jwt.verify(req.token, process.env.ADMIN_SECRET_KEY);
        const admin = await findAdminTeacherUsingUserId(decode?.studentId);
        if (!admin) {
            return res.json({
                status: false,
                data: null,
                msg: 'Not A Admin'
            })
        }
        const myBatchDetails = await MybatchTable.findOne({ _id: id });
        // 
        const emis = await saleEmiTable.find({ myBatchId: myBatchDetails?._id, batch: myBatchDetails?.batch_id, user: myBatchDetails?.user }).sort({ createdAt: 1 })
        return res.json({
            status: true,
            data: emis.map((item, index) => {
                return {
                    id: item?._id ?? "",
                    emiNumber: index + 1 ?? 0,
                    txnId: item?.txnId ?? "",
                    expectedDate: moment(item?.installmentDate),
                    txnAmount: item?.amount ?? "",
                    txnMode: item?.txnMode ?? "",
                    txnDate: moment(item?.txnDate),
                    isPaid: item?.isPaid,
                }
            }),
            msg: 'details fetched'
        })

    } catch (error) {
        return res.json({
            status: false,
            data: null,
            msg: error.message
        })
    }
})
AdminPanel.post("/updateSaleMyBatchdetails/:id", isAdmin, async (req, res) => {
    const { id } = req.params;
    let { enrollAmount, totalAmountReceived, noOfEmi } = req.body;
    try {
        const decode = jwt.verify(req.token, process.env.ADMIN_SECRET_KEY);
        const admin = await findAdminTeacherUsingUserId(decode?.studentId);
        if (!admin) {
            return res.json({
                status: false,
                data: null,
                msg: 'Not A Admin'
            })
        }
        // enrollAmount = parschormeInt(enrollAmount)
        // let isMyExist = await 
        // if( )
        const myBatchDetails = await MybatchTable.findOneAndUpdate({ _id: id }, { enrollAmount, totalAmountReceived });
        const saleEmisExist = await saleEmiTable.find({ user: myBatchDetails?.user, batch: myBatchDetails?.batch_id });
        if (saleEmisExist?.length == 0) {
            for (let i = 0; i < parseInt(noOfEmi); i++) {
                const newSaleEmi = new saleEmiTable({
                    user: myBatchDetails?.user,
                    admin: admin?._id,
                    batch: myBatchDetails?.batch_id,
                    amount: 0,
                    isPaid: false,
                    myBatchId: myBatchDetails?._id,
                    // installmentDate : 
                    // txnMode : ""
                    // txnId : ""
                })
                await newSaleEmi.save();
            }
        }
        // 
        // const emis = await saleEmiTable.find({ batch : myBatchDetails?.batch_id , user : myBatchDetails?.user}).sort({ createdAt : 1})
        return res.json({
            status: true,
            data: null,
            msg: 'details updated'
        })

    } catch (error) {
        return res.json({
            status: false,
            data: null,
            msg: error.message
        })
    }
})

AdminPanel.post("/updateSaleEmiDetails/:id", isAdmin, async (req, res) => {
    const { id } = req.params;
    let { installmentDate, txnDate, txnId, amount, txnMode, isPaid } = req.body;
    if (!["QR", "Link", "AccountTransfer", "JODO", "ShopeSe"].includes(txnMode)) {
        return res.json({
            status: false,
            data: null,
            msg: 'txn mode can be ["QR" ,"Link", "AccountTransfer","JODO","ShopeSe"]'
        })
    }
    try {
        const decode = jwt.verify(req.token, process.env.ADMIN_SECRET_KEY);
        const admin = await findAdminTeacherUsingUserId(decode?.studentId);
        if (!admin) {
            return res.json({
                status: false,
                data: null,
                msg: 'Not A Admin'
            })
        }
        installmentDate = new Date(installmentDate);
        txnDate = new Date(txnDate);
        const newEmi = await saleEmiTable.findByIdAndUpdate(id, { txnDate, installmentDate, txnId, amount, isPaid, txnMode })
        // console.log(newEmi);
        if (newEmi?.isPaid == false && isPaid == true) {
            // let myBatch = await MybatchTable.findOne({ user: newEmi?.user, batch: newEmi.batch });
            let myBatch = await MybatchTable.findOne({ _id: newEmi?.myBatchId, user: newEmi?.user, batch: newEmi.batch });

            let receviedAmount = parseInt(myBatch.totalAmountReceived) + parseInt(amount);
            // console.log("new amount recieved"  ,receviedAmount)
            // console.log("myBatchBefore" ,myBatch)
            // let pendingAmount = parseInt(myBatch.totalAmountReceived) + parseInt(amount);

            const newMyBatch = await MybatchTable.findOneAndUpdate({ _id: myBatch?._id }, { totalAmountReceived: receviedAmount }, { new: true, lean: true })
            //    console.log("after changes in amount" , newMyBatch);
        }
        // 
        // const emis = await saleEmiTable.find({ batch : myBatchDetails?.batch_id , user : myBatchDetails?.user}).sort({ createdAt : 1})
        return res.json({
            status: true,
            data: null,
            msg: 'details updated'
        })

    } catch (error) {
        return res.json({
            status: false,
            data: null,
            msg: error.message
        })
    }
})

AdminPanel.get("/dashBoardGrid", isAdmin, async (req, res) => {
    let { type, page, pageSize, } = req.query;
    try {
        page = parseInt(page) || 1;
        pageSize = parseInt(pageSize) || 25;
        // console.log(page , pageSize);
        const decode = jwt.verify(req.token, process.env.ADMIN_SECRET_KEY);
        const admin = await findAdminTeacherUsingUserId(decode?.studentId);
        if (!admin) {
            return res.json({
                status: false,
                data: null,
                msg: 'Not A Admin'
            })
        }
        let response = [];
        let count = 0;
        // console.log(type);
        if (type === 'soldBatches') {
            let data = await MybatchTable.aggregate([
                {
                    $facet: {
                        batches: [
                            //     {
                            //     // $match: { isPaid : false , installmentDate : { $gte : todayStartDate.toISOString(), $lte : todayEndDate.toISOString() }  },
                            //   },
                            { $skip: (page - 1) * pageSize },
                            { $limit: pageSize },
                            {
                                $sort: { "createdAt": -1 }
                            },
                            {
                                $lookup: {
                                    from: 'batchestables',
                                    localField: 'batch_id',
                                    foreignField: '_id',
                                    as: 'batch',
                                },
                            },
                            {
                                $unwind: {
                                    path: "$batch",
                                    preserveNullAndEmptyArrays: true,
                                },
                            },
                            {
                                $lookup: {
                                    from: "userstables",
                                    localField: "user",
                                    foreignField: "_id",
                                    as: "user",
                                },
                            },
                            {
                                $unwind: {
                                    path: "$user",
                                    preserveNullAndEmptyArrays: true,
                                },
                            },
                            { $sort: { createdAt: -1 } }
                        ],
                        totalCounts: [
                            // { $match :{ isPaid : false , installmentDate : { $gte : todayStartDate.toISOString(), $lte : todayEndDate.toISOString() } }} ,
                            { $group: { _id: null, count: { $sum: 1 } } },
                        ]
                    }
                },
                {
                    $project: {
                        batches: 1,
                        totalCounts: { $arrayElemAt: ['$totalCounts', 0] },

                    }
                }

            ])
            // const soldBatches =  await MybatchTable.find({ is_active : true }).sort({ createdAt : -1 }).skip((page - 1) * pageSize).limit(pageSize).populate('batch_id' , 'batch_name').populate('user', 'mobileNumber email FullName');
            for (let batch of data[0].batches) {
                if (batch?.batch?.batch_name && batch.user?.mobileNumber) {
                    response.push({
                        id: batch?._id ?? "",
                        batchName: batch?.batch?.batch_name ?? "",
                        studentName: batch.user?.FullName ?? "",
                        studentEmail: batch.user?.email ?? "",
                        studentPhone: batch.user?.mobileNumber ?? "",
                        amount: batch.amount ?? ""
                    })
                }

            }
            count = data[0]?.totalCounts?.count;

        } else if (type === "todayDue") {
            // console.log('today Due');
            let todayStartDate = new Date();
            todayStartDate.setHours(0, 0, 0, 0);
            let todayEndDate = new Date();
            todayEndDate.setHours(23, 59, 59, 59);
            let data = await saleEmiTable.aggregate([
                {
                    $facet: {
                        emis: [{
                            $match: { isPaid: false, installmentDate: { $gte: todayStartDate, $lte: todayEndDate } },
                        },
                        { $skip: (page - 1) * pageSize },
                        { $limit: pageSize },
                        {
                            $sort: { "createdAt": -1 }
                        },
                        {
                            $lookup: {
                                from: 'batchestables',
                                localField: 'batch',
                                foreignField: '_id',
                                as: 'batch',
                            },
                        },
                        {
                            $unwind: {
                                path: "$batch",
                                preserveNullAndEmptyArrays: true,
                            },
                        },
                        {
                            $lookup: {
                                from: "userstables",
                                localField: "user",
                                foreignField: "_id",
                                as: "user",
                            },
                        },
                        {
                            $unwind: {
                                path: "$user",
                                preserveNullAndEmptyArrays: true,
                            },
                        },
                        ],
                        totalCounts: [
                            { $match: { isPaid: false, installmentDate: { $gte: todayStartDate, $lte: todayEndDate } } },
                            { $group: { _id: null, count: { $sum: 1 } } },
                        ]
                    }
                },
                {
                    $project: {
                        emis: 1,
                        totalCounts: { $arrayElemAt: ['$totalCounts', 0] },

                    }
                }

            ])
            // console.log(data[0]?.emis)
            //    const todayEmiMonth =  await saleEmiTable.find({ isPaid : false , installmentDate : { $gte : todayStartDate.toISOString(), $lte : todayEndDate.toISOString() } }).sort({ createdAt : -1 }).skip((page - 1) * pageSize).limit(pageSize).populate('batch' , 'batch_name').populate('user' , 'mobileNumber email FullName');
            //    console.log(todayEmiMonth)
            for (let emi of data[0]?.emis) {
                if (emi?.batch?.batch_name && emi.user?.mobileNumber) {
                    response.push({
                        id: emi?._id ?? "",
                        batchName: emi?.batch?.batch_name ?? "",
                        studentName: emi.user?.FullName ?? "",
                        studentEmail: emi.user?.email ?? "",
                        studentPhone: emi.user?.mobileNumber ?? "",
                        amount: emi.amount ?? ""
                    })
                }

            }
            count = data[0]?.totalCounts?.count
            // console.log('today Due- 2');


        } else if (type === "nextMonthDue") {
            // sale emi next month due 

            let today = new Date();
            let year = today.getFullYear();
            let month = today.getMonth();
            if (month === 11) {
                year++;
                month = 0;

            } else {
                month++;
            }
            let nextMonthStartDate = new Date(year, month, 1)
            nextMonthStartDate.setHours(0, 0, 0, 0);
            let nextMonthEndDate = new Date(year, month + 1, 0)
            nextMonthStartDate.setHours(23, 59, 59, 59);
            // console.log()
            let data = await saleEmiTable.aggregate([
                {
                    $facet: {
                        emis: [{
                            $match: { isPaid: false, installmentDate: { $gte: nextMonthStartDate, $lt: nextMonthEndDate } },
                        },
                        { $skip: (page - 1) * pageSize },
                        { $limit: pageSize },
                        {
                            $sort: { "createdAt": -1 }
                        },
                        {
                            $lookup: {
                                from: 'batchestables',
                                localField: 'batch',
                                foreignField: '_id',
                                as: 'batch',
                            },
                        },
                        {
                            $unwind: {
                                path: "$batch",
                                preserveNullAndEmptyArrays: true,
                            },
                        },
                        {
                            $lookup: {
                                from: "userstables",
                                localField: "user",
                                foreignField: "_id",
                                as: "user",
                            },
                        },
                        {
                            $unwind: {
                                path: "$user",
                                preserveNullAndEmptyArrays: true,
                            },
                        },
                        ],
                        totalCounts: [
                            { $match: { isPaid: false, installmentDate: { $gte: nextMonthStartDate, $lte: nextMonthEndDate } } },
                            { $group: { _id: null, count: { $sum: 1 } } },
                        ]
                    }
                },
                {
                    $project: {
                        emis: 1,
                        totalCounts: { $arrayElemAt: ['$totalCounts', 0] },

                    }
                }

            ])
            // console.log(data[0]?.emi)

            // const nextEmiMonth =  await saleEmiTable.find({ isPaid : false , installmentDate : { $gte :nextMonthStartDate.toISOString(), $lt : nextMonthEndDate.toISOString() } }).sort({ createdAt : -1 }).skip((page - 1) * pageSize).limit(pageSize).populate('batch' , 'batch_name').populate('user' , 'mobileNumber email FullName');
            for (let emi of data[0].emis) {
                if (emi?.batch?.batch_name && emi.user?.mobileNumber) {
                    response.push({
                        id: emi?._id ?? "",
                        batchName: emi?.batch?.batch_name ?? "",
                        studentName: emi.user?.FullName ?? "",
                        studentEmail: emi.user?.email ?? "",
                        studentPhone: emi.user?.mobileNumber ?? "",
                        amount: emi.amount ?? ""
                    })
                }

            }
            count = data[0]?.totalCounts?.count


        } else if (type === 'overDue') {
            let today = new Date();
            let data = await saleEmiTable.aggregate([
                {
                    $facet: {
                        emis: [{
                            $match: { isPaid: false, installmentDate: { $lte: today } },
                        },
                        { $skip: (page - 1) * pageSize },
                        { $limit: pageSize },
                        {
                            $sort: { "createdAt": -1 }
                        },
                        {
                            $lookup: {
                                from: 'batchestables',
                                localField: 'batch',
                                foreignField: '_id',
                                as: 'batch',
                            },
                        },
                        {
                            $unwind: {
                                path: "$batch",
                                preserveNullAndEmptyArrays: true,
                            },
                        },
                        {
                            $lookup: {
                                from: "userstables",
                                localField: "user",
                                foreignField: "_id",
                                as: "user",
                            },
                        },
                        {
                            $unwind: {
                                path: "$user",
                                preserveNullAndEmptyArrays: true,
                            },
                        },
                        ],
                        totalCounts: [
                            { $match: { isPaid: false, installmentDate: { $lte: today } } },
                            { $group: { _id: null, count: { $sum: 1 } } },
                        ]
                    }
                },
                {
                    $project: {
                        emis: 1,
                        totalCounts: { $arrayElemAt: ['$totalCounts', 0] },

                    }
                }

            ])
            // console.log(data);
            count = data[0]?.totalCounts?.count;
            //    const overDueEmi =  await saleEmiTable.find({ isPaid : false , installmentDate : {  $lte : today} }).sort({ createdAt : -1 }).skip((page - 1) * pageSize).limit(pageSize).populate('batch' , 'batch_name').populate('user' , 'mobileNumber email FullName');;
            for (let emi of data[0]?.emis) {
                if (emi?.batch?.batch_name && emi.user?.mobileNumber) {
                    response.push({
                        id: emi?._id ?? "",
                        batchName: emi?.batch?.batch_name ?? "",
                        studentName: emi.user?.FullName ?? "",
                        studentEmail: emi.user?.email ?? "",
                        studentPhone: emi.user?.mobileNumber ?? "",
                        amount: emi.amount ?? ""
                    })
                }

            }

        }
        // console.log(`Hello`);
        return res.json({
            status: true,
            data: { response, count, },
            msg: `Grid Details fetched`
        })
    } catch (error) {
        return res.json({
            status: false,
            data: null,
            msg: error.message
        })
    }
})

AdminPanel.put("/changeLectureComment", isAdmin, async (req, res) => {
    const { lectureId } = req.query;
    if (!lectureId) {
        return res.json({
            status: false,
            data: null,
            msg: `Lecture Id Required`
        })
    }
    try {
        const decode = jwt.verify(req.token, process.env.ADMIN_SECRET_KEY);
        // console.log(decode?.studentId)
        const admin = await findAdminTeacherUsingUserId(decode?.studentId);
        if (!admin) {
            return res.json({
                status: false,
                data: null,
                msg: 'Not A Admin'
            })
        }
        const isLecture = await LectureTable.findOne({ _id: lectureId });
        if (!isLecture) {
            return res.json({
                status: false,
                data: null,
                msg: "Lecture not found"
            })
        }
        let isCommentAllowed = !isLecture?.isCommentAllowed
        await LectureTable.findByIdAndUpdate(isLecture?._id, { isCommentAllowed: isCommentAllowed });
        return res.json({
            status: true,
            data: null,
            msg: `Comment is ${isCommentAllowed == true ? 'allowed' : 'disable'} on ${isLecture?.lecture_title}`
        })

    } catch (error) {
        return res.json({
            status: false,
            data: null,
            msg: error.message
        })
    }
})

AdminPanel.get("/getAllSubCategoryForAdmin", isAdmin, async (req, res) => {
    try {
        const decoded = jwt.verify(req.token, process.env.ADMIN_SECRET_KEY);
        const adminDetails = await findAdminTeacherUsingUserId(decoded.studentId);
        if (!adminDetails) {
            return res.status(401).json({
                status: false,
                data: null,
                msg: "Not an admin",
            });
        }
        const allSubCategory = await subCategoryTable.find({}).populate('category', '_id title type');
        let filterSubCategory = [];
        for (let item of allSubCategory) {
            let obj = {
                id: item?._id,
                title: item?.title,
                label: item?.title,
                value: item?._id,
                slug: item?.slug,
            }
            if (item?.category?.type == 'Stream') {
                filterSubCategory.push(obj);
            }
        }
        return res.json({
            status: true,
            data: filterSubCategory,
            msg: `All Sub Category fetched`
        })
    } catch (error) {
        return res.json({
            status: false,
            data: null,
            msg: error.message
        })
    }
})

AdminPanel.get('/getSubCategoryForAdmin/:id', isAdmin, async (req, res) => {
    const { id } = req.params;
    if (!id) {
        return res.json({
            status: false,
            data: null,
            msg: `Required Id`
        })
    }
    try {
        const decoded = jwt.verify(req.token, process.env.ADMIN_SECRET_KEY);
        const adminDetails = await findAdminTeacherUsingUserId(decoded.studentId);
        if (!adminDetails) {
            return res.status(401).json({
                status: false,
                data: null,
                msg: "Not an admin",
            });
        }
        const subCategory = await subCategoryTable.findOne({ _id: id }).populate('category', '_id title');
        return res.json({
            status: true,
            data: {
                id: subCategory?._id,
                title: subCategory?.title,
                is_active: subCategory?.is_active,
                category: subCategory?.category,
                slug: subCategory?.slug,
                // id :  subCategory?._id ,

            },
            msg: 'Sub Categor details fetched.'
        })


    } catch (error) {
        return res.json({
            status: false,
            data: null,
            message: error.message
        })
    }
})

module.exports = AdminPanel;